<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java线程知识点（二）线程的构造和运行]]></title>
    <url>%2F2019%2F10%2F07%2F%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[① 用Thread类构造线程对象（继承Thread类来创建并启动多线程） 123456789101112131415161718192021222324252627282930313233343536373839package cn.sxt.thread;/** * 创建线程方式一： * 1、创建：继承Thread+重写run * 2、启动：创建子类对象+start * @author 1979 * */public class StartThread extends Thread&#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println("一边听歌"); &#125; &#125; public static void main(String[] args) &#123; /* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程 * for(int i=0;i&lt;20;i++) &#123; * System.out.println("一边coding"); * &#125; */ //创建子类对象 StartThread st = new StartThread(); //启动 st.start();//不保证立即运行 由cpu调用 //st.run();//普通方法调用，只能听完歌再敲代码 for(int i=0;i&lt;20;i++) &#123; System.out.println("一边coding"); &#125; &#125;&#125; 【运行结果】 12345678一边coding一边coding...一边听歌一边听歌...一边coding一边coding 【缺点】：由于java采用单继承机制，若为实现多线程而继承了Thread，将无法再继承其他类，是非常不明智的做法。 ② 用Runnable辅助构造线程（实现Runnable接口创建线程类） 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.sxt.thread;/*** * 创建线程方式二 * 1、创建：实现Runnable+重写run * 2、启动：创建实现类对象+Thread对象+start * * 推荐：避免单继承的局限性，优先使用接口 * 方便共享资源 * @author 1979 * */public class StartRun implements Runnable&#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println("一边听歌"); &#125; &#125; public static void main(String[] args) &#123; /* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程 * for(int i=0;i&lt;20;i++) &#123; * System.out.println("一边coding"); * &#125; */ //创建实现类对象 StartRun sr = new StartRun(); //创建代理类对象 Thread t = new Thread(sr); //启动 t.start();//不保证立即运行 由cpu调用 //st.run();//普通方法调用，只能听完歌再敲代码 for(int i=0;i&lt;20;i++) &#123; System.out.println("一边coding"); &#125; &#125;&#125; 【运行结果】 12345678一边coding一边coding...一边听歌一边听歌...一边coding一边coding 12345678910111213141516171819202122232425262728293031323334353637383940package liti_07;/*本例展现这样一种方式：利用Runnable接口直接构造线程并运行 *有如下关键点： *1、希望该类中创建线程对象，就必须有线程成员，即私有变量t; *2、在构造函数中构造t引用的线程对象，注意把自己作为参数传给t; *3、还需要启动线程。由于t长设为私有，故不能直接t.start()， * 需要设置其他方法，如本例另提供一个公共的start()方法。 **/public class Ch_7_3 implements Runnable&#123; public static void main (String[] args) &#123; System.out.print("Main 开始"); Ch_7_3 m1=new Ch_7_3(1,"奇数线程"); //注意，m1依旧不是线程对象 Ch_7_3 m2=new Ch_7_3(2,"偶数线程"); m1.start(); //注意，调用的是类R自己定义的start() m2.start(); System.out.print("当前共有"+ Thread.activeCount()+"个线程"); System.out.print("Main 结束"); &#125; private int d; private Thread t; //-----新增成员 public void start()&#123; t.start(); &#125; //-----关键点2 public Ch_7_3(int x, String s)&#123; d=x; //t=new Thread(this); t.setName(s); //----关键点1 t=new Thread(this,s); &#125; public void run()&#123; for(int i=d; i&lt;50;i=i+2) System.out.print(" "+i); //Thread t=Thread.currentThread(); //---此句不再需要 System.out.print(t.getName()+"结束！"); &#125; &#125; 线程的一些常用方法 1、currentThread() 返回对当前正在执行的线程对象的引用。 2、getId() 返回此线程的标识符 3、getName() 返回此线程的名称 4、getPriority() 返回此线程的优先级 5、isAlive() 测试这个线程是否还处于活动状态。 什么是活动状态呢？ 活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。 6、sleep(long millis) 使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。 7、interrupt() 中断这个线程。 8、interrupted() 和isInterrupted() interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能 isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但不清楚状态标志 9、 setName(String name) 将此线程的名称更改为等于参数 name 。 10、isDaemon() 测试这个线程是否是守护线程。 11、setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程。 12、join() 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。 join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行 13、yield() yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。 14、setPriority(int newPriority) 更改此线程的优先级]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3分钟教你Hexo如何绑定个人域名]]></title>
    <url>%2F2019%2F10%2F06%2FHexo%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[前两天用Hexo+GitHub搭建好了自己的个人博客http://tsundere-x.top/ ，默认域名github下的二级域名：username.github.io，为了提升访问速度和博客的格调，绑定个人域名是多数人的选择。下面给大家介绍详细过程。 购买域名 国内有很多不错的域名服务商，这里我给大家推荐阿里云的万网。我购买的域名是：tsundere-x.top。 大家可以根据自身的需求购买相应的域名。点击查域名后确认域名没有被使用后即可下单购买，当然在付款之前你还需要进行邮箱验证和实名认证（虽然上面提示实名认证需要3-5天，但正常情况下其实只要一个小时左右）。 实名认证通过后进行域名解析 在此之前需要获取自己 github 的二级域名的 IP地址 。cmd下ping+自己博客的地址即可获得。 实名认证后来到域名控制台，点击解析。 进入新手指导，将得到的 IP 地址填到记录值一栏 即可。 仓库的custom domain绑定域名 进入仓库中， 点击 setting 往下滑 会看到custom domain 将自己购买的域名填写进去 。 最后一步，设置CNAME 进入Hexo根目录下的source文件夹，新建CNAME文件（文件！！！，不需要任何后缀）。 接下来 使用 hexo d -g 重新部署，就可以成功访问咯！]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（一）]]></title>
    <url>%2F2019%2F10%2F05%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%E3%80%81Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1 程序、进程、线程之间的区别与联系 三者之间的形象化理解： * 程序：代码实现了功能，就是程序，是静态的； * 进程：执行中的程序就是进程，是动态的； * 线程：进程内的一个执行单元,也是进程内的可调度实体，可以并发执行提高了进程的效率。 进程和线程的关系：（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。（3）处理机分给线程，即真正在处理机上运行的是线程。（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 线程与进程的区别: (1) 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 。 (2) 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 。 (3) 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。 (4) 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 程序与进程的区别：程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。 程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。 进程更能真实地描述并发，而程序不能；进程是由程序和数据两部分组成的。进程具有创建其他进程的功能，而程序没有。 同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程。也就是说同一程序可以对应多个进程。 2 Java的线程状态和生命周期) ==新建状态:==使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 ==就绪状态:==当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 ==运行状态:==如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 ==阻塞状态:==如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O处理完毕，线程重新转入就绪状态。 ==死亡状态:==一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this和super的用法总结]]></title>
    <url>%2F2019%2F10%2F04%2FJava%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[this this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this 的用法在 Java 中大体可以分为3种： 1.普通的直接引用 this 相当于是指向当前对象本身。 2.形参与成员名字重名，用 this 来区分：123456789101112131415161718class Person &#123; private int age = 10; public Person()&#123; System.out.println("初始化年龄："+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println("Harry's age is "+Harry.GetAge(12)); &#125;&#125; 运行结果： 1初始化年龄：10 Harry&apos;s age is 12 可以看到，这里 age 是 GetAge 成员方法的形参，this.age 是 Person 类的成员变量。 3.引用构造函数supersuper 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super 也有三种用法： 1.普通的直接引用与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员。 2.子类中的成员变量或方法与父类中的成员变量或方法同名123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = "China"; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = "Shanghai"; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 运行结果： 1Shanghai China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法 value()，只调用父类变量 name 的话，则父类 name 值为默认值 null。 3.引用构造函数 super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 123456789101112131415161718192021222324252627282930313233343536class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt("父类·无参数构造方法： "+"A Person."); &#125;//构造方法(1) Person(String name) &#123; prt("父类·含一个参数的构造方法： "+"A person's name is " + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt("子类·调用父类"无参数构造方法"： "+"A chinese coder."); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt("子类·调用父类"含一个参数的构造方法"： "+"his name is " + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt("子类：调用子类具有相同形参的构造方法：his age is " + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese("codersai"); cn = new Chinese("codersai", 18); &#125; &#125; 运行结果： 1234567父类·无参数构造方法： A Person.子类·调用父类”无参数构造方法“： A chinese coder.父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用 super 和 this 分别调用父类的构造方法和本类中其他形式的构造方法。 例子中 Chinese 类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 ==super 和 this 的异同== super(参数)：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this(参数)：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。 super() 和 this() 均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static 方法，static 语句块。 从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
