<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 1470. 重新排列数组]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%201470.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。示例 1：123输入：nums = [2,5,1,3,4,7], n = 3输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 12输入：nums = [1,2,3,4,4,3,2,1], n = 4输出：[1,4,2,3,3,2,4,1] 示例 3： 12输入：nums = [1,1,2,2], n = 2输出：[1,2,1,2] 12345678910111213141516class Solution &#123; public int[] shuffle(int[] nums, int n) &#123; int[] res = new int[nums.length]; int j = 0; for(int i = 0; i &lt; nums.length; i++) &#123; res[i] = nums[j]; if(i % 2 == 0) j = j + n; else j = j - n + 1; &#125; return res; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 771. 宝石与石头]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%20771.%20%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[题目： 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。示例 1:12输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3 示例 2: 12输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0 123456789101112131415161718class Solution &#123; public int numJewelsInStones(String J, String S) &#123; int num = 0; char[] a = new char[J.length()]; for(int i = 0; i &lt; J.length(); i++) &#123; a[i] = J.charAt(i); &#125; for(int j = 0; j &lt; S.length(); j++) for(int k = 0; k &lt; a.length; k++) &#123; if(S.charAt(j) == (a[k])) num++; &#125; return num; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1486.数组异或操作]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%201486.%20%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数，n 和 start 。数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。请返回 nums 中所有元素按位异或（XOR）后得到的结果。示例 1：1234输入：n = 5, start = 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 &quot;^&quot; 为按位异或 XOR 运算符。 示例 2： 123输入：n = 4, start = 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8. 示例 3： 12输入：n = 1, start = 7输出：7 1234567891011121314151617class Solution &#123; public int xorOperation(int n, int start) &#123; int[] a = new int[n]; for(int i = 0; i &lt; n; i++) &#123; a[i] = start + 2 * i; &#125; int res = a[0]; for(int j = 1; j &lt; n; j++) &#123; res = res ^ a[j]; &#125; return res; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode LCP 06. 拿硬币]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%20LCP%2006.%20%E6%8B%BF%E7%A1%AC%E5%B8%81%2F</url>
    <content type="text"><![CDATA[题目：桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。示例 1：12345输入：[4,2,1]输出：4解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例 2： 123输入：[2,3,10]输出：8 12345678910111213141516class Solution &#123; public int minCount(int[] coins) &#123; int n = 0; for(int i = 0; i &lt; coins.length; i++) &#123; int m = 0; if((coins[i] % 2) != 0) m = (coins[i] / 2) + 1; else m = coins[i] / 2; n += m; &#125; return n; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 222. 完全二叉树的节点个数]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%20222.%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给出一个完全二叉树，求出该树的节点个数。说明：完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。示例:12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 思路：分为两种情况，第一种是左子树的高度 n 与右子树的高度 m 相同，说明左子树已经填满了，左子树的节点数加上根节点的总数为 2^n，只需遍历右子树的节点个数即可；第二种是 n 与 m 不相等，说明右子树已经填满了，右子树的节点数加上根节点的总数为 2^m，只需遍历左子树的节点个数即可。这里计算节点个数要用到递归的思想。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int countNodes(TreeNode root) &#123; if(root == null) return 0; int n = countLevel(root.left); int m = countLevel(root.right); if(n == m)&#123; return (countNodes(root.right) + (1&lt;&lt;n)); &#125; else&#123; return (countNodes(root.left) + (1&lt;&lt;m)); &#125; &#125; private int countLevel(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; return Math.max(countLevel(root.left), countLevel(root.right)) + 1; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1108. IP地址无效化]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%201108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题目：给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。 所谓无效化 IP 地址，其实就是用 &quot;[.]&quot; 代替了每个 &quot;.&quot;。示例 1：12输入：address = &quot;1.1.1.1&quot;输出：&quot;1[.]1[.]1[.]1&quot; 示例 2： 12输入：address = &quot;255.100.50.0&quot;输出：&quot;255[.]100[.]50[.]0&quot; 思路：直接使用Java的替换函数。 123456class Solution &#123; public String defangIPaddr(String address) &#123; return address.replace(".", "[.]"); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 237. 删除链表中的节点]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%20237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：示例 1：123输入：head = [4,5,1,9], node = 5输出：[4,1,9]解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.示例 2：123输入：head = [4,5,1,9], node = 1输出：[4,5,9]解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 123456789101112131415/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1281. 整数的各位积和之差]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%201281.%20%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。示例 1：123456输入：n = 234输出：15 解释：各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15示例 2：123456输入：n = 4421输出：21解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1 = 11 结果 = 32 - 11 = 21 思路：先将 int 类型转换为 String 类型，获取到每一位的值，然后计算和与乘积，返回题目所需的结果。 12345678910111213141516171819202122class Solution &#123; public int subtractProductAndSum(int n) &#123; String s = String.valueOf(n); int x = s.length(); int[] t = new int[x]; int sum = 0; int mul = 1; for(int i = 0; i &lt; x; i++)&#123; t[i] = s.charAt(i) - 48; &#125; for(int j = 0; j &lt; x; j++)&#123; sum += t[j]; mul *= t[j]; &#125; return mul - sum; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1480 一维数组的动态和]]></title>
    <url>%2F2020%2F11%2F22%2FLeetCode%201480%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。请返回 nums 的动态和。示例 1：123输入：nums = [1,2,3,4]输出：[1,3,6,10]解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 123输入：nums = [1,1,1,1,1]输出：[1,2,3,4,5]解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 12输入：nums = [3,1,2,10,1]输出：[3,4,6,16,17] 思路：遍历相加 1234567891011class Solution &#123; public int[] runningSum(int[] nums) &#123; int[] s = new int[nums.length]; s[0] = nums[0]; for(int i = 1; i &lt; nums.length; i++) s[i] = s[i-1]+nums[i]; // System.out.println(s); return s; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白 LeetCode 5605 检查两个字符串数据是否相等]]></title>
    <url>%2F2020%2F11%2F22%2F%E5%B0%8F%E7%99%BD%20LeetCode%205605%20%E6%A3%80%E6%9F%A5%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。示例 1：123456输入：word1 = ["ab", "c"], word2 = ["a", "bc"]输出：true解释：word1 表示的字符串为 "ab" + "c" -&gt; "abc"word2 表示的字符串为 "a" + "bc" -&gt; "abc"两个字符串相同，返回 true 示例 2： 12输入：word1 = ["a", "cb"], word2 = ["ab", "c"]输出：false 示例 3： 12输入：word1 = ["abc", "d", "defg"], word2 = ["abcddefg"]输出：true 思路：先把字符串数组合并成字符串，再比较两个字符串是否相等，若相等，则返回true；否则，返回false。 1234567891011121314151617class Solution &#123; public boolean arrayStringsAreEqual(String[] word1, String[] word2) &#123; String s1 = ""; String s2 = ""; for(int i = 0; i &lt; word1.length; i++)&#123; s1 = s1.concat(word1[i]); &#125; for(int j = 0; j &lt; word2.length; j++)&#123; s2 = s2.concat(word2[j]); &#125; if(s1.equals(s2)) return true; else return false; &#125;&#125; concat() 方法：用于将指定的字符串参数连接到字符串上。]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白 LeetCode 242 有效的字母异位词]]></title>
    <url>%2F2020%2F11%2F22%2F%E5%B0%8F%E7%99%BD%20LeetCode%20242%20%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[字母异位词字符串由相同字母组成，但允许排列顺序不同。如“aaabbb” 与 “ababab” 是字母异位词，而“aabb” 与 “ab” 不是字母异位词。题目：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。1234示例 1:输入: s = "anagram", t = "nagaram"输出: true 1234示例 2:输入: s = "rat", t = "car"输出: false 思路：先判断字符串长度是否相同，若不同，直接返回false；若相同则继续判断，给两个字符串排序，若排序后的字符串完全相等，那么返回true，否则，返回false。 12345678910111213141516171819class Solution &#123; public boolean isAnagram(String s, String t) &#123; int ls = s.length(); int lt = t.length(); if(ls != lt) return false; else &#123; char[] arrayS = s.toCharArray(); //把字符串转换为数组 char[] arrayT = t.toCharArray(); Arrays.sort(arrayS); //利用数组帮助类自动排序 Arrays.sort(arrayT); if(Arrays.equals(arrayS, arrayT)) return true; else return false; &#125; &#125; 字符串转为数组 .toCharArray() 数组排序：Arrays.sort(array) 判断数组是否相同：Arrays.equals(array1, array2)]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter notebook 导入和卸载 conda 虚拟环境]]></title>
    <url>%2F2020%2F11%2F21%2FJupyter%20notebook%20%E5%AF%BC%E5%85%A5%E5%92%8C%E5%8D%B8%E8%BD%BD%20conda%20%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、导入进入Anaconda Prompt，激活要使用的虚拟环境。1conda activate xxx # 你要使用的虚拟环境名称安装 ipykernel 插件， 建议使用 pip 进行安装， conda 安装容易失败1pip install ipykernel安装完成之后，键入以下命令1python -m ipykernel install --name (你要导入的虚拟环境名称) --display-name (你要显示的名称) 例如：打开 jupyter notebook， 可以看到环境已经成功导入 二、删除使用命令 1jupyter kernelspec remove (你要删除的虚拟环境名称 注意不是显示名称) 例如：删除成功 ！]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leaf 叶子(张量)]]></title>
    <url>%2F2020%2F11%2F20%2Fleaf%20%E5%8F%B6%E5%AD%90(%E5%BC%A0%E9%87%8F)%2F</url>
    <content type="text"><![CDATA[在pytorch的tensor类中,有个is_leaf的属性,姑且把它作为叶子节点. is_leaf 为False的时候,则不是叶子节点, is_leaf为True的时候为叶子节点(或者叶张量)所以问题来了: leaf的作用是什么?为什么要加 leaf? 我们都知道tensor中的 requires_grad()属性，当requires_grad()为True时我们将会记录tensor的运算过程并为自动求导做准备，但是并不是每个requires_grad()设为True的值都会在backward的时候得到相应的grad，它还必须为leaf。这就说明： leaf成为了在 requires_grad()下判断是否需要保留 grad的前提条件 is_leaf() 按照惯例,所有requires_grad为False的张量(Tensor) 都为叶张量( leaf Tensor)requires_grad为True的张量(Tensor),如果他们是由用户创建的,则它们是叶张量(leaf Tensor).这意味着它们不是运算的结果,因此gra_fn为None只有是叶张量的tensor在反向传播时才会将本身的grad传入的backward的运算中. 如果想得到当前tensor在反向传播时的grad, 可以用retain_grad()这个属性 例子: &gt;&gt;&gt; a = torch.rand(10, requires_grad=True) &gt;&gt;&gt; a.is_leaf True &gt;&gt;&gt; b = torch.rand(10, requires_grad=True).cuda() &gt;&gt;&gt; b.is_leaf False # b was created by the operation that cast a cpu Tensor into a cuda Tensor &gt;&gt;&gt; c = torch.rand(10, requires_grad=True) + 2 &gt;&gt;&gt; c.is_leaf False # c was created by the addition operation &gt;&gt;&gt; d = torch.rand(10).cuda() &gt;&gt;&gt; d.is_leaf True # d does not require gradients and so has no operation creating it (that is tracked by the autograd engine) &gt;&gt;&gt; e = torch.rand(10).cuda().requires_grad_() &gt;&gt;&gt; e.is_leaf True # e requires gradients and has no operations creating it &gt;&gt;&gt; f = torch.rand(10, requires_grad=True, device="cuda") &gt;&gt;&gt; f.is_leaf True # f requires grad, has no operation creating it]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《动手学深度学习 PyTorch版》学习笔记（三）：线性回归]]></title>
    <url>%2F2020%2F10%2F09%2F%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[线性回归输出是一个连续值，因此适用于回归问题。回归问题在实际中很常见，如预测房屋价格、气温、销售额等连续值的问题。一、基本要素摘自原书模型定义设房屋的面积为 x1，房龄为 x2，售出价格为 y。我们需要建立基于输入 x1 和 x2 来计算输出 y 的表达式，也就是 模型（model） 。顾名思义，线性回归假设输出与各个输入之间是线性关系：其中 w1 和 w2 是 权重（weight），b 是 偏差（bias），且均为标量。它们是线性回归模型的 参数（parameter）。模型输出 yˆ 是线性回归对真实价格 y 的预测或估计。我们通常允许它们之间有一定误差。 模型训练 我们需要通过数据来寻找特定的模型参数值，使模型在数据上的误差尽可能小。这个过程叫作 模型训练（model training），包含三个要素： 训练数据 我们通常收集一系列的真实数据，例如多栋房屋的真实售出价格和它们对应的面积和房龄。我们希望在这个数据上面寻找模型参数来使模型的预测价格与真实价格的误差最小。在机器学习术语里，该数据集被称为 训练数据集（training data set） 或 训练集（training set） ，一栋房屋被称为一个 样本（sample） ，其真实售出价格叫作 标签（label） ，用来预测标签的两个因素叫作 特征（feature）。特征用来表征样本的特点。 损失函数 在模型训练中，我们需要衡量价格预测值与真实值之间的误差。通常我们会选取一个非负数作为误差，且数值越小表示误差越小。一个常用的选择是平方函数。它在评估索引为 i 的样本误差的表达式为：其中常数 1/2 使对平方项求导后的常数系数为1，这样在形式上稍微简单一些。显然，误差越小表示预测价格与真实价格越相近，且当二者相等时误差为0。给定训练数据集，这个误差只与模型参数相关，因此我们将它记为以模型参数为参数的函数。在机器学习里，将衡量误差的函数称为 损失函数（loss function） 。这里使用的平方误差函数也称为 平方损失（square loss） 。通常，我们用训练数据集中所有样本误差的平均来衡量模型预测的质量，即 优化算法 当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫作 解析解（analytical solution） 。本节使用的线性回归和平方误差刚好属于这个范畴。然而，大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫作 数值解（numerical solution）。 在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent） 在深度学习中被广泛使用。它的算法很简单：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch）B，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。 在训练本节讨论的线性回归模型的过程中，模型的每个参数将作如下迭代： 模型预测 二、线性回归的表示方法如果我们对训练数据集里的3个房屋样本（索引分别为1、2和3）逐一预测价格现在，我们将上面3个等式转化成矢量计算。设： 对3个房屋样本预测价格的矢量计算表达式为yˆ=Xw+b, 其中的加法运算使用了 广播机制]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《动手学深度学习 PyTorch版》学习笔记（二）：自动求梯度]]></title>
    <url>%2F2020%2F10%2F08%2F%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%B1%82%E6%A2%AF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[一、自动求梯度1、requires_grad_(), detach(), torch.no_grad()的区别参考博客：https://www.jianshu.com/p/ff74ccae25f32、.grad_fn每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function, 就是说该Tensor是不是通过某些运算得到的，若是，则grad_fn返回一个与这些运算相关的对象，否则是None。 3、梯度 grad在反向传播过程中是累加的(accumulated)，这意味着每一次运行反向传播，梯度都会累加之前的梯度，所以一般在反向传播之前需把梯度清零 .grad.data.zero_() 在y.backward()时，如果y是标量，则不需要为backward()传入任何参数；否则，需要传入一个与y同形的Tensor 1234x = torch.tensor([1.0, 2.0, 3.0, 4.0], requires_grad=True)y = 2 * xz = y.view(2, 2)print(z) 输出 12tensor([[2., 4.], [6., 8.]], grad_fn=&lt;ViewBackward&gt;) 现在 z 不是一个标量，所以在调用backward时需要传入一个和z同形的权重向量进行加权求和得到一个标量。 123v = torch.tensor([[1.0, 0.1], [0.01, 0.001]], dtype=torch.float)z.backward(v)print(x.grad) 输出 1tensor([2.0000, 0.2000, 0.0200, 0.0020]) 4、中断梯度 123456789101112x = torch.tensor(1.0, requires_grad=True)y1 = x ** 2 with torch.no_grad(): y2 = x ** 3y3 = y1 + y2print(x.requires_grad)print(y1, y1.requires_grad) # Trueprint(y2, y2.requires_grad) # Falseprint(y3, y3.requires_grad) # Truey3.backward()print(x.grad)]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《动手学深度学习 PyTorch版》学习笔记（一）：数据操作]]></title>
    <url>%2F2020%2F10%2F08%2F%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、数据操作在PyTorch中，torch.Tensor是存储和变换数据的主要工具。12&quot;tensor&quot;这个单词一般可译作“张量”，张量可以看作是一个多维数组。标量可以看作是0维张量，向量可以看作1维张量，矩阵可以看作是二维张量。1、torch.arange() 和torch.linspace 1234567# arange(s, e, step) =&gt; 从s到e，步长为stepx8 = torch.arange(1, 10, 2)# print(x8)# linspace(s, e, steps) =&gt; 从s到e，均匀切分成steps份x9 = torch.linspace(2,8,3)# print(x9) 2、torch.range() 和torch.arange() 的区别 1234567891011&gt;&gt;&gt; y=torch.range(1,6)&gt;&gt;&gt; ytensor([1., 2., 3., 4., 5., 6.])&gt;&gt;&gt; y.dtypetorch.float32&gt;&gt;&gt; z=torch.arange(1,6)&gt;&gt;&gt; ztensor([1, 2, 3, 4, 5])&gt;&gt;&gt; z.dtypetorch.int64 3、torch.randn与torch.rand的区别 randn 1torch.randn(*sizes, out=None) → Tensor 返回一个包含了从标准正态分布中抽取的一组随机数的张量 size：张量的形状 out：结果张量 rand 1torch.rand(*sizes, out=None) → Tensor 返回一个张量，包含了从区间[0, 1)的均匀分布中抽取的一组随机数 4、NumPy数组与Tensor的互相转换（共享内存） NumPy转Tensor：torch.from_numpy()Tensor转NumPy：numpy()另：可以使用 torch.tensor() 将NumPy数组转换成Tensor，但不再共享内存 5、Tensor on GPU 1234567if torch.cuda.is_available(): device = torch.device("cuda") # GPU y = torch.ones_like(x, device=device) # 直接创建一个在GPU上的Tensor x = x.to(device) # 等价于 .to("cuda") z = x + y print(z) print(z.to("cpu", torch.double)) # to()还可以同时更改数据类型 6、索引 索引出来的结果与元数据共享内存 1234567x = torch.tensor([[1, 2, 3], [4, 5, 6]])print(x)y = x[0, :] # 取出第一行print(y)y += 1print(y)print(x[0, :]) # 源tensor也被改了 输出 12345tensor([[1, 2, 3], [4, 5, 6]])tensor([1, 2, 3])tensor([2, 3, 4])tensor([2, 3, 4]) 7、广播机制 当对两个形状不同的Tensor按元素运算时，可能会触发广播（broadcasting）机制：先适当复制元素使这两个Tensor形状相同后再按元素运算 12345x = torch.arange(1, 3).view(1, 2)print(x)y = torch.arange(1, 4).view(3, 1)print(y)print(x + y) 输出 1234567tensor([[1, 2]])tensor([[1], [2], [3]])tensor([[2, 3], [3, 4], [4, 5]])]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[torch.randn与torch.rand的区别]]></title>
    <url>%2F2020%2F10%2F05%2Ftorch.randn%E4%B8%8Etorch.rand%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[randn1torch.randn(*sizes, out=None) → Tensor 返回一个包含了从标准正态分布中抽取的一组随机数的张量 size：张量的形状 out：结果张量 rand1torch.rand(*sizes, out=None) → Tensor [0,1)之间的均匀分布]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch 之 requires_grad，requires_grad_()，grad_fn]]></title>
    <url>%2F2020%2F10%2F04%2FPyTorch%20%E4%B9%8B%20requires_grad%EF%BC%8Crequires_grad_()%EF%BC%8Cgrad_fn%2F</url>
    <content type="text"><![CDATA[x.grad_fn和x.requires_grad为x的属性 x.grad_fn：积分方法名，默认为None x.requires_grad：是否积分的属性，默认为False x.requires_grad_()：设置积分的方法，设置之后requires_grad为True 123456789101112"""Tensor"""import torch# 创建一个Tensor并设置requires_grad=Truex = torch.ones(2, 2, requires_grad=True)print(x)print(x.grad_fn)y = x + 2print(y)print(y.grad_fn)print(x.is_leaf, y.is_leaf)]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指定tensorflow运行的GPU或CPU设备]]></title>
    <url>%2F2020%2F07%2F29%2F%E6%8C%87%E5%AE%9Atensorflow%E8%BF%90%E8%A1%8C%E7%9A%84GPU%E6%88%96CPU%E8%AE%BE%E5%A4%87%2F</url>
    <content type="text"><![CDATA[如果 TensorFlow 指令中兼有 CPU 和 GPU 实现，当该指令分配到设备时，GPU 设备有优先权。 如果你的系统里有多个 GPU, 那么 ID 最小的 GPU 会默认使用。 当我们要指定tensorflow运行的GPU或CPU设备时，可以使用tf.device()命令 首先查看可用运算设备(CPU,GPU) 12from tensorflow.python.client import device_libprint(device_lib.list_local_devices()) 得到类似以下的输出结果 123456789101112131415[name: "/device:CPU:0"device_type: "CPU"memory_limit: 268435456locality &#123;&#125;incarnation: 13177083330855175469, name: "/device:GPU:0"device_type: "GPU"memory_limit: 10968950375locality &#123; bus_id: 1&#125;incarnation: 6161624703599064583physical_device_desc: "device: 0, name: GeForce GTX 1080 Ti, pci bus id: 0000:00:08.0, compute capability: 6.1"] name即是对应设备名称，一般来说（以各自实际情况为准，每个人的情况可能不同） 123&quot;/cpu:0&quot;：机器的 CPU。&quot;/device:GPU:0&quot;：机器的 GPU（如果有一个）。&quot;/device:GPU:1&quot;：机器的第二个 GPU（以此类推）。 使用命令tf.device()进行指定 12import osos.environ["CUDA_VISIBLE_DEVICES"] = '/device:GPU:0']]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[module ‘tensorflow‘ has no attribute ‘sparse ‘]]></title>
    <url>%2F2020%2F07%2F29%2Fmodule%20%E2%80%98tensorflow%E2%80%98%20has%20no%20attribute%20%E2%80%98sparse%20%E2%80%98%2F</url>
    <content type="text"><![CDATA[非常奇怪的一个报错，在查找资料无果的情况下选择了重装keras（应该是版本对应出现了问题），报错解决]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习环境搭建之Anaconda安装keras]]></title>
    <url>%2F2020%2F07%2F29%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B9%8BAnaconda%E5%AE%89%E8%A3%85keras%2F</url>
    <content type="text"><![CDATA[一、确定安装版本号搭环境遇到一堆坑，总结一点最重要的就是要选择好版本。 这里我们要注意tensorflow与keras的版本对应关系。见下图 二、使用pip进行安装 这里注意首先要激活对应的环境 1pip install keras==版本号 后续有时间再补充安装tensorflow-gpu以及pytorch的教程]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下进入Anaconda Prompt以及Navigator]]></title>
    <url>%2F2020%2F07%2F29%2FLinux%E4%B8%8B%E8%BF%9B%E5%85%A5Anaconda%20Prompt%E4%BB%A5%E5%8F%8ANavigator%2F</url>
    <content type="text"><![CDATA[一、进入Anaconda Promp 打开终端，cd 进Anaconda下的bin目录 1conda activate 退出 1conda deactivate 二、进入Anaconda Navigator 1anaconda-navigator]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哔哩哔哩n倍速播放视频]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9n%E5%80%8D%E9%80%9F%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[在b站看一些学习视频的时候，有时候2倍速满足不了我们的需求，可以在控制台键入以下命令实现n倍速播放视频 1document.querySelector('video').playbackRate = 3]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层的基本概念]]></title>
    <url>%2F2020%2F06%2F13%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[网络层的功能网络层负责实现各种不一样的物理网络的互联 网络层采用分组交换技术 网络层应当使用统一编址 路由器使用存储转发实现异构网络的互联 网络层关注分组从一个网络到达另一个网络的选路问题 资源子网与通信子网资源子网 负责全网的数据处理业务，向网络用户提供各种网络资源与网络服务。 传输层应用层属于资源子网，关注端到端通信 通信子网 完成网络数据传输转发等通信处理任务 网络层、数据链路层和物理层属于通信子网，负责网络通信转发 分组交换网络的路由模式路由模式的概念 分组选路的方式 网络根据路由模式分类 数据报网络：无连接不可靠的网络 虚电路网络：面向连接可靠的网络 数据报网络特点： 在网络层没有连接建立过程 路由器不维护端对端的连接状态 一般分组使用目标主机的ID（即IP地址）进行路由选择 同样的收发双方的不同分组可能经由的路径可能不同 虚电路网络特点： 发送分组之前会建立一条虚拟的电路（永久PVC或临时SVC）； 每个分组携有标签（虚电路ID），由标签来确定下一跳； 在连接建立阶段确定固定的路由，全部数据通过同一条路传递； 路由器为每个正在通信中的连接维持状态 QoS的基本概念 QoS（Quality of Service）服务质量是指允许用户在带宽、延迟、抖动、可靠性（丢包率）等方面获得可预期的服务水平的一系列技术的集合。 抖动：延迟的变化程度 数据报网络和虚电路网络比较 数据报网络：无连接，可靠性不强，可能形成环路，但是速度快，路由器的工作相对小，不容易实现QoS（服务质量保证）虚电路网络：面向连接可靠性较好，路由器需要为每个虚电路维护状态，代价较高，建立虚电路需要时间，容易实现QoS 网络层提供的服务 因特网模型：无连接不可靠灵活的数据包网络传输服务 ATM网络：面向连接可靠的虚电路传输服务 因特网的选择 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据包服务 网络在发送分组时不需要先建立连接。每一个分组（即IP数据报）独立发送，与其前后的分组无关（不进行编号） 网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序，当然也不保证分组传送的时限 因特网特点：灵活、适应性强、网络成本相对低]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的拥塞控制机制]]></title>
    <url>%2F2020%2F06%2F13%2FTCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[拥塞： 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，产生拥塞 若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降 拥塞控制： 保证网络能够承受现有的网络负荷 开环控制和闭环控制开环控制 在设计网络时事先将有关发生的拥塞的因素考虑周到，力求网络在工作时不产生拥塞 闭环控制 基于反馈环路的概念 监测网络系统以便检测到拥塞在何时、何处发生 将拥塞发生的信息传送到可采取行动的地方 调整网络系统的运行以解决出现的问题 TCP拥塞控制思想特性 使用拥塞窗口cwnd控制发送窗口大小 发送窗口的上限值 = Min [rwnd，cwnd] 分组超时意味着拥塞，分组收到确认则意味着网络未拥塞 拥塞则少发（拥塞窗口减小），没拥塞则多发（拥塞窗口增加） 在网络未知的情况下拥塞窗口从最小开始 收到确认拥塞窗口大小增加 为提高效率，开始窗口增加速度快，到了一定阶段窗口增加速度变慢 举例 总结两个阶段 慢启动阶段 - - - 乘法增 拥塞避免阶段 - - - 加法增 一个阈值 定义了慢启动阶段和拥塞避免阶段的分界点 超时发生时 阈值变成超时的窗口大小的一半 回到慢启动 快恢复算法 当发送端收到连续3个重复的确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，直接进入拥塞避免阶段 LAND攻击攻击方法及原理 方法：将TCP包的源地址和目的地址，源端口和目的端口都设置成相同，导致对方死机 原理：TCP连接管理的实现存在漏洞]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议详解]]></title>
    <url>%2F2020%2F06%2F11%2FTCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、TCP的设计理念 传输层协议 端到端控制，实现分用和复用 可靠传输机制 保证端到端数据按序正确的到达、序号机制、确认机制、差错检测机制、缓存机制、重传机制、滑动窗口机制 其他机制 流量控制机制、拥塞控制机制 TCP协议的可靠传输机制TCP的首部 源端口和目的端口字段——各占2字节。端口是传输层与应用层的服务接口，类似一个地址标识。传输层的复用和分用功能都要通过端口才能实现 序号字段——占4字节。TCP连接中传送的数据流中的每一个字节都编上一个号。序号字段的值指的是本报文段所发送的数据的第一个字节的编号 确认号字段——占4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。注意，当有数据要发送给对方时，顺便确认，当没有数据发送给对方时，单独发一个确认报文 特殊标记（Flag）：每个标记占一个bit，有特殊约定 URG——紧急比特标记，当URG置为1时，表明紧急指针字段有效。通知本报文段中有紧急数据，应尽快传送，紧急数据的优先级要高。 ACK——只有当ACK置为1时，确认号字段才有效。正常情况下只有第一次握手时ACK=0 PSH（Push）——推送比特，接收方收到推送比特置为1的报文段，就尽快地将该报文段的数据交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付 RST（ReSet）——复位比特，当RST=1时，表明TCP连接中出现严重差错，必须强行释放连接，属于单方面强行断开连接 SYN——同步比特，SYN置为1，表示这是一个连接请求报文。正常情况下只有第一次握手和第二次握手时SYN等于1，其余都等于0 FIN（Final）——终止比特，用来正常释放一个连接。当FIN=1时，表明此报文段的发送端的数据已发送完毕，并请求对方释放连接，当对方确认后，会释放发送缓存 窗口字段——占2字节。窗口字段是流量控制的关键，用来控制对方发送窗口的大小，单位为字节。接收方根据自身的缓存大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限 检验和——占2字节。检验和字段检验的范围包括首部和数据这两部分，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部 紧急指针字段——占16bit，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号 TCP的确认机制序号 按字节编号 确认 期望确认：期待对方发送的下一个报文的序号 累积确认：收到某个分组的确认意味着该分组及之前所有分组都正确收到 特殊报文的确认问题 对于没有包含数据的确认报文段不再确认 对于含特殊标记的数据段，即使没有任何的数据接收，确认号也要加1 TCP 建立连接的作用作用： 使每一方能够确知对方的存在 允许双方协议一些参数（如最大报文段长度，最大窗口大小，服务质量等） 对传输实体资源进行分配 TCP的三次握手建立连接 注意：这个时候如果客户端再发请求，序号还是从x+1开始 注意： 建立连接时会初始化相关参数，分配缓存等资源 服务端收到第一次握手后默认会跟踪该连接75秒 SYN Flooding攻击 攻击原理：服务器进行第二次握手之后会在超时时间内（一般为75秒）跟踪该连接，未收到第三次握手会不断重发，消耗资源 攻击防范 缩短TCP超时时间 更改TCP的搬开连接数 TCP-z，监控TCP状态 通过防火墙、路由器等过滤网关防护 使用SYN Cookie技术 TCP的四次挥手断开连接 TCP的时间等待计时器 防止最后一个ACK丢失导致断开连接出现异常 一般等于二倍报文段寿命长度 保活计时器 防止两个TCP之间的连接长时间的空闲 TCP的重传机制 选择性重传机制 当数据超时则需要重传，需要重传定时器 TCP属于使用累积确认的选择性重传协议 重传超时时间的确定 快重传机制 当连续收到三个重复的确认，直接重传所需分组，提高效率 TCP的流量控制接收方：明确地通过TCP首部的窗口字段发送接收窗口大小，从而限制发送方发送窗口的最大值发送方：保证发送窗口大小不超过对方发送的接收窗口的大小]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口协议]]></title>
    <url>%2F2020%2F06%2F10%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[滑动窗口协议核心思想： 发送方在没有收到对方的ACK的时候可以发送多个数据包 特性 发送方使用发送窗口限制没收到确认时允许发送的数据量 必须增加序号的个数，发送方和接收方需要增加缓存 常见的两种滑动窗口协议：GBN（回退N步）和SR（选择性重传） GBN的工作方式 发送方：窗口不满则发送至窗口满，窗口满则等待，收到确认窗口向后移动，某个分组出错或丢失则重传该分组及其后面所有已发送但未被确认的分组 接收方：对按序正确到达的分组确认，乱序或错误的分组丢弃且发送最后一次正确收到的分组的确认 累计确认机制 发送方收到某个分组的确认意味着该分组及之前所有分组接收方都正确收到 GBN协议演示 SR的工作方式SR（selective repeat）选择性重传 发送方某个分组出错或丢失只重传该分组 接收方增加接收窗口（接收缓存），若收到的分组在接受窗口内且乱序，缓存该分组，等到分组按序后一起提交，接收窗口的大小一般等于发送方发送窗口的大小 也是累计确认 SR的演示 窗口大小和序号的关系 GBN窗口的最大值等于序号的个数-1 SR窗口的最大值等于序号的一半]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP协议、电子邮件系统与Telnet远程控制]]></title>
    <url>%2F2020%2F06%2F08%2FFTP%E5%8D%8F%E8%AE%AE%E3%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8ETelnet%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、FTP协议概述FTP定义 文件传输协议 用于因特网文件传输 FTP特性 使用客户端/服务器模式 使用TCP提供可靠的传输 FTP属于维护状态的协议 FTP使用两条TCP连接完成数据传输 FTP的两条连接数据连接问题 当有具体文件或目录内容传输时，临时建立数据连接 主动模式下由服务器方发起，服务器端口号20 被动模式下由客户端发起，服务器端口号不确定 二、电子邮件系统的组成电子邮件系统的组成用户代理 电子邮件客户端软件，如浏览器，Outlook，Outlook Express，Foxmail等 邮件服务器 提供邮件服务的主机，如sina邮件服务器sina.com，google的邮件服务器gmail.com 邮件发送和接收协议 HTTP，SMTP，POP，IMAP等 SMTP协议SMTP协议定义 Simple Mail Transfer Protocol：简单邮件传输协议 用于使用邮件代理发给邮件服务器或邮件服务器之间转发邮件 SMTP特性 使用TCP可靠的传送邮件报文，服务器监听端口号为25 使用命令/响应代码完成邮件传输的控制交互 SMTP只能传送7bit的ASCII码的邮件报文 SMTP采用持续连接的方式发邮件 问题1：SMTP无认证 将导致大量的垃圾邮件 ESMTP：增强型SMTP，发邮件需要用户名密码验证 问题2：SMTP只能传输ASCII码的文本文件 使用MIME多目标邮件拓展协议 MIME使用BASE64编码或QP编码将非ASCII码转为ASCII码 邮件接收协议简介 用户收取邮件常用的协议 POP（Post Office Protocol邮局协议）：服务器端口默认110 IMAP（Internet Mail Access Protocol）【因特网邮件访问协议】：服务器默认端口143 HTTP POP3协议 IMAP协议 IMAP具备和POP一样的邮件下载功能 IMAP允许只读取邮件中的某一个部分 IMAP提供操作的三种模式1、在线方式：邮件保留在Mail服务器端，客户端可以对其进行管理。其使用方式与WebMail相类似2、离线方式：邮件保留在客户端，客户端可以对其进行管理3、分离方式：邮件的一部分在Mail服务器端，一部分在客户端 三、Telnet远程控制 Telnet用于终端使用命令行方式对服务器进行远程控制。端口号为TCP的23 Telnet的客户端称为VTY（虚拟终端），Telnet不安全，明文传输，可以用更安全的SSH协议替代]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP报文的格式]]></title>
    <url>%2F2020%2F06%2F08%2FHTTP%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、HTTP请求报文的格式 两个回车换行表示首部的结尾 注意：HTTP协议首部使用ASCII码作为编码方式 HTTP请求报文提交表单时会包含数据 二、HTTP响应报文格式]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[www万维网和HTTP协议]]></title>
    <url>%2F2020%2F06%2F06%2Fwww%E4%B8%87%E7%BB%B4%E7%BD%91%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[万维网的相关概念万维网的客户端程序 浏览器：IE、firefox、chrome 万维网的服务器端软件 IIS，Tomcat、Apache 万维网的模式 采用C/S模式 Web页面 由文字、图片、声音、视频等多种对象组成 HTTP协议 Web页面传输方式 如何标志分布在因特网上的万维网文档？ 使用整个因特网范围内唯一的统一资源定位符URL（Uniform Resource Locator）来标识万维网上的各种文档 &lt;URL的访问方式&gt;：// &lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; &lt;URL的访问方式&gt;ftp：文件传送协议http：超文本传送协议https：基于安全的套接层的http协议 &lt;主机&gt;：存放资源的主机在因特网中的域名或IP地址&lt;端口&gt;：根据协议有默认值，如http为80端口，https为443，默认端口可以省略&lt;路径&gt;：文件在主机中的相对位置，当路径省略时自动打开默认文档 HTTP协议概述定义 超文本传输（hypertext transfer protocol）协议。 定义WEB页面在因特网上的交互方式的应用层协议。 WEB页面传输需要可靠传输吗？需要，使用TCP协议作为传输层，服务器默认端口号为80 页面文本和链接的对象怎么传输？ HTTP1.0：RFC 1945定义 HTTP1.1：RFC 2068定义 HTTP1.0默认特性非持续连接：传完一个对象就断开连接，获得对象至少需要2 RTTS（建立连接和获取对象），每次传送都要受到TCP初始化时慢启动影响非流水线作业方式 HTTP1.1的默认特性持续连接：一条TCP连接传多个对象流水线作业方式 HTTP协议首部的格式 HTTP请求报文 HTTP响应报文 HTTP协议的设计原则 满足协议的功能 注意协议的拓展性 便于程序处理 注意协议的通信效率 其他细节的处理]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS域名系统详解]]></title>
    <url>%2F2020%2F06%2F04%2FDNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、分层次的域名结构 顶级域名、 二级域名、 三级域名、 四级域名 二、因特网的域名结构 因特网采用了层次树状结构的命名方法，称为域名，如：www.jxnu.edu.cn三级域名：如www表示万维网二级域名：如jxnu表示江西师大一级域名：如edu表示教育网顶级域名：如cn表示中国 一个域名可以对应多个IP吗？可以一个IP可以对应多个域名吗？可以 三、域名服务器的工作方式1、域名服务器的分类域名系统是分级别的，所以域名服务器也是有层次的，域名服务器本身也有域名 本地域名服务器 针对主机而言，主机首先将DNS请求发给本地的域名服务器 根域名服务器 用于解释.com、.net等顶级域名的服务器 权威域名服务器 能够权威的解释某个域名和IP对应的服务器 2、DNS的查询方式DNS递归查询服务器与服务器DNS迭代查询主机与服务器 DNS的查询优化 问题：每次访问网页都需要首先进行DNS请求，效率不高，如何能够提高效率？ 使用缓存机制可以提高效率—— 客户端短期内会将DNS映射缓存—— DNS服务器从上级DNS服务器获得的DNS映射会缓存—— 缓存的映射必须有生存时间 缓存的利与弊讨论—— 导致有时无法及时获得更新的DNS映射—— 导致DNS的负载均衡无效 DNS的负载均衡 将一个域名对应多个IP（多台相同的服务器），域名服务器收到域名查询请求时将IP轮流分配给不同的客户端，使得不同的客户端访问不同的服务器，实现服务器的负载均衡。 DNS的反向查询 DNS查询模式包括正向查询和反向查询 正向查询根据域名找IP（包括递归查询和迭代查询） 反向查询是指通过IP地址获得相应的域名 DNS协议格式 DNS服务器使用TCP/UDP的53端口 客户端浏览器发出的DNS查询使用UDP DNS服务器之间同步DNS记录使用TCP DNS协议报文包括两种 DNS请求报文 DNS响应报文 为合理定义DNS记录，DNS协议采用资源记录的结构表示 DNS资源记录（Resource Record） RR格式：（name, value, type, ttl, class）name：域名 value：根据type的不同，意义不同ttl：该记录在缓存中能停留的时间，0表示不能缓存class：RR的类别代码，默认为0001，表示因特网type：RR类型|type| value ||–|–|| A | 域名对应的IP地址 ||AAAA|域名对应的IPv6地址||NS|域名对应的权威域名服务器名称||CNAME|域名对应的别名||MX|域名对应的邮件服务器的名称||PTR|name对应的 名字（反向查询）| DNS的报文格式 hosts文件hosts文件的域名和IP的对应优先DNS查询结果]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层相关概念]]></title>
    <url>%2F2020%2F06%2F04%2F%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[一、应用层概述1、应用层协议基本概念应用层的功能 应用层协议定义了应用程序需交换的报文、所需采取的动作和最终通信数据的应用 应用层位于协议栈的最高层次 应用层协议提供不同主机之间进程与进程之间的通信 用户代理实现应用层协议 套接字IP+端口号，唯一确定某台主机某个进程IP地址唯一确定某主机在因特网上的位置，32位二进制，采用点分十进制表示，例如192.168.1.1端口号唯一确定某台主机的某个通信进程，16位二进制，一般用十进制表示，例如80端口端口号是应用进程的入口标识，是一个存放在传输层首部的一个字段的值（2^16 - 1 = 65535） 包括TCP端口号和UDP端口号 一个进程可能使用多个端口号 端口号范围 端口类型 0到1023 公认端口、一般分配给固定的服务进程，用于某种应用的服务端 1024到49151 可注册端口（随机使用端口）随机分配给客户端进程，或者用于某些非公认应用程序 49152到65535 私有端口或临时端口、一般分配给某些P2P应用程序，使用较少 网络应用层协议 服务器端端口号 协议 DNS 53 TCP/UDP HTTP 80 TCP HTTPS 443 TCP FTP 20,21 TCP SMTP 25 TCP POP 110 TCP TELNET 23 TCP 网络应用的模式 C/S 模式的网络应用 目前大多数网络应用采用C/S模式 客户端首先发起请求，再由服务器端响应提供服务 P2P（peer to peer） 任意主机既是客户端又是服务器 主机之间是对等的 迅雷，BT等常见下载软件均提供P2P下载模式 网络应用需要的服务 可靠性保证 应用数据能否保证按序，正确的到达对方 带宽保证 应用数据传输能否保证最小带宽 实时性保证 数据是否保证在规定时间内到达对方 网络应用使用的传输层协议一般原则 对可靠性要求高的使用TCP作为传输层，对速度要求高，可靠性要求低的使用UDP作为传输层 TCP提供面向连接可靠的传输服务 UDP提供无连接不可靠的传输服务 因特网的传输层不提供带宽保证、实时性保证服务]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教学5层网络体系结构——分层之后数据的发送和接收]]></title>
    <url>%2F2020%2F06%2F03%2F%E6%95%99%E5%AD%A65%E5%B1%82%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%88%86%E5%B1%82%E4%B9%8B%E5%90%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%2F</url>
    <content type="text"><![CDATA[协议分层后数据发送过程发送方层层封装接收方层层解封装 唯一加尾部的是数据链路层 思考发送方某层封装完如何知道该交给哪个下层封装？ 应用层选择传输层由应用程序决定，传输层选择网络层由固定的搭配，例如因特网只有IP协议，网络层选择数据链路层由网卡的类型决定。 接收方某层解封装后如何知道该交给上层哪个协议处理？ 每个协议都应该有个上层协议的标识，让接收方处理本层之后交给正确的上层协议 每一层协议的首部有何作用？ 实现本层次的特定功能，提供相邻层次协议的接口等 例如网络层IP协议中包含IP地址等信息 协议分层的进一步讨论 协议是对等的 收发双方某层协议必须相同 服务是垂直的 下层为上层提供服务 层次实现是透明的 某层的实现细节对其他层次透明 层与层之间必须提供接口 某层只需知道相邻层次的接口]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——因特网的接入技术]]></title>
    <url>%2F2020%2F06%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[因特网接入与ISPISP：Internet服务供应商，为接入Internet提供基本的服务一、模拟拨号 早期使用调制解调器（Modem）和常规的语音级电话线路 早期使用最为广泛，最大带宽56Kb/s【下一首歌差不多要30分钟、上网就不能打电话】 拨号调制解调器的作用：数字信号和模拟信号的转换 二、综合业务数字网络（ISDN） 综合业务数字网络（ISDN）是一种电路交换技术，能够让PSTN本地环路传输数字信号，从而实现更高容量的交换连接。 最大带宽128kb/s 三、非对称数字用户线路（ADSL） 上行和下行带宽不对称（因为下载比上传重要） 采用频分复用技术利用普通电话线提供高宽带服务 四、有线电视带宽 也称为HFC光纤同轴混合网 采用光纤和有线电视网络传输数据的带宽接入技术 五、光纤接入网点到点的网络、路边交换网络、无源光网络（PON）六、专线接入专线业务主要应用于用户的局域网互联或快速浏览互联网特点： 专线专用、24小时在线、实现双向数据同步传输，上网速度快、质量稳定、丢包率低、更具安全性 七、无线网络 WLAN：无线局域网技术，也称WIFI技术 WIMAX：无线城域网技术 4G/5G：第四代移动通信技术]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因特网的硬件组成]]></title>
    <url>%2F2020%2F06%2F03%2F%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[终端系统 主机、服务器、PDA 通信介质 有线介质：双绞线、同轴电缆、光纤 无线介质：无线电波、卫星 中间设备 路由器、交换机等 路由器路由器的产生 由思科公司创始人伯塞克发明 路由器的特性和作用 存储转发机制 连接异构的网络 交换机交换机的特性 交换机一般都指以太网交换机 存储转发机制和其他转发机制 交换机的作用 将终端设备连接成一个局域网（以太网） 网络的有线传输介质 双绞线屏蔽双绞线（STP）：抗干扰性好，但不易安装布线非屏蔽双绞线（UTP）：抗干扰性较差，但容易安装布线，目前使用范围最广根据性能分类：1、根据电气性能分为：3类、5类、超5类、6类、7类2、3类用于10Mb/s以太网，5类用于100Mb/s以太网，超5类，6类，7类用于千兆网3、目前的布线建议采用超5类以上4、UTP使用RJ-45水晶头作为连接器 UTP的接线标准T568B接线方式：对主机而言：1,2引脚发数据、3,6引脚收数据、1,3高电平、2,6低电平接线原则：1 2 3 6，橙绿蓝棕 半全半全 直通线和交叉线直通线：两端都使用T568B连线，一般用于不同设备之间交叉线：一端使用T568B，一端使用T568A，一般用于相同或相近设备之间tips:主机和路由器之间相连用交叉现 UTP的性能讨论 衰减 由距离决定，理论不能超过100m 距离过长导致衰减过大 串扰 线对之间的干扰，在水晶头上尤为突出（因为没有绞合） 水晶头上串扰最大 回波损耗（反射） 当信号遇到不连续的阻抗会朝相反方向反射，产生干扰 线歪曲过度或水晶头上容易产生较强的回波损耗（反射干扰） 同轴电缆 50Ω同轴，多用于早期以太网 70Ω同轴，用于有线电视 屏蔽较好，不容易安装，目前在计算机网络中使用不多 光纤工作原理 通过光的全反射传输信号 特性 抗干扰性强，衰减小，传输距离长 分成多模光纤和单模光纤 随着价格的不断下降应用日益普及 注意事项 可以歪曲、不能折 两根成对实现全双工 注意激光伤害眼睛]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基本概念]]></title>
    <url>%2F2020%2F06%2F01%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[计算机网络的分类按照网络拓扑结构划分计算机网络拓扑结构是指网络中各个站点相互连接的形式星型、环型、总线型、树型、网状型、无限蜂窝型 按照网络作用范围划分广域网WAN（Wide Area Network）：作用范围通常为几十到几千公里 一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网络。所覆盖的范围从几十公里到几千公里。 城域网MAN（Metropolitan Area Network）：作用距离约为5~50公里 一种介于局域网与广域网之间，覆盖一个城市的地理范围，用来将同一区域内的多个局域网互连起来的中等范围的计算机网络 接入网AN（Access Network）：又称为本地接入网或居民接入网。 接入网是一类比较特殊的计算机网络，用于将用户接入互联网。 接入网指骨干网络到用户终端之间的所有设备。其长度一般为几百米到几公里，有时称为“最后一公里” 局域网LAN（Local Area Network）：局限在较小的范围（如1公里左右） 定义：一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网络 局域网包括：以太网、令牌环网等 当前的局域网主流是以太网 个人局域网PAN（Personal Area Network）：范围很小，大约在10米左右TIPS： 若中央处理机之间的距离非常近（如仅1米的数量级甚至更小些），则一般就称之为多处理机系统，而不称它为计算机网络 按照网络使用者划分公用网（public network） 按规定交纳费用的人都可以使用的网络。因此也可称为公众网 专用网（private network） 为特殊业务工作的需要而建造的网络]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无类别地址CIDR概述]]></title>
    <url>%2F2020%2F05%2F31%2F%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9C%B0%E5%9D%80CIDR%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[问题 IPv4的地址空间最终将全部耗尽 子网掩码无法改变IP地址的分配方式，无法缓解IP地址危机 CIDR概述 CIDR是无类别域间路由 CIDR取消了IP地址的分类限制，可以取IP地址的任意前缀作为网络号 CIDR改善了IP地址的分配方式，缓解了IP地址危机 CIDR可以利用层次网络和路由汇总减小路由器中路由表的规模，提高转发速度 CIDR地址说明CIDR地址的网络地址由前缀或掩码决定 128.14.32.5/20表示该IP地址前20位为网络号，后12位为主机号，即掩码为255.255.240.0CIDR地址的网络地址和广播地址本质不变 主机号全0为网络地址，全1为广播地址 128.14.32.0/32表示一个网络地址，即一个CIDR地址块 路由汇总 路由汇总指将多个网络地址汇总为一个网络地址 路由汇总必须与层次物理网络结合 路由汇总能极大的减少路由器上路由表的规模 VLSM中，多个子网可以汇总成一个分类地址块或一个子网地址块 CIDR地址中，多个网络（可以是分类网络）可以汇总成一个CIDR地址块，形成超网 192.168.0（00000000）.0/24192.168.1（00000001）.0/24 路由汇总192.168.2（00000010）.0/24 ====⇒ 192.168.0.0/22四个网段的前22位相同保留，192.168.3（00000011）.0/24 ====⇒ 后10位作为汇总后的主机部分，用0表示]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定长掩码地址划分与VLSM子网划分]]></title>
    <url>%2F2020%2F05%2F31%2F%E5%AE%9A%E9%95%BF%E6%8E%A9%E7%A0%81%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86%E4%B8%8EVLSM%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[定长掩码地址划分案例若某个公司得到一个C类网络地址210.33.15.0，假如所有子网的掩码都一样，该如何划分子网？步骤一：确定子网个数7个子网，其中4个局域网，3个广域网步骤2：确定每个子网所需IP个数步骤3：确定子网掩码 过去规定不能使用子网号全0和全1的子网 C类网络，7个子网，需要借4位作为子网号，掩码为255.255.255.240，该掩码下每个子网可以使用14个IP地址 总部需要25个IP，出现子网和主机数的矛盾 子网数与主机数矛盾的解决方法 申请更大的地址块 让一个物理网络包含多个IP子网 使用子网0 使用可变长子网掩码VLSM 最终规划方案：假设采用子网0的方式解决子网数和主机数的冲突，使用子网掩码255.255.255.224（11100000）子网0：210.33.15.000hhhhh ，主机号不能全0或全1 所以范围为210.33.15.1（00000001）~ 210.33.15.30（00011110）子网1：210.33.15.001hhhhh ，主机号不能全0或全1 所以范围为210.33.15.33 （00100001）~ 210.33.15.62（00111110）子网2：210.33.15.010hhhhh ，主机号不能全0或全1 所以范围为210.33.15.65（01000001）~ 210.33.15.94（01011110）…… VLSM划分子网步骤 按照主机数的需求从多到少或从少到多排序 每个子网根据主机IP的需求确定主机号的位数，从而确定子网号的位数，确定子网掩码 一定要保证某个子网不会成为其他子网的细分子网，即子网划分不能重复]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAT与DHCP协议]]></title>
    <url>%2F2020%2F05%2F31%2FNAT%E4%B8%8EDHCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[DHCP概述DHCP产生的原因大型网络中静态配置IP地址容易出现地址冲突定义DHCP：动态主机配置协议，用于主机自动获得IP地址、子网掩码、网关地址、DNS服务器地址，租用期等相关信息。采用C/S模式。DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。DHCP的设计思考问题1： DHCP协议如何找到服务器？答：通过广播，广播的目标地址是255.255.255.255（对自己所在的本局域网发广播）【在不知道目标在哪的时候可以采用广播的方式进行通信】 问题2： 多个客户端同时请求IP，服务器该如何分辨？答：通过MAC地址 问题3： 服务器是否能够给某个客户分配固定的IP地址？答：可以并且有些情况下是有必要的【如何实现：通过MAC地址，固定MAC地址给固定的IP地址】 问题4： DHCP服务器如何保证分配的IP地址是唯一的？答：在服务器分配某一个IP地址的时候，发广播去问局域网上所有的主机有没有人的IP地址是将要分配的这个IP地址，如果没有收到回复，那么可以分配。 问题5： DHCP协议如果要实现某个客户端的IP动态变化，该如何处理？答：使用租用期 问题6 DHCP协议的报文应当包含几种？答：DHCPDISCOVER、DHCPOFFER、DHCPREQUEST、DHCPACK、DHCPREQUEST DHCP基于UDP工作，DHCP服务器运行在67号端口，DHCP客户运行在68号端口。【为什么使用UDP而不是TCP？】因为DHCP要使用广播，1对多的传输模式只能用UDP 若DHCP服务器不响应步骤6的请求报文DHCPREQUEST，则在租用期过了87.5%时，DHCP客户必须重新发送请求报文DHCPREQUEST（重复步骤6），然后又继续后面的步骤。 DHCP客户可随时提前终止服务器所提供的租用期，这时只需向DHCP服务器发送释放报文DHCPRELEASE即可。 DHCP中继代理 并不是每个网络上都有DHCP服务器，这样会使DHCP服务器的数量太多。现在是每一个网络至少有一个DHCP中继代理，它配置了DHCP服务器的IP地址信息。 当DHCP中继代理收到主机发送的发现报文后，就以单播方式向DHCP服务器转发此报文，并等待其回答。收到DHCP服务器回答的提供报文后，DHCP中继代理再将此提供报文发回给主机。 一个网络如果没有DHCP服务器，至少需要一个DHCP中继代理，它配置了DHCP服务器的IP地址信息。 ipconfig命令： ipconfig/release：释放IP地址 ipconfig/renew：重新使用DHCP获取IP地址 禁止主机通过DHCP获取IP： 禁用系统服务中的DHCP client服务]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BGP协议]]></title>
    <url>%2F2020%2F05%2F26%2FBGP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[概述 BGP是目前“唯一”的EGP协议，用于AS之间传递路由信息，目前版本为4 为什么需要BGP？ 不同AS自治系统的管理部门不同，路由策略不同 AS之间的路由不强调最优路径，更强调路由控制和路由策略 IGP与BGP对比 IGP关注如何自动学习最优路径，如何提高路由收敛速度，有明确的算法 BGP关注如何将人为控制策略应用到BGP上，强调路由控制的灵活性，无需明确的算法 BGP的特性 在不考虑路由控制和路由策略的情况下，使用距离矢量（路径矢量）算法，默认以AS为单位计算代价，即到达目的网络最优路径是经过的AS最少的。 使用TCP作为传输层，端口号为179 支持CIDR技术 路由信息中可以携带丰富的路由属性，提供丰富的路由控制机制和路由策略 路由更新机制：只发送增量路由，非周期更新 不支持负载均衡，只选一条最“优”路径 BGP发言人和AS 也称为AS网关路由器，位于AS边界 既运行IGP，又运行BGP BGP的邻居 两个BGP路由器只要能建立TCP连接就能成为邻居 BGP的邻居建立由管理员手动配置，不是自动寻找 BGP的两种邻居关系IBGP和EBGPEBGP：两个BGP邻居不在同一个AS，IBGP：两个BGP邻居位于同一个AS 从IBGP学习到的路由是否需要通告给其他IBGP邻居？ 如果通告可能出现环路 如果不通告在部分互联网IBGP中会使得路由更新失效 例如：B，E不是IBGP邻居，B获得的路由不告诉E，F也无法得到路由信息 IBGP的水平分割原则 默认BGP认为BGP网络时全互联的，从IBGP邻居获得的路由不通告给其他IBGP邻居 解决中转路径上路由问题的方法方法1：同步（早期使用的办法），将BGP获得的路由重分布到IGP中，当E收到IBGP路由之后，并通过IGP获得同一网段路由，完成同步，E通告路由给F。同步缺点LBGP路由太多，重分布到IGP之后给IGP带来太多负担，建议禁止同步功能方法2：保证所有中转路径上的路由器都运行BGP BGP的路由通信原则1、路由信息只会通告给邻居，不会洪泛2、从EBGP得到的路由会立刻向所有EBGP邻居和IBGP邻居通告3、从IBGP得到的路由不通告给其他IBGP邻居，在全互联的AS下通告给EBGP邻居 BGP的四种报文OPEN报文用来与相邻的另一个BGP发言人建立关系UPDATE报文用来发送某一路由的信息，以及列出要撤销的多条路由KEEPALIVE报文用来确认打开报文和周期性证实邻站关系NOTIFICATION报文用来发送检测到的差错 BGP属性 防止路由环路的产生 提供丰富的路由策略 常见的BGP属性 Origin AS-Path Next hop MED Local-Preference Atomic-Aggregate Aggregator AS-Path属性记录BGP路由所经过的自治系统号，当某个BGP路由器收到一条包含自己所在自治系统的BGP时会丢弃该路由，从而避免环路 EGP（BGP）和IGP的比较策略AS之间选路策略至关重要，AS内部选路管理和性能更重要规模AS之间网络规模更大，EGP必须能够适应超大规模网络。IGP对此要求不高性能AS之间强调策略开销，不强调实际的网络开销，不强调路由器性能问题，AS内部强调路由花费，必须考虑路由器的性能]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链路状态路由协议与OSPF]]></title>
    <url>%2F2020%2F05%2F26%2F%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E4%B8%8EOSPF%2F</url>
    <content type="text"><![CDATA[链路状态路由算法（LS算法）工作原理 每个路由器将自己的链路状态信息洪泛到网络上的所有路由器。tips:（每个路由器都洪泛会给网络带来负担） 每个路由器最终会知道整个网络的拓扑结构（LSDB）。 每个路由器使用Dijkstra最短路径算法计算本路由器到其他路由器的最短路径，更新路由表。 路由器的链路状态发生变化时会继续洪泛自身的链路状态信息到其他路由器。 链路与链路状态链路的本质上是路由器上的一个接口链路状态是有关各条链路的状态信息链路状态数据包洪泛路由器一旦接收到来自相邻路由器的LSP，立即将该LSP从除接收该LSP的接口以外的所有接口发出 Dijkstra算法（直接见图） Dijkstra算法分析算法复杂度：n个节点 每次迭代需要检查不在N的节点 最差的复杂度：n*（n - 1）/2次比较：O(n^2) 平均的复杂度：O(nlogn)路由振荡 假设，link cost = amount of carried traffic（链路代价与流量和有关），且链路代价的具有方向性，LS算法可能会让分组一会逆时针转发，一会顺时针转发，形成振荡。 本质：同时执行最短路径算法导致路由振荡，可以采用随机数解决同时问题 OSPF协议概述 Open Shortest Path First，开放式最短路径优先路由协议 链路状态路由算法，无路由自环 用于AS内部，属于IGP 使用区域划分，适用于大规模网络 支持VLSM和CIDR 使用组播方式发送协议报文 支持验证 OSPF是基于IP的，协议号为89 OSPF是典型的停止等待协议，自身实现了可靠传输 路由器标识（Router ID） 用于唯一确定OSPF路由器 一个32位的无符号整数，整个自治系统内唯一 若不手动配置，一般取该路由器的所有接口的IP地址的最大值（loopback地址优先） OSPF的链路代价一条OSPF链路的代价定义为：10^8/BandWidth一条OSPF路由的代价为其经过的所有链路代价的总和 OSPF规定的网络类型|网络类型|举例 ||–|–|| 广播 | 以太网 || 非广播多路访问NBMA|帧中继、X.25 || 点到点|PPP，HDLC ||点到多点| 多个点到点链路的集合| 全连通网络的处理选取DR和BDRDR：指定路由器 （村长）BDR：备份指定路由器 （副村长）DR负责通告路由BDR备份 选取规则选取优先级最大的选取router id 最大的 选取方式投票制和终身制OSPF的数据包格式|ODPF包类型| 描述 ||–|–|| Hello （不需要确认）| 用户邻居路由器之间建立和维护邻接关系 ||数据库描述包DBD|描述每台OSPF路由器的链路状态数据库的内容||链路状态请求包LSR|请求链路状态数据库的部分内容||链路状态更新包LSU|传送链路状态数据通告LSA给邻居路由器||链路状态确认包LSAck（不需要确认）|确认邻居发过来的LSA已经收到| OSPF划分区域目的：减少洪泛的范围工作方式： 同一个区域内部路由器之间使用链路状态算法，洪泛的范围限于一个区域内部。 不同区域之间的路由通过ABR（区域边界路由器）负责通告（距离矢量算法） 必须要有骨干区域（area 0)，且所有区域应当和骨干区域物理上直连，保证不会出现路由环路问题。 区域划分可以和IP地址结合在ABR上通告汇总的路由。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解云计算三种服务模式——IaaS、PaaS和SaaS]]></title>
    <url>%2F2020%2F04%2F26%2F%E7%90%86%E8%A7%A3%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%89%E7%A7%8D%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94IaaS%E3%80%81PaaS%E5%92%8CSaaS%2F</url>
    <content type="text"><![CDATA[云计算的服务模式仍在不断进化，但业界普遍接受将云计算按照服务的提供方式划分为三个大类：SaaS（Software as a Service–软件即服务） PaaS（Platform as a Service–平台即服务） IaaS（Infrastructure as a Service–基础架构即服务）。 PaaS基于IaaS实现，SaaS的服务层次又在PaaS之上，三者分别面对不同的需求。1.IaaS: Infrastructure-as-a-Service（基础设施即服务） 第一层叫做IaaS，有时候也叫做Hardware-as-a-Service，以前如果你想在办公室或者公司的网站上运行一些企业应用，你需要去买服务器，或者别的高昂的硬件来控制本地应用，让你的业务运行起来。 但是现在有IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。 一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。2.PaaS: Platform-as-a-Service（平台即服务） 第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。 PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。 一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog, Mendix 和 Standing Cloud3.SaaS: Software-as-a-Service（软件即服务） 第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。 你消费的服务完全是从网页如Netflix, MOG, Google Apps, Box.net, Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分 一些用作商务的SaaS应用包括Citrix的GoToMeeting，Cisco的WebEx，Salesforce的CRM，ADP，Workday和SuccessFactors。区别： 如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：买服务器，安装服务器软件，编写网站程序。 现在你追随潮流，采用流行的云计算， 如果你采用IaaS服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件 而如果你采用PaaS的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序 如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为SaaS。下面是从网上download的一幅图，希望对大家学习有所帮助：]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java socket 实现增删改查 + 在线答题小案例]]></title>
    <url>%2F2020%2F04%2F17%2Fjava%20socket%20%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%20%2B%20%E5%9C%A8%E7%BA%BF%E7%AD%94%E9%A2%98%E5%B0%8F%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[实现效果 （1） 在client端可以实现对数据库的操作（Select，Insert，Update，Delete） （2）数据库中创建一个考试表和学生表，考试表中问题是四项选择题（10道以上），client端做题，成绩存入学生表 （3）实现多个Client程序对server端的访问 Hint：Java程序中会使用多个class，server端使用thread监听多个client 。 一、创建数据库demo，数据表student、question。其中student表存储了学生的姓名以及成绩记录、question表中存储了单项选择题的有关内容。 二、创建Student、Question 两个实体类 包含属性，Getter,Setter方法Student.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.jxnu.demo;/** * @author xiao */public class Student &#123; //主键ID private Integer id; //用户名 private String username; //分数 private String grade; //生日 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getGrade() &#123; return grade; &#125; public void setGrade(String grade) &#123; this.grade = grade; &#125; @Override public String toString() &#123; return "Student&#123;" + "id=" + id + ", username='" + username + '\'' + ", grade=" + grade + '&#125;'; &#125;&#125; Question.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.jxnu.demo;/** * @author xiao */public class Question &#123; private Integer id; private String Content; private String OptionA; private String OptionB; private String OptionC; private String OptionD; private String answer; private String grade; public String getGrade() &#123; return grade; &#125; public void setGrade(String grade) &#123; this.grade = grade; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getContent() &#123; return Content; &#125; public void setContent(String content) &#123; Content = content; &#125; public String getOptionA() &#123; return OptionA; &#125; public void setOptionA(String optionA) &#123; OptionA = optionA; &#125; public String getOptionB() &#123; return OptionB; &#125; public void setOptionB(String optionB) &#123; OptionB = optionB; &#125; public String getOptionC() &#123; return OptionC; &#125; public void setOptionC(String optionC) &#123; OptionC = optionC; &#125; public String getOptionD() &#123; return OptionD; &#125; public void setOptionD(String optionD) &#123; OptionD = optionD; &#125; public String getAnswer() &#123; return answer; &#125; public void setAnswer(String answer) &#123; this.answer = answer; &#125; @Override public String toString() &#123; return "Question&#123;" + "id=" + id + ", Content='" + Content + '\'' + ", OptionA='" + OptionA + '\'' + ", OptionB='" + OptionB + '\'' + ", OptionC='" + OptionC + '\'' + ", OptionD='" + OptionD + '\'' + ", answer='" + answer + '\'' + ", grade='" + grade + '\'' + '&#125;'; &#125;&#125; 三、导入jar包，编写三个与数据库相关的Java Class，DbManage、 StudentDao和QuestionDao。 其中DbManage有三个方法，initDB()负责打开驱动，两个close()方法分别关闭有结果集与无结果集。 DBManage.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.jxnu.demo;import java.sql.*;/** * @author xiao */public class DbManage &#123; //打开驱动 public Connection initDB() &#123; Connection conn = null; final String DRIVER_NAME = "com.mysql.jdbc.Driver"; //数据库连接地址 final String URL = "jdbc:mysql://localhost:3306/socket?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=FALSE&amp;serverTimezone=UTC"; //用户名 final String USER_NAME = "root"; //密码 final String PASSWORD = ""; try &#123; Class.forName(DRIVER_NAME); conn = DriverManager.getConnection(URL,USER_NAME,PASSWORD); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; //关闭无结果集 public void closeDB(PreparedStatement pstmt, Connection con) &#123; try &#123; if(pstmt!=null) &#123; pstmt.close(); &#125; if(con!=null) &#123; con.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //关闭有结果集 public void closeDB(ResultSet rs, PreparedStatement pstmt, Connection con) &#123; try &#123; if(pstmt!=null) &#123; pstmt.close(); &#125; if(con!=null) &#123; con.close(); &#125; if(rs!=null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; StudentDao.javaStudentDao负责有关学生信息的增删查改(insert、update、delete、findAll） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186package com.jxnu.demo;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;/** * @author xiao */public class StudentDao &#123; /** * 添加 * @param student * @return */ public boolean insert(Student student) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; String sql = "insert into student(username,grade) VALUES(?,?)"; boolean res = false; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setString(1,student.getUsername()); pstmt.setString(2,student.getGrade()); res = (pstmt.executeUpdate() == 1); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(pstmt, con); &#125; return res; &#125; /** * 删除 * @param id * @return */ public boolean delete(Integer id) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; String sql = "delete from student where id = ?"; boolean flag = false; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setInt(1, id); int result = pstmt.executeUpdate(); if (result &gt; 0) &#123; flag = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(pstmt, con); &#125; return flag; &#125; /** * 修改信息 * @param student * @return */ public boolean update(Student student) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; String sql = "update student set username=? where id= ?"; boolean res = false; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setString(1,student.getUsername()); pstmt.setInt(2,student.getId()); res = (pstmt.executeUpdate()==1); &#125;catch (SQLException e) &#123; e.printStackTrace(); return false; &#125;finally &#123; dbmanage.closeDB(pstmt, con); &#125; return res; &#125; public boolean updateG(Student student) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; String sql = "update student set grade=? where id= ?"; boolean res = false; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setString(1,student.getGrade()); pstmt.setInt(2,student.getId()); res = (pstmt.executeUpdate()==1); &#125;catch (SQLException e) &#123; e.printStackTrace(); return false; &#125;finally &#123; dbmanage.closeDB(pstmt, con); &#125; return res; &#125; /** * 查找所有数据 * @return */ public List&lt;Student&gt; findAll() &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; ResultSet rs = null; List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); String sql = "select * from student"; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); while (rs.next()) &#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setUsername(rs.getString("username")); student.setGrade(rs.getString("grade")); list.add(student); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(rs,pstmt, con); &#125; return list; &#125; /** * 根据ID查询 * @param id * @return */ public List&lt;Student&gt; findById(Integer id) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; ResultSet rs = null; //MessageEntity messageEntity = new MessageEntity(); List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); String sql = "select * from student where id=?"; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setInt(1, id); rs = pstmt.executeQuery(); while(rs.next())&#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setUsername(rs.getString("username")); student.setGrade(rs.getString("grade")); list.add(student); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(rs,pstmt, con); &#125; return list; &#125;&#125; QuestionDao.javaQuestionDao负责有关题目的增删改查 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.jxnu.demo;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;/** * @author xiao */public class QuestionDao &#123; public List&lt;Question&gt; findAll() &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; ResultSet rs = null; List&lt;Question&gt; list = new ArrayList&lt;Question&gt;(); String sql = "select * from question"; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); while (rs.next()) &#123; Question question = new Question(); question.setId(rs.getInt("id")); question.setAnswer(rs.getString("answer")); question.setContent(rs.getString("content")); question.setOptionA(rs.getString("optionA")); question.setOptionB(rs.getString("optionB")); question.setOptionC(rs.getString("optionC")); question.setOptionD(rs.getString("optionD")); list.add(question); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(rs,pstmt, con); &#125; return list; &#125;&#125; 三、编写StudentService类，用于处理增删改查以及答题的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.jxnu.demo;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.Socket;import java.util.List;/** * @author xiao */public class StudentService&#123; public void show(Socket socket) throws IOException &#123; DataOutputStream out = new DataOutputStream(socket.getOutputStream()); StudentDao dao = new StudentDao(); List&lt;Student&gt; list = dao.findAll(); out.writeUTF(String.valueOf(list)); &#125; public void insert(Socket socket) throws IOException &#123; DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream out = new DataOutputStream(socket.getOutputStream()); out.writeUTF("请输入新增用户名"); String username = input.readUTF(); out.writeUTF("请输入用户成绩"); String grade = input.readUTF(); StudentDao dao = new StudentDao(); Student student = new Student(); student.setUsername(username); student.setGrade(grade); if(dao.insert(student)) out.writeUTF("添加成功"); else out.writeUTF("添加失败"); &#125; public void delete(Socket socket) throws IOException &#123; DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream out = new DataOutputStream(socket.getOutputStream()); out.writeUTF("请输入要删除的ID号"); String id = input.readUTF(); StudentDao dao = new StudentDao(); if(dao.delete(Integer.valueOf(id))) out.writeUTF("删除成功"); else out.writeUTF("删除失败，请确认ID是否存在"); &#125; public void update(Socket socket) throws IOException &#123; DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream out = new DataOutputStream(socket.getOutputStream()); out.writeUTF("请输入要修改的用户ID号"); String id = input.readUTF(); out.writeUTF("请输入修改后的用户名"); String username = input.readUTF(); StudentDao dao = new StudentDao(); Student student = new Student(); student.setId(Integer.valueOf(id)); student.setUsername(username); if(dao.update(student)) out.writeUTF("更新成功"); else out.writeUTF("更新失败"); &#125; public void answer(Socket socket) throws IOException &#123; DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream out = new DataOutputStream(socket.getOutputStream()); QuestionDao questionDao = new QuestionDao(); List&lt;Question&gt; questionList = questionDao.findAll(); Question question = new Question(); out.writeUTF(String.valueOf(questionList.size())); int n = questionList.size(); //out.writeUTF("请输入题号"); int sum = 0; String[] answers = new String[20]; for(int i=0;i&lt;n;i++) &#123; out.writeUTF("第"+(i+1)+"题"+": "+questionList.get(i).getContent()); out.writeUTF("A. " + questionList.get(i).getOptionA() + "\t" + "B. " + questionList.get(i).getOptionB() + "\t" + "C. " + questionList.get(i).getOptionC() + "\t" + "D. " + questionList.get(i).getOptionD()); answers[i]=input.readUTF(); System.out.println(answers[i]); if(answers[i].equals(questionList.get(i).getAnswer())) &#123; out.writeUTF("回答正确,+10 分\n"); sum += 10; &#125; else out.writeUTF("回答错误\n"); &#125; String id = input.readUTF(); out.writeUTF("总成绩为"+sum); StudentDao dao = new StudentDao(); Student student = new Student(); student.setId(Integer.valueOf(id)); student.setGrade(String.valueOf(sum)); if (dao.updateG(student)) out.writeUTF("成绩保存成功"); else out.writeUTF("成绩保存失败"); &#125;&#125; 四、编写Server类。其中server端使用thread监听多个client，根据Client端的指令调用不同的方法并执行。收到指令“1”，执行StudentService中的show()方法，查询出学生表中所有的记录并返回给Client；收到指令“2”，执行StudentService中的insert()方法，获取客户端传来的姓名与成绩并插入student表中。收到指令“3”，执行update()方法，可以实现根据client端传来的ID号和新姓名实现修改姓名的功能;收到指令“4”，执行delete()方法，可以根据Client端传来的ID号实现删除学生记录的功能；收到指令“5”，实现答题功能，用户每回答一个题目，Server端判断正误并将结果返回给Client端，最后计算出总成绩存入student表；收到指令“0”，Client端将断开连接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.jxnu.demo;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.util.List;/** * @author xiao */public class Server &#123; public static final int PORT = 12345;//监听的端口号 public static void main(String[] args) &#123; System.out.println("服务器启动...\n"); Server server = new Server(); server.init(); &#125; public void init() &#123; try &#123; ServerSocket serverSocket = new ServerSocket(PORT); while (true) &#123; // 一旦有堵塞, 则表示服务器与客户端获得了连接 Socket client = serverSocket.accept(); // 处理这次连接 new HandlerThread(client); &#125; &#125; catch (Exception e) &#123; System.out.println("服务器异常: " + e.getMessage()); &#125; &#125; public static class HandlerThread implements Runnable &#123; private Socket socket; public HandlerThread(Socket client) &#123; socket = client; new Thread(this).start(); &#125; public void run() &#123; try &#123; // 读取客户端数据 DataInputStream input = new DataInputStream(socket.getInputStream()); String clientInputStr = input.readUTF();//这里要注意和客户端输出流的写方法对应,否则会抛 EOFException // 处理客户端数据 System.out.println("客户端:" + clientInputStr); // 向客户端回复信息 DataOutputStream out = new DataOutputStream(socket.getOutputStream()); action(clientInputStr,socket); out.close(); input.close(); &#125; catch (Exception e) &#123; System.out.println("服务器 run 异常: " + e.getMessage()); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (Exception e) &#123; socket = null; System.out.println("服务端 finally 异常:" + e.getMessage()); &#125; &#125; &#125; &#125; public void action(String clientInputStr,Socket socket) throws IOException &#123; DataOutputStream out = new DataOutputStream(socket.getOutputStream()); StudentService studentService = new StudentService(); switch (clientInputStr) &#123; case "1": studentService.show(socket); break; case "2": studentService.insert(socket); break; case "3": studentService.delete(socket); break; case "4": studentService.update(socket); break; case "5": studentService.answer(socket); break; case "0": out.writeUTF("OK"); break; default: out.writeUTF("输入指令有误，请重新输入"); &#125; &#125; &#125;&#125; 六、编写Client类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.jxnu.demo;import java.io.BufferedReader;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.io.InputStreamReader;import java.net.Socket;/** * @author xiao */public class Client &#123; public static final String IP_ADDR = "192.168.19.133";//服务器地址 public static final int PORT = 12345;//服务器端口号 public static void main(String[] args) &#123; System.out.println("客户端启动..."); System.out.print("【提示】 1 表示查看所有学生信息, 2 表示添加学生信息, 3 表示删除学生信息, 4表示修改学生信息, 5表示做题, 0表示结束\n "); while (true) &#123; Socket socket = null; try &#123; //创建一个流套接字并将其连接到指定主机上的指定端口号 socket = new Socket(IP_ADDR, PORT); //读取服务器端数据 DataInputStream input = new DataInputStream(socket.getInputStream()); //向服务器端发送数据 DataOutputStream out = new DataOutputStream(socket.getOutputStream()); System.out.println("请输入指令: \t"); String str = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(str); String ret = input.readUTF(); System.out.println("服务器端: " + ret); if("请输入要删除的ID号".equals(ret)) &#123; String id = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(id); String result = input.readUTF(); System.out.println(result); &#125; if("请输入要修改的用户ID号".equals(ret)) &#123; String id = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(id); System.out.println("服务器端: "+input.readUTF()); String username = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(username); String result = input.readUTF(); System.out.println(result); &#125; if("请输入新增用户名".equals(ret)) &#123; String username = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(username); System.out.println("服务端: " + input.readUTF()); String grade = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(grade); String result = input.readUTF(); System.out.println(result); &#125; // 如接收到 "OK" 则断开连接 if ("OK".equals(ret)) &#123; System.out.println("客户端将关闭连接"); Thread.sleep(500); break; &#125; if (ret.length() &lt;=3 ) &#123; Integer n = Integer.valueOf(ret); System.out.println("总共" + n + "道题,每题10分，总分100分"); for(int i=0;i&lt;n;i++) &#123; System.out.println(input.readUTF()); System.out.println(input.readUTF()); System.out.println("请输入答案: "); String answer = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(answer); System.out.println(input.readUTF()); &#125; System.out.println("请输入你的用户ID号"); String id = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(id); String sum = input.readUTF(); System.out.println(sum); String result = input.readUTF(); System.out.println(result); &#125; out.close(); input.close(); &#125; catch (Exception e) &#123; System.out.println("客户端异常:" + e.getMessage()); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); System.out.println("socket is closed"); &#125; catch (IOException e) &#123; socket = null; System.out.println("客户端 finally 异常:" + e.getMessage()); &#125; &#125; &#125; &#125; &#125;&#125; 效果图这里我还弄了点花里胡哨的颜色，有点好看嘿嘿。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机 NAT模式与桥接模式的区别]]></title>
    <url>%2F2020%2F04%2F17%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%20NAT%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[NAT模式：相当于宿主机再构建一个局域网，虚拟机无法和本局域网中的其他真实主机进行通讯。只需要宿主机器能访问互联网，那么虚拟机就能上网，不需要再去配置IP地址，子网掩码，网关。虚拟机和主机能够互相ping通。桥接模式：VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。但是需要我们手动去配置IP地址和网关，IP地址要与主机的无线网的IP段对应，子网掩码，网关，DNS都需要与宿主机保持一致。下面是我将虚拟机从NAT模式换成桥接模式对配置文件做的一些改动，重启网络后，虚拟机可以访问自身静态IP，访问公网，宿主机和虚拟机也可以相互ping通。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 搭建 web服务器 socket实现]]></title>
    <url>%2F2020%2F04%2F17%2Fjava%20%E6%90%AD%E5%BB%BA%20web%E6%9C%8D%E5%8A%A1%E5%99%A8%20socket%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【写在前面】云计算的第n个java作业，开始一直不懂为什么老师一直让我们写java web的小demo，不应该是hadoop啥的直接上框架嘛。后来慢慢了解到，其实java web 的一些内容确实是云计算的基础。这个demo是用java socket 来搭建一个web服务器，以前确实没有接触过，所以这里记录一下。 基本原理（1）设置WebServer端口号（2）使用 ServerSocket.accept()方法,轮询监听用户请求；（3）用户使用浏览器输入地址，向WebServer发出请求；（4）服务器监听到用户请求，为该请求新建一个HttpServer来处理该请求；（5）HttpServer解析用户请求并作出响应；（6）用户浏览器显示响应结果。 一、编写WebServer.java WebServer.java 是整个项目的主线程，用于设置服务器端口号，监听用户的请求，为每一个监听到的请求新建一个HttpServer线程，来处理用户请求。public void startServer(int port) 轮询serverSocket.accept()，监听用户请求。为每一个监听到的请求，新建一个httpserver线程响应 public static void main(String[] args) ，设置服务器端口号，之后，启动Webserver服务器。 123456789101112131415161718192021222324252627282930package com.jxnu.socket;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author xiao */public class WebServer extends Thread&#123; public void startServer(int port)&#123; try &#123; ServerSocket serverSocket = new ServerSocket(port); while(true)&#123; Socket socket = serverSocket.accept(); HttpServer httpServer = new HttpServer(socket); httpServer.start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; new WebServer().startServer(8000); &#125;&#125; 二、编写HttpServer.javaHttpServer.java 继承Thread，用于读取用户访问路径，根据路径响应请求。public HttpServer(Socket socket) 初始化socket对象,获取对应 输入，输出流 public void run() 重载Run（）函数，调用Read（）、response（）函数 private void response(String filePath) 根据读取的路径，进行响应。以流的形式读取文件，再以流的形式输出文件 private String read() 解析请求路径。其中，为了项目的可移植性，文件的解析路径是相对路径，整个文件都放在文件夹resource下。项目目录如下：index.html这里注意加上 1&lt;link rel="shortcut icon" href="#" type="image/x-icon"&gt; 效果图]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用子网掩码划分子网]]></title>
    <url>%2F2020%2F04%2F14%2F%E5%88%A9%E7%94%A8%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%2F</url>
    <content type="text"><![CDATA[分类IP地址的弊端 一个物理网络不能过大，否则网络性能很差，某个B类或A类IP网络无法全部用于单个物理网络 分类IP地址分配不合理，利用率低 分类IP地址设计的弊端 —— 不灵活，IP地址利用率不高 划分子网的思路网络管理员将本应属于一个物理网段的单个分类IP网络划分成多个子网，不同的子网对应不同的物理网段，不同子网之间的通信必须要经过路由器。 remember10000000 (128)11000000 (192)11100000 (224)11110000 (240)11111000 (248)11111100 (252)11111110 (254)11111111 (255) 小案例1、 网络号为192.168.1，子网掩码为255.255.255.224，可以划多少子网，每个子网多少主机？ 255.255.255.224（224==》11100000），这是C类网络所以子网数 = 2^3^子网数 = 2^5^ -2 2、 C类IP地址192.168.5.0， 如何划分使得有20个子网，每个子网5台主机 2^4^ = 16 &lt; 20 2^5^ = 32 &gt; 20所以应该有五位，从上面的remember可以看出5个1对应的是248这是看看主机号是不是也够，2^3^-2=6 &gt; 5 ，所以最终的子网掩码就是255.255.255.248 子网掩码为什么如此设计？IP address AND subnet mask = Network address 193.154.34.129 255.255.255.192的网络地址是？思路：子网掩码前面24位都是1，所以193.154.34.129不变。129==》10000001192==》11000000，与操作（0与任何数与都得0,1与任何数与都不变）之后得到10000000，所以网络地址就是192.154.34.128 划分子网后的分组转发这里有3个子网现在主机H1要发送分组给H2路由器R1逐项查找路由表，决定下一跳。路由器使用每行的子网掩码与目标进行“与”操作，判断结果和目的网络地址是否相同。在这个例子中，会匹配R1路由表中的第二条路。因为H2的IP地址（目标IP地址）为128.30.33.138，128.30.33.138与路由表中的子网掩码（255.255.255.128）做与操作，得到的是128.30.33.128，匹配第二项，选择接口1转发。 路由转发的进一步讨论 使用子网掩码后，路由表是否可能出现多条同时匹配的路由？ 目的网络地址 子网掩码 下一跳 128.30.33.0 255.255.255.0 接口0 128.30.33.128 255.255.255.128 接口1 128.30.36.0 255.255.255.0 R2 在这张路由表中，IP为128.30.33.138的地址既匹配第一条路又匹配第二条路，出现了多条同时匹配的路由。前缀表示法128.30.33.0/24 =&gt; (24是因为子网掩码有24个1)128.30.33.128/25 =&gt; (25是因为子网掩码有25个1)所以可以看出，下面这个网络是上面这个网络的细分子网结论： 可能，如果出现，采用掩码最长前缀（掩码中1的个数）匹配原则选择路径。若掩码前缀相同，则采用网络负载均衡的方式转发 IP地址的前缀表示法：128.30.33.128/25表示的IP地址的掩码为255.255.255.128在这个例子中，IP地址128.30.33.138同时匹配第一条和第二条路由，由于第二条路由的掩码前缀为25，长于第一条路由，因此选择第二条路由。 路由表原理3条法则 每台路由器根据其自身路由表中的信息独立作出决策 一台路由器的路由表中包含某些信息并不表示其他路由器也包含相同的信息 有关两个网络之间的路径的路由信息并不能提供反向路径（即返回路径）的路由信息 关于路由的说明目标网络路由 最常见的路由项，能匹配一个网络的IP地址 特定主机路由 只能匹配某个特定的主机IP的路由，优先级最高 默认路由（缺省路由） 可以匹配所有IP地址的路由，优先级最低 目的网络地址 子网掩码 下一跳 128.30.33.128 255.255.255.128 接口0 128.30.33.111 255.255.255.255 接口1 0.0.0.0 0.0.0.0 接口2 子网掩码的作用 划分子网，便于管理，提高IP地址利用率]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类的IP地址]]></title>
    <url>%2F2020%2F04%2F13%2F%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[现有物理地址再有IP地址 IP地址的表示方法为点分十进制法 IP地址的设计思想：网络部分 + 主机部分 分类的IP地址特征：根据不同特征的IP地址，事先约定好网络号所占的位数和主机号所占的位数。A类地址全球一共有2^7^-2 个A类网络，每个A类网络共有2^24^-2个主机地址，地址范围是1.0.0.0 — 126.255.255, 网络号全0是没有地址，而127开头的地址保留为本机回环地址（浪费很大，IPV6进行了改进，只用了一个地址表示本机回环地址）。 有两个主机号被保留，主机号全0，如126.0.0.0，表示这个网络地址；主机号全1，如126.255.255.255 ，是广播地址。B类地址全球共有 2^14^ 个B类网络，每个B类网络共有2^16^-2个主机地址，地址范围是：128.0.0.0 — 191.255.255.255C类地址全球共有2^21^个C类网络，每个C类网络共有2^8^-2个主机地址，地址范围是：192.0.0.0 — 223.255.255.255此外还有D类地址和E类地址 特殊的IP地址网络地址主机号全0的地址，例如192.168.1.0特定网络的广播地址主机号全为1的地址，表示特定网络的广播，例如192.168.1.255本地链路广播地址255.255.255.255，表示本机所在的网络广播本机环回地址127开头的地址，表示主机自身，例如127.0.0.1内网地址（私有地址）保留给任何一个公司单位内部网络使用的IP地址，不能出现在公网上，范围是：10.0.0.0 — 10.255.255.255172.16.0.0 — 172.31.255.255192.168.0.0 — 192.168.255.255链路本地地址无IP地址时由操作系统临时分配的IP地址169.254.0.0 — 169.254.255.255 判断IP地址是否可以有效用于公网的接口上1.1.1.1 是10.1.1.0 不是，这是内网地址127.10.2.1 不是，这是本地环回地址169.254.1.2 不是，这是操作地址给的地址，没有地址200.200.200.255 不是，这是C类地址，主机号全1131.107.0.0 不是，这是B类地址，主机号全0229.0.0.1 不是，这是D类地址判断准则：非D，E类地址，非广播地址。非网络地址，非私有地址，非本地环回地址]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop 重新格式化 NameNode]]></title>
    <url>%2F2020%2F04%2F08%2Fhadoop%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%20NameNode%2F</url>
    <content type="text"><![CDATA[【问题描述】 在安装配置hadoop的过程中，很可能发生错误导致datanode或者namenode 启动失败，这时我们可以选择重新格式化 namenode。一、删除data数据和log日志二 、使用命令 bin/dfs namenode -format 重新格式化【注意事项】为什么不能一直格式化NameNode，格式化NameNode需要注意什么？ 原因： 格式化NameNode，会产生新的集群id，导致NameNode 和 DataNode的集群id 不一致，集群找不到以往数据。]]></content>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令整理 —— vi 和 vim 编辑器]]></title>
    <url>%2F2020%2F04%2F03%2FLinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%20%E2%80%94%E2%80%94%20vi%20%E5%92%8C%20vim%20%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、目录结构二 、vim 和 vim 编辑器2.1【基本介绍】所有的 Linux 系统都会内建 vi 文本编辑器。vim 具有程序编辑的能力，可以看做是 vi 的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。2.2 三种常见模式 1、正常模式 以 vim 打开一个档案就直接进入一般模式了(默认)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。 2、插入模式/编辑模式在模式下，程序员可以输入内容。按下 i, I, o, O, a, A, r, R 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可 3、命令行模式在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！ 2.3 快捷键 1) 拷贝当前行 yy , 拷贝当前行向下的 5 行 5yy，并粘贴（p）。2) 删除当前行 dd , 删除当前行向下的 5 行 5dd3) 在文件中查找某个单词 [命令行下 /关键字 ， 回车 查找 , 输入 n 就是查找下一个 ]4) 设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu]5) 编辑 /etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg],注意这些都是在正常模式下执行的。6) 在一个文件中输入 “hello” ,然后又撤销这个动作，再正常模式下输入 u7) 编辑 /etc/profile 文件，并将光标移动到 第 20 行 shift+g第一步：显示行号 :set nu 第二步：输入 20 这个数第三步: 输入 shift+g]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令整理 —— 目录结构]]></title>
    <url>%2F2020%2F03%2F26%2FLinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%20%E2%80%94%E2%80%94%20%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[二 、vi 和 vim 编辑器【写在前面】云计算与分布式这门课程的实验都是在Linux下完成的，虽然之前也一直也学习过Linux，但是一直没有系统的过一遍。这周花了两天的时间看完了尚硅谷的Linux教程，在这里记录一下学习过程，也方便自己以后的学习。一、目录结构在 Linux 世界里，一切皆文件linux 的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。具体目录结构➢/bin（/usr/bin、/usr/local/bin） 是Binary的缩写，这个目录存放着最经常使用的命令 ➢/sbin (/usr/sbin、/usr/local/sbin) s就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序 ➢/home 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 ➢/root 该目录为系统管理员，也称作超级权限者的用户主目录 ➢/boot 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 ➢/proc 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息 ➢/srv service 缩写，该目录存放一些服务启动后需要提取的数据 ➢/sys 这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 ➢/tmp 这个目录是用来存放一些临时文件的 ➢/dev 类似于winldows的设备管理器，把所有的硬件用文件的形式存储。 ➢/media linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 ➢/mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。 ➢/opt 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。 ➢/usr/local 这是另一个给主机额外安装软件所安装的目录。-般是通过编译源码方式安装的程序。 ➢/var 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。 ➢/selinux [security-enhanced linux] 360 SELinux是一种安全子系统，它能控制程序只能访问特定文件。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据技术生态体系]]></title>
    <url>%2F2020%2F03%2F25%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop的组成]]></title>
    <url>%2F2020%2F03%2F25%2FHadoop%E7%9A%84%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[一、Hadoop 1.x 和 2.x 的区别二、HDFS架构1）NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。（笔者把它简单理解为书的目录）2）DataNode（dn）：在本地文件系统存储文件块数据，以及块数据的校验和。（笔者把它简单理解为书中真正的内容） 3）Secondary NameNode（2nn）：用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。 三、YARN架构1）ResourceManager（RM） 处理客户端请求 监控NodeManager 启动或监控ApplicationMaster 资源的分配与调度 2）NodeManager（NM） 管理单个节点上的资源 处理来自ResourceManager的命令 处理来自ApplicationMaster的命令 3）ApplicationMaster（AM） 负责数据的切分 为应用程序申请资源并分配给内部的任务 任务的监控与容错 4）Containeryarn中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘等]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输层协议详解]]></title>
    <url>%2F2020%2F03%2F20%2F%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、传输层的概念和服务1、传输层的基本概念 传输层负责端到端之间的数据传输控制 传输层依赖于网络层的服务，对应用层提供传输服务2、传输层的功能跟踪会话 跟踪源主机和目的主机上应用程序间的每次通信 数据分段 将数据分段，并管理每个分段 数据重组 将数据重组，并管理每个片段 标识应用程序 标识不同的应用程序 3、因特网传输层提供的服务 无连接不可靠的服务（UDP） 面向连接可靠的传输服务（TCP） 因特网传输层不能提供的服务 实时性保证 带宽承诺 可靠的广播通信 二、UDP协议1、UDP协议概述特性： “最简单的”Internet传输协议 提供不可靠的数据传输，又称“尽力而为”的服务，其本质是宁缺毋滥，尽力传输 UDP协议允许： 数据丢失 应用数据乱序到达 在UDP收发双方之间，无需握手建立连接 每个UDP数据段的操作都互相独立 2、UDP协议的首部 三、可靠传输协议1、可靠传输协议概述概念： 可靠传输协议保证接收方接收到的数据一定是正确、按序的 注意： 可靠传输协议不能保证数据一定到达 应用层次： 可靠传输协议的机制可以用于数据链路层、网络层、传输层和应用层 2、停止等待协议的设计定义： SW（stop and wait）停止等待协议 发送方每发送一个报文，必须收到接收方的回复确认后才能发送下一个报文 停止等待协议1.0的讨论 差错的方法 校验和、CRS冗杂检验等 从错误中恢复的方法 使用确认（ACKs）和否认（NAKs）机制 若收到NAK，重传分组（缓存机制） 停等协议的设计缺陷？ACK/NAK出错重复分组…… 所以引入了序号机制 停等协议2.0 停等协议3.0前提：数据可能出错和丢失 数据丢失的处理方法： 发送方对发送的分组定义一个超时时间（定时器），若在超时时间里没有收到ACK，则认为数据丢失。 数据超时则直接重传数据 停等协议3.0超时讨论 问题： 数据超时是否一定丢失？ 结论： 数据超时并非一定丢失了，可能确认丢失，也可能分组或确认延迟了 超时未丢失将导致重复分组问题，使用序号解决重复分组问题 进一步思考： 超时时间如何确定，固定的还是变化的？ 结论： 超时时间应当根据RTT（往返时间）动态变化 超时时间应当大于历史分组的RTT 更特殊的情况]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输层协议]]></title>
    <url>%2F2020%2F03%2F20%2F%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[一、传输层的基本概念及功能基本概念 传输层负责端（主机）到端（主机）之间的数据传输控制 传输层依赖于网络层的服务，对应用层提供传输服务 传输层的功能跟踪会话 跟踪源主机和目的主机上应用程序间的每次通信； 数据分段 将数据分段，并管理每个片段； 数据重组 将数据重组，并管理每个片段； 标识应用程序 标识不同的应用程序 应用层标识-分用和复用 分用：接收方传输层根据端口号分用到不同的应用层进程 复用：发送方不同的应用层进程根据不同端口号复用到同一传输层中 二、因特网传输层提供的服务 无连接不可靠的服务（UDP） 面向连接可靠的传输服务（TCP） 因特网传输层不能提供的服务 实时性保证 带宽承诺 可靠的广播通信三、UDP协议概述 特性： ”最简单的“ Internet传输协议 提供不可靠的数据传输，又称“尽力而为的 try best effort” 的服务，其本质是宁缺毋滥，尽力传输 UDP协议允许： 数据丢失 应用数据乱序到达 在UDP收发双方之间，无需握手建立连接 每个UDP数据段的操作都互相独立 四、可靠传输协议概念可靠传输协议保证接收方接收到的数据一定是正确、按序的。注意：可靠传输协议不能保证数据一定到达 停止等待协议的设计 定义： SW（stop and wait）停止等待协议 发送方每发送一个报文，必须收到接收方的回复确认后才能发送下一个报文。 这种情况下乱序不存在 停止等待协议1.0查错的方法 校验和、CRS冗余检验等从错误中恢复的方法 使用确认（ACKs)和否认（NAKs)机制 若收到NAK，重传分组（缓存机制） 停止等待协议2.0 停止等待协议3.0 前提：数据可能出错和丢失 数据丢失的处理方法：发送方对发送的分组定义一个超时时间（定时器），数据超时则重传数据 数据超时并非一定丢失了，也可能确认丢失，也可能分组或确认延迟了。 超时未丢失将导致重复分组问题，使用序号解决重复分组问题 超时时间应当根据RTT（往返时间）动态变化。超时时间应当大于历史分组的RRT]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP协议、电子邮件系统、Telnet远程控制]]></title>
    <url>%2F2020%2F03%2F20%2FFTP%E5%8D%8F%E8%AE%AE%E3%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81Telnet%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、FTP协议FTP定义 文件传输协议（File Transfer Protocol） 用于因特网文件传输（RFC 959） FTP特性 使用客户端/服务器模式 使用TCP提供可靠的传输 FTP属于维护状态的协议 FTP使用两条TCP连接完成数据传输 FTP的两条连接数据连接问题 当有具体文件或目录内容传输时，临时建立数据连接 主动模式下由服务器方发起，服务器端口号20 被动模式下由客户端发起，服务器端口号不确定 二、电子邮件系统电子邮件系统的组成用户代理 电子邮件客户端软件，如浏览器,Outlook,Outlook Express,Foxmail等 邮件服务器 提供邮件服务的主机如 sina邮件服务器sina.com, google的邮件服务器gmail.com 邮件发送和接收协议 HTTP，SMTP，POP，IMAP等 SMTP协议 定义： Simple Mail Tranfer Protocol：简单邮件传输协议 用于使用邮件代理发邮件给邮件服务器或邮件服务器之间转发邮件 SMTP特性： 使用TCP可靠的传送邮件报文，服务器监听端口为25 使用命令/响应代码完成邮件传输的控制交互 SMTP只能传送7bit的ASCII码的邮件报文 SMTP采用持续性的方式发邮件 Quote Printable编码方式 把一个8bit的非ASCII字符用两个16进制数值表示，然后在前面加“=” QP编码方式适用于当所传送的数据中只有少量的非ASCII，例如汉字 邮件接收协议简介用户收取邮件常用的协议 POP（Post Office Protocol邮局协议）：服务器端口默认110 IMAP（Internet Mail Access 因特网邮件访问协议）：服务器默认端口143 HTTP 三、Telnet远程控制 Telnet用于终端使用命令行方式对服务器进行远程控制。端口号为TCP的23 Telnet服务配置Telnet 的客户端称为VTY（虚拟终端），Telnet不安全，明文传输，可以使用更安全的SSH协议替代。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx启动后无法访问页面]]></title>
    <url>%2F2020%2F03%2F19%2FNginx%E5%90%AF%E5%8A%A8%E5%90%8E%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[【问题描述】Nginx启动后浏览器输入IP地址无法访问页面 一、检查Nginx是否成功启动./sbin/nginx -t 二、检查80端口是否开放 三、打开防火墙80端口，重启防火墙firewall-cmd --zone=public --add-port=8082/tcp --permanent systemctl restart firewalld.service]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 安装并启动 Nginx]]></title>
    <url>%2F2020%2F03%2F19%2FCentOS%207%20%E5%AE%89%E8%A3%85%E5%B9%B6%E5%90%AF%E5%8A%A8Nginx%2F</url>
    <content type="text"><![CDATA[一、安装必要的库1、安装gcc gcc-c ++1yum install -y gcc gcc-c ++2、gzip模块需要 zlib 库123456cd /usr/localwget http://zlib.net/zlib-1.2.11.tar.gztar -zxvf zlib-1.2.11.tar.gzcd zlib-1.2.11./configmake &amp;&amp; make install 3、重写模块需要pcre库 123456cd /usr/localwget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gztar -zxvf pcre-8.33.tar.gzcd pcre-8.33./configuremake &amp;&amp; make install 4、ssl功能需要openssl库 123456cd /usr/localwget http://www.openssl.org/source/openssl-1.0.1j.tar.gztar -zxvf openssl-1.0.1j.tar.gzcd openssl-1.0.1j./configuremake &amp;&amp; make install 二、安装nginx123456cd /usr/localwget http://nginx.org/download/nginx-1.14.0.tar.gztar -zxvf nginx-1.14.0.tar.gzcd nginx-1.14.0./configure --user=nobody --group=nobody --prefix=/usr/localinx --with-http_stub_status_module --with-http_gzip_static_module --with-http_realip_module --with-http_sub_module --with-http_ssl_module --with-pcre=/usr/local/pcre-8.33 --with-zlib=/usr/local/zlib-1.2.11 --with-openssl=/usr/local/openssl-1.0.1jmake &amp;&amp; make install 三、启动12cd /usr/local/nginx./sbin/nginx 四、浏览器访问IP地址，出现Welcome to nginx!]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成MyBatis的分页插件PageHelper]]></title>
    <url>%2F2020%2F03%2F14%2FSpringBoot%E9%9B%86%E6%88%90MyBatis%E7%9A%84%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper%2F</url>
    <content type="text"><![CDATA[【写在前面】项目的后台管理系统需要展示所有资源信息，select * 虽然方便但数据量过于庞大会严重降低查找效率，页面加载慢，用户体验差。分页自然是必要选择，但原生的方法过于繁杂。MyBatis的分页插件PageHelper和SpringBoot的集成是更好的选择，它的使用非常简单，开发更为高效。代码如下 一、pom文件导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; 二、配置application.yml 123456##pagehelper分页插件pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 三、编写PageRequest、PageResult 实体类 12345678910111213141516171819202122232425262728package com.jxnu.os.model;/** * @author xiao */public class PageRequest &#123; /** * 当前页码 */ private int pageNum; /** * 每页数量 */ private int pageSize; public int getPageNum() &#123; return pageNum; &#125; public void setPageNum(int pageNum) &#123; this.pageNum = pageNum; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.jxnu.os.model;import java.util.List;/** * @author xiao */public class PageResult&#123; /** * 当前页码 */ private int pageNum; /** * 每页数量 */ private int pageSize; /** * 记录总数 */ private long totalSize; /** * 页码总数 */ private int totalPages; /** * 数据模型 */ private List&lt;?&gt; content; public int getPageNum() &#123; return pageNum; &#125; public void setPageNum(int pageNum) &#123; this.pageNum = pageNum; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public long getTotalSize() &#123; return totalSize; &#125; public void setTotalSize(long totalSize) &#123; this.totalSize = totalSize; &#125; public int getTotalPages() &#123; return totalPages; &#125; public void setTotalPages(int totalPages) &#123; this.totalPages = totalPages; &#125; public List&lt;?&gt; getContent() &#123; return content; &#125; public void setContent(List&lt;?&gt; content) &#123; this.content = content; &#125;&#125; 四、service层 编写findPage、PageInfo方法 12345678910111213141516public PageResult findPage(PageRequest pageRequest,Integer p_id) &#123; return PageUtils.getPageResult(pageRequest, getPageInfo(pageRequest,p_id)); &#125; /** * 调用分页插件完成分页 * @param pageRequest * @return */ private PageInfo&lt;Resource&gt; getPageInfo(PageRequest pageRequest,Integer p_id) &#123; int pageNum = pageRequest.getPageNum(); int pageSize = pageRequest.getPageSize(); PageHelper.startPage(pageNum, pageSize); List&lt;Resource&gt; resources = resourceMapper.selectPage(p_id); return new PageInfo&lt;Resource&gt;(resources); &#125; 五、controller层编写findPage方法 123456@PostMapping(value="/findPage") public Object findPage(@RequestBody(required = false) PageRequest pageQuery,Integer p_id) &#123; //System.out.println(pageQuery.getPageNum()); //System.out.println(p_id); return resourceService.findPage(pageQuery,p_id); &#125; ok ,大功告成！]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot前后端分离项目MultipartFile获取前端传的file为null问题]]></title>
    <url>%2F2020%2F03%2F14%2Fspringboot%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AEMultipartFile%E8%8E%B7%E5%8F%96%E5%89%8D%E7%AB%AF%E4%BC%A0%E7%9A%84file%E4%B8%BAnull%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[【问题描述】springboot+vue 前后端分离项目，在对接上传文件功能时，一直显示文件为空。【分析】查找了很多博客，解决方法五花八门，但原因应该还是 springboot自带的org.springframework.web.multipart.MultipartFile和Multipart冲突。所以使用 @EnableAutoConfiguration 注解的exclude属性 进行排除。 【解决方法】亲测有效！！！代码如下： 12345678910111213@EnableAutoConfiguration(exclude = &#123;MultipartAutoConfiguration.class&#125;)public class UploadConfig &#123; @Bean(name = "multipartResolver") public MultipartResolver multipartResolver() &#123; CommonsMultipartResolver resolver = new CommonsMultipartResolver(); resolver.setDefaultEncoding("UTF-8"); resolver.setResolveLazily(true); resolver.setMaxInMemorySize(40960); //上传文件大小 resolver.setMaxUploadSize(5 * 1024 * 1024); return resolver; &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式——ACID原则 CAP理论]]></title>
    <url>%2F2020%2F03%2F11%2F%E5%88%86%E5%B8%83%E5%BC%8F%E2%80%94%E2%80%94ACID%E5%8E%9F%E5%88%99%20%20CAP%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[分布式计算的原理分布式计算就是将计算任务分摊到大量的计算节点上，一 起完成海量的计算任务。而分布式计算的原理和并行计算 类似，就是将一个复杂庞大的计算任务适当划分为一个个 小任务，任务并行执行，只不过分布式计算会将这些任务 分配到不同的计算节点上，每个计算节点只需要完成自己 的计算任务即可，可以有效分担海量的计算任务。而每个 计算节点也可以并行处理自身的任务，更加充分利用机器 的CPU资源。最后再将每个节点的计算结果汇总，得到最 后的计算结果。 分布式计算的理论基础ACID原则ACID是数据库事务正常执行的四个原则，分别指原子性、一致性、独立性及持久性。 A（Atomicity）—— 原子性 原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失 败，整个事务就失败，需要回滚。 例如银行转账，从A账户转100元至B账户，分为两个步骤：①从A账户取 100元；②存入100元至B账户。 这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失 败，钱会莫名其妙少了100元。 C（Consistency）—— 一致性 一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。 例如现有完整性约束a + b = 10，如果一个事务改变了a，那么必须得改变 b，使得事务结束后依然满足a + b = 10，否则事务失败。 I（Isolation）—— 独立性 所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问 的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问 的数据就不受未提交事务的影响。 例如交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如 果此时B查询自己的账户，是看不到新增加的100元的。 D（Durability）—— 持久性 持久性是指一旦事务提交后，它所做的修改将会永久保存在数据库上， 即使出现宕机也不会丢失。 这些原则解决了数据的一致性、系统的可靠性等关键问题，为关系数据 库技术的成熟以及在不同领域的大规模应用创造了必要的条件。 CAP理论 一个分布式系统最多只 能同时满足一致性（Consistency）、可用 性（Availability）和分区容错性（Partition tolerance）这三项中的两项。 一致性指“All nodes see the same data at the same time”，即更新操作成功并返 回客户端完成后，所有节点在同一时间的数据完全一致。对于一致性，可以分 为从客户端和服务端两个不同的视角来看。 从客户端来看，一致性主要指多并发访问时更新过的数据如何获取的问题。 从服务端来看，则是如何将更新复制分布到整个系统，以保证数据的最终一 致性问题。 可用性 指“Reads and writes always succeed”，即服务一直可用，而且是 在正常的响应时间内。对于一个可用性的分布式系统，每一个非故障的节点 必须对每一个请求作出响应。也就是该系统使用的任何算法必须最终终止 当同时要求分区容错性时，这是一个很强的定义：即使是严重的网络错误， 每个请求也必须终止。好的可用性主要是指系统能够很好地为用户服务，不 出现用户操作失败或者访问超时等用户体验不好的情况。通常情况下可用性 和分布式数据冗余、负载均衡等有着很大的关联。 分区容错性 指“The system continues to operate despite arbitrary message loss or failure of part of the system”，也就是指分布式系统在遇到某节点或网络 分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原 因导致系统无法正常运转。好的分区容错性要求应用虽然是一个分布式系统， 但看上去却好像是一个可以运转正常的整体。例如现在的分布式系统中有某 一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求， 或者是机器之间有网络异常，将分布式系统分隔为独立的几个部分，各个部 分还能维持分布式系统的运作，这样就具有好的分区容错性。 CAP权衡无法同时满足一致性、可用性和分区容错性这三个特性，那应该如何取舍呢？ （1）CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用 性）是可以保证的。但其实分区始终会存在，因此CA的系统更多的是允许分区 后各子系统依然保持CA。 （2）CP without A：如果不要求A（可用），相当于每个请求都需要在Server之 间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很 多传统的数据库分布式事务都属于这种模式。 （3）AP without C：要高可用并允许分区，则需放弃一致性。一旦分区发生， 节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务， 而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承与多态]]></title>
    <url>%2F2020%2F03%2F05%2FJava%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[☆ 继承 ☆ 继承是面向对象思想的三大特性之一，使类与类之间产生特殊 - 一般的关系，即is-a关系。 继承是从已有类中派生出新的类，新的类能吸收已有类的属性和方法，并且能拓展新的属性和行为。 在Java中使用extends关键字表示继承，语法表示为: class 子类 extends 父类{}。 子类被称为派生类，父类又被称为超类。 子类继承父类，表明子类是一种特殊的父类，子类拥有父类的属性和方法，并且子类可以拓展具有父类所没有的一些属性和方法。 子类即使不扩展父类，也能维持拥有父类的操作。 优缺点优点提高了代码的复用性提高了代码的维护性让类与类之间产生了关系，是多态的前提缺点增加了耦合性OOP思想开发原则：高内聚，低耦合耦合：类与类之间的关系内聚：自身完成事情的能力 继承特点Java只支持单继承，不支持多重继承操作（extends A,B,C..） 123class A &#123;&#125;class B &#123;&#125;class C extends A,B &#123;&#125; // 错误的，一个子类继承了两个父类，Java中不允许 为什么只支持单继承？ 多继承会存在安全隐患，因为当继承的多个类都存在相同的属性或方法名相同方法体不同的方法，子类进行调用时，就会产生不知道该调用哪一个类中的方法的情况。 Java支持多层继承（继承体系） 123class A &#123;&#125;class B extends A &#123;&#125;class C extends B &#123;&#125; 超类Animal派生出子类Dog 123456789101112131415public class Ch_4_13&#123; public static void main (String[] args) &#123; Dog d=new Dog(); d.name="Snoppy"; d.age=3; d.bark(); //引用完全合法 &#125;&#125;class Animal &#123; public String name; public int age; public void eat()&#123; System.out.println(name +" are eating！");&#125;&#125;class Dog extends Animal &#123; public void bark()&#123; System.out.println("Dog barks！");&#125;&#125; ☁ is - A 与 has - A 关系has - A: 意为“有什么”，刻画的是类与成员之间的关系，决定了对象能实施的动作。is - A: 意为“是什么”，刻画的是对象与类之间的关系，可用于判别对象间的赋值兼容。 1234567891011121314class Animal &#123; public String name; public int age; public void eat()&#123; System.out.println(name +" are eating！");&#125;&#125;class Dog extends Animal &#123; public void bark()&#123; System.out.println("Dog barks！");&#125;&#125;Animal a = new Dog();//合法，因为Dog和Animal满足is-A关系，即Dog对象是Animal对象a.age = 2;//合法，a是Animal类型，Animal与age满足has-A关系a.bark();//非法，a是Animal类型，Animal与bark()不满足has-A关系Dog d = new Animal();//非法，Animal对象不一定是Dog ☆ 多态 ☆多态概述 多态是继封装、继承之后，面向对象的第三大特性。 多态现实意义理解： a. 现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。b. Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。 前提条件：必须有子父类关系。 多态体现为父类引用变量可以指向子类对象。 在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。 重写(Override) 从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。 发生在父类与子类之间 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 final 方法不能被子类重写 静态方法不能被子类重写 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private) 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常 123456789101112class A&#123; public void f(int x)&#123;;&#125; &#125;public class Ch_4_20 extends A&#123; public void f(int x)&#123;;&#125; //对超类A中的f()正确的重写 //void f(double x)&#123;;&#125; //是重载，而不是重写 //public int f(int x)&#123;return 0;&#125; //编译错，不能根据返回类型来区分重写 //void f(int x)&#123;;&#125; //编译错，重写时缩小了访问权限&#125; 重载(Overload)在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。 重载Overload是一个类中多态性的一种表现 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java抽象类、接口、类的特殊成员]]></title>
    <url>%2F2020%2F03%2F05%2FJava%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[抽象类在面向对象的概念中，所有的对象都是通过类来描绘的，但是并不是所有的类都是用来描绘对象的.如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类往往用来表征我们在对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。比如：如果我们进行一个图形编辑软件的开发，就会发现问题领域存在着圆、三角形 这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域是不存在的，它就是一个抽象概念。正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。 抽象方法：一种特殊的方法，它只有声明，而没有具体的实现（无方法体）。抽象方法的声明格式为： 1abstract void f(); 抽象方法必须用abstract关键字进行修饰。abstract 只能修饰类或类中的成员方法，不能修饰属性。被修饰的类或方法分别称作抽象类或抽象方法。其中抽象方法不能有方法体，而抽象类不能实例化，如果一个类含有抽象方法，则这个类一定为抽象类，抽象类必须在类前用abstract关键字修饰。当然，抽象类也可以没有抽象方法。 12345abstract class Test1&#123; abstract void f();//正确， 抽象方法不能有方法体 abstract void g()&#123;;&#125;//编译错， 抽象方法不能有方法体 void h();//编译错， 非抽象类必须有方法体&#125; 【注意】：abstract 不能修饰最终方法、静态方法或构造函数，因为这三类方法都不能被子类重写。 12345abstract class Test2&#123; abstract Test2();//编译错， 构造函数不能被abstract修饰 abstract final void f();编译错， final方法不能被abstract修饰 abstract static void g();编译错， 静态方法不能被abstract修饰&#125; 抽象类是契约的重量级应用方式 接口是契约的轻量级应用方式 接口Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。特点： 就像一个类一样，一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。（即只有方法标识符，而没有方法体）。 接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。 一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。 如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类）。 为什么要用接口： 接口被用来描述一种抽象。 因为Java不像C++一样支持多继承，所以Java可以通过实现接口来弥补这个局限。 接口也被用来实现解耦。 接口被用来实现抽象，而抽象类也被用来实现抽象，为什么一定要用接口呢？- 接口和抽象类之间又有什么区别呢？原因是抽象类内部可能包含非final的变量，但是在接口中存在的变量一定是final，public， static的。 接口的实现： 1234[修饰符] interface 接口名 [extends 父接口列表]&#123; [public][static][final]类型 成员常量 = 常量值 [public][abstract] 返回类型 成员方法名（[参数列表]）&#125; 具体的例子：我们知道，如果某个设备需要向电脑中读取或者写入某些东西，这些设备一般都是采用USB方式与电脑连接的，我们发现，只要带有USB功能的设备就可以插入电脑中使用了，那么我们可以认为USB就是一种功能，这种功能能够做出很多的事情（实现很多的方法），其实USB就可以看做是一种标准，一种接口，只要实现了USB标准的设备我就认为你已经拥有了USB这种功能。（因为你实现了我USB标准中规定的方法）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//先声明USB接口：其中规定了要实现USB接口就必须实现接口规定实现的read( )和write( )这两个方法。interface USB &#123; void read(); void write();&#125;//然后在写一个U盘类和一个键盘类，这两个类都去实现USB接口。（实现其中的方法）class YouPan implements USB &#123; @Override public void read() &#123; System.out.println("U盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("U盘正在通过USB功能写入数据"); &#125;&#125;class JianPan implements USB &#123; @Override public void read() &#123; System.out.println("键盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("键盘正在通过USB功能写入数据"); &#125;&#125;//那么，现在U盘和键盘都实现了USB功能，也就是说U盘和键盘都能够调用USB接口中规定的方法，并且他们实现的方式都不一样。public class Main &#123; public static void main(String[] args) &#123; //生成一个实现可USB接口（标准）的U盘对象 YouPan youPan = new YouPan(); //调用U盘的read( )方法读取数据 youPan.read(); //调用U盘的write( )方法写入数据 youPan.write(); //生成一个实现可USB接口（标准）的键盘对象 JianPan jianPan = new JianPan(); //调用键盘的read( )方法读取数据 jianPan.read(); //调用键盘的write( )方法写入数据 jianPan.write(); &#125;&#125; 运行结果 1234U盘正在通过USB功能读取数据U盘正在通过USB功能写入数据键盘正在通过USB功能读取数据键盘正在通过USB功能写入数据 【注意】：1）接口不是类，接口中的方法都是抽象的，是没有方法体的没有构造函数，也不能实例化出对象。2）一个类可以实现不止一个接口。3）一个接口可以继承于另一个接口，或者另一些接口，接口也可以继承，并且可以多继承。4）一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。5）接口中所有的方法都是抽象的和public的，所有的属性都是public,static,final的。6）接口用来弥补类无法实现多继承的局限。7）接口也可以用来实现解耦。 123456789interface A&#123; int x = 1;&#125;interface B&#123; int y = 2;&#125;interface C extends A,B&#123; int z = 3;&#125;//也称C为复合接口，它有A，B两个父接口 类中的特殊成员——内嵌类型、初始化块、本地方法 内嵌类型 内嵌类型就是在类或接口内部定义的自定义类型，你包括内部类和内部接口。包围内部类或内部接口的类称为囿类型，或包围类型、外部类型等。 12345678910111213141516171819class A&#123; //A是包围类 class B&#123; //内部类 int x; &#125; interface C&#123; //内部接口 int y = 0; &#125;&#125;编译后将产生三个文件：A.class、A$B.class、A$C.classinterface X&#123; //X是包围接口 class Y&#123; //内部类 int x; &#125; interface Z&#123; //内部接口 int y = 0; &#125;&#125;编译后将产生三个文件：X.class、X$Y.class、X$Z.class 内部类存取规则：1、作为囿类的成员，内部类可以存取囿类的其他所有成员，包括私有成员。2、存取内部类及其成员必须要借助囿类或囿类的对象。显然，若囿类对象不能访问，那么内部类也不能访问。 12345678910111213141516171819202122232425262728public class Ch_4_27 &#123; public static void main (String[] args) &#123; Z a=new Z(); Z.B ab=a.g(); //★★★借助囿类提供的方法获得内部类对象 ab.h2(); //★★★正确，可调用内部类的public方法 //ab.y=6; //编译错，不能访问私有成员 //A.B ab1=new A.B(); //编译错，不能以这种方式创建内部类对象 //A.B ab1=new a.B(); //编译错，不能以这种方式创建内部类对象 Z.B ab1=new Z().new B(); //★★★可用这种方式直接创建内部类对象 Z.B ab2=a.new B(); //★★★可用这种方式直接创建内部类对象 &#125;&#125;class Z&#123; public class B&#123; //内部类定义 private int y; private void h1()&#123;x=10;&#125; //内部类的成员方法可直接访问囿类的私有成员 public void h2()&#123; //用于测试对外部内部类成员的调用 System.out.println("Hi, Executed innerClass Method!"); Z.this.x=5; //★★★此句显示：在内部类中如何引用囿类对象自身 &#125; &#125; private int x; private void f()&#123; //y=5; //编译错，囿类成员方法不能直接访问内部类成员 B b=new B(); b.y=5; //★★★只能借助内部类对象访问内部类的成员 &#125; public B g()&#123; return new B(); &#125;//返回内部类的实例对象&#125; 1、内部类和囿类可以任意访问，没有权限上的限制。但囿类成员方法访问内部类成员，必须要借助内部类的对象，反之则无此限制。 2、在囿类外部，只要权限允许，也可以通过囿类对象访问内部类的成员，如ab.h2()；。但是，ab.y=6则编译错误，因为权限不允许。 3、两种在外部获取内部类对象的方式： 1）通过囿类的public方法返回，如a.g();。 2）直接调用内部类的构造函数，但方式特殊，如new A().new B();或者a.new B();。 静态内部类Java规定：若内部类中有静态成员，则该内部类必须是静态内部类。 123456789101112class A&#123; static class A1&#123; int x; static int y;//正确 &#125; class A2&#123; int a ; static int b; //编译错，非静态内部类中不能有静态成员 &#125;&#125;A.A1.y = 10;//合法 测试静态类和非静态类 成员内部类(可以使用private、default、 protected、 public任意进行修饰。类文件:外部类$内部类.class) a)非静态内部类(外部类里使用非静态内部类和平时使用其他类没什么不同) i. 非静态内部类必须寄存在一个外部类对象里。因此,如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 ii. 非静态内部类可以直接访问外部类的成员,但是外部类不能直接访问非静态内部类成员。 iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。 iv. 外部类的静态方法、静态代码块不能访问非静态内部类,包括不能使用非静态内部类定义变量、创建实例。 v. 成员变量访问要点: 1.内部类里方法的局部变量:变量名。 2.内部类属性: this.变量名。 3.外部类属性:外部类名.this.变量名。 123456789101112131415161718192021222324252627public class TestInnerClass &#123; public static void main(String[] args) &#123; //创建内部类对象 Outer.Inner inner = new Outer().new Inner(); inner.show(); &#125;&#125;class Outer&#123; private int age = 10; public void testOuter() &#123; System.out.println("Outer.testOuter()"); &#125; class Inner&#123; int age = 20; public void show() &#123; int age = 30; System.out.println("外部类的成员变量age:"+Outer.this.age); System.out.println("内部类的成员变量age:"+this.age); System.out.println("局部变量age:"+age); &#125; &#125;&#125; 局部内部类和匿名内部类成员方法中只有局部变量、常量、内部类相应地称作局部内部类。局部变量不能用权限属性、static、abstract等属性的修饰，局部内部类也是如此。局部内部类的作用范围，仅限于其所在的方法。 123456789101112class A&#123; public void f()&#123; int x; class B&#123; int a; public void g()&#123; a = x; //编译错误 局部内部类不能引用所在方法中定义的变量。因为局部变量x存于f()的栈空间，f运行结束x将自动销毁。但对象存在于堆空间，若允许存取x，将可能导致错误。 &#125; &#125;//局部内部类 B b = new B(); &#125; 没有名字的内部类成为匿名类 12345678910111213public class Ch_4_28&#123; public static void main (String[] args) &#123; A a=new A() &#123; //定义A的匿名子类（匿名的局部内部类） public void f()&#123;System.out.println("匿名类.f()");&#125; public void g()&#123;;&#125; //可通过编译但无法使用 &#125;; //作为语句结束符的分号不能少，匿名类定义结束 a.f(); // a.g(); //编译错，因为a是A类型，A中无g()方法 &#125;&#125;class A&#123; public void f()&#123; System.out.println("A.f()"); &#125;&#125; 初始化块初始化块就是在类中独立于成员方法之外的代码段，它没有名字，不带参数，无返回值。被static修饰就是静态初始化块，否则就是实力初始化块。初始化块的执行遵循以下规则：1）初始块的执行顺序遵循其出现的次序。2）实例初始化块先于构造函数。3）静态初始化块在类中的初次加载时执行，仅执行一次，且先于实例初始化块。 1234567891011121314151617181920212223242526272829public class Ch_4_29&#123; public static void main(String[] args) &#123; System.out.print("ppppp== "); new TestBlock(); new TestBlock(99); &#125;&#125;class TestBlock &#123; TestBlock (int x)&#123; System.out.print("1== "); &#125; TestBlock ()&#123; System.out.print("2== "); &#125; static &#123; System.out.print("Static 3 == "); &#125; //静态初始化块 &#123; System.out.print("4== "); &#125; //实例初始化块 &#123; System.out.print("5== "); &#125; //实例初始化块 static &#123; System.out.print("Static 6== "); &#125; //静态初始化块&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成员变量、局部变量、实例变量、静态变量、类变量、常量]]></title>
    <url>%2F2020%2F03%2F05%2F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E3%80%81%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[成员变量：直接在类中声明的变量叫成员变量(又称全局变量)▲ 初始化：如果未对成员变量设置初始值，则系统会根据成员变量的类型自动分配初始值：int分配初始值0、boolean分配初始值false，而自定义类型则分配初始值null▲作用范围：成员变量定义后，其作用域是其所在的整个类。且成员变量的定义没有先后顺序，但是最好将成员变量的定义集中在类的顶部。 123456789101112131415public class Field&#123; static int v;//定义int类型数据 static double w;//定义double类型数据 static char x;//定义char类型数据 static boolean y;//定义boolean类型数据 static String z;//定义String类型数据 public static void main(String[] args) &#123; System.out.println(v);//输出0 System.out.println(w);//输出0.0 System.out.println(x);//输出空，实质上此时x的值为0 System.out.println(y);//输出false System.out.println(z);//输出null &#125;&#125; 局部变量：方法中的参数、方法中定义的变量和代码块中定义的变量统称为局部变量。▲ 初始化：♢ 局部变量在使用以前必须显式初始化或赋值，局部变量没有默认值。♢ 声明局部变量时，数据类型前除final外不允许有其他关键字，即其定义格式为： [final] 数据类型 变量名 = 初始值；▲作用范围：局部变量的作用域范围从定义的位置开始到其所在语句块结束。【注意】1）如果局部变量的名字与全局变量的名字相同，则在局部变量的作用范围内全局变量被隐藏，即这个全局变量在同名局部变量所在方法内暂时失效。2）所以如果在局部变量的作用域范围内访问该成员变量，则必须使用关键字this来引用成员变量。 123456789101112public class LocalVariable&#123; int x = 1;//定义一个int类型的全局变量 void show() &#123; int x = 2;//方法中的局部变量 System.out.println("x="+x);//输出2 System.out.println("x="+this.x);//输出1 &#125; public static void main(String[] args) &#123; new LocalVariable().show(); &#125;&#125; 实例变量：不用 static 修饰的 成员变量 。随对象的创建而创建，每个对象都有自己的独有的实例变量，属于对象私有。调用要实例化对象，用 对象名.实例变量名 才可以调用，如：Student student= new Student (); int YouAge = student.age; (当然，一般都会将成员变量设为 private ，通过属性方法调用)。 静态变量：静态变量就是用 static 修饰的成员变量。又叫 类变量 。一个类里只有一份，属于对象共有，调用是一般用 类名.静态变量名 就可以调用，或者用 对象名.静态变量名 也可以调用，调用的都是同一个变量，如： Student.height 。常量：用 final 修饰的成员变量叫常量。在类中也是只有一份，同时不可以修改它的值。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象语言基础]]></title>
    <url>%2F2020%2F03%2F05%2FJava%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[面向过程 就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向对象 是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。1、 区分类、对象和对象的引用对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 创建对象对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 12345678910111213141516public class Ch_4_1&#123; public static void main(String[] args) &#123; Pet a=new Pet(); //根据Pet类创建出一个对象 System.out.println("A Pet object is created."); a.name="Snoppy"; //修改对象的状态，即对属性成员赋值 a.showMe(); //操控对象的行为（或调用对象对外提供的服务） &#125;&#125; class Pet&#123; String name; //定义成员变量 void showMe()&#123; //定义成员方法 System.out.println("Hi, I'm "+name +" !"); &#125;&#125; 运行结果 12A Pet object is created.Hi, I'm Snoppy ! 【说明】 类中的内容统称为成员 —-&gt; 成员变量、成员方法。 只能通过引用名来操控对象，不能通过属性值。如本例中的a.name、a.showMe()，均为正确写法。 一个Java文件可包含多个类，但是只能存在一个public修饰的类，因为文件名必须与public类同名。若无public类，则文件取名只要满足标识符命名规则即可。文件中每个类（或接口），编译后都会产生一个单独的.class文件与之对应。 类成员可以缺省，俗称空类 1class Species&#123;&#125; 对象和对象引用的内存管理 1、内存空间的自动管理机制：基于栈的内存管理模式 特色：栈空间的数据被系统自动管理，即在函数调用时自动创建数据空间，在函数运行结束时自动释放数据空间。栈空间中的数据与特定函数直接相关。程序员在函数中定义的所有变量，无论是基本类型还是引用类型，均存储在栈空间。2、内存空间的手动管理机制：基于堆的内存管理模式 特色：在程序中给出申请或释放内存单元的指令，可实现内存单元的按需分配或释放。其中堆是一种无结构的内存区域，用于执行期间内存单元的动态分配和释放。所有对象均存储于堆空间。 2、 构造函数关于java类中的构造方法： 构造方法又被称为构造函数/构造器/Constructor 构造方法语法结构： [修饰符列表] 构造方法名（形式参数列表）{ 构造方法体； } 普通方法的语法结构： [修饰符列表] 返回值类型 方法名 （形式参数列表）{ 方法体 } 对于构造方法来说，“返回值类型不需要指定，并且也不能写void, 只要写上void,那么这个方法变成普通方法 构造方法的方法名必须和类名保持一致 构造方法的作用？ -构造方法存在的意义是，通过构造方法的调用，可以创建对象 -初始化实例变量的内存空间 构造方法应该怎么调用？ -普通方法：方法修饰符中有static的时候：类名.方法名（实参列表）、方法修饰符列表中没有static的时候：引用.方法名（实参列表） -new 构造方法名（实参列表） 构造方法调用之后，有返回值吗? 每一个构造方法实际上执行结束后都有返回值，但是这个&quot;return值;&quot;这样的语句不需要写。构造方法结束的时候java程序自动返回值 并且返回值类型是构造方法所在类的类型，由于构造方法的返回值类型就是类本身，所以返回值类型不需要编写 当一个类中没有定义任何构造方法的话，系统默认给该类提供一个无参数的构造方法，这个构造方法被称为缺省构造器 当一个类显示的将构造方法定义出来了，那么系统不再默认为这个类提供缺省构造器。建议手动提供 构造方法支持重载机制。在一个类当中编写多个构造方法，这多个构造方法显然已经构成方法重载机制 1234567891011121314151617181920212223public class ConstructorTest01 &#123; public static void main(String[] args) &#123; User u1 = new User(); User u2 = new User(10); User u3 = new User("zhangsan"); User u4 = new User(10,"zhangsan"); //有static的方法调用,同一个类中类名可要可不要 ConstructorTest01.dosome(); dosome(); //无static的方法调用，需要先创建对象 ConstructorTest01 t = new ConstructorTest01(); t.doOther(); &#125; public static void dosome() &#123; System.out.println("do some!"); &#125; public void doOther() &#123; System.out.println("do other!"); &#125;&#125; 运行结果带有int类型参数的构造器带有String类型的构造器带有int,String类型的构造器do some!do some!do other! 1234567891011121314151617181920public class User &#123; //无参数的构造方法 public User()&#123; System.out.println(); &#125; //有参数的构造方法 public User(int i) &#123; System.out.println("带有int类型参数的构造器"); &#125; public User(String name) &#123; System.out.println("带有String类型的构造器"); &#125; public User(int i,String name) &#123; System.out.println("带有int,String类型的构造器"); &#125; &#125; 运行结果构造函数 P() 被执行!构造函数 B() 被执行!构造函数 C() 被执行! 显然，若要构造出C的对象，必须先构造出其源自超类B的对象部分。同理，要构造出B的对象，则应先构造出A的对象部分。这说明在构造子类时，会自动调用超类的构造函数，调用次序与派生次序相同。 ☁ 空指针引用所谓空指针引用，就是当引用变量未关联任何对象时，却引用其成员。 1234567891011121314151617181920public class Ch_4_7&#123; public static void main(String[] args)&#123; C c=new C(); //c.b=new B();c.b.a=new A(); //System.out.println(c.b.a.x); //此句运行时报错 C c1=new C(); &#125;&#125;class A &#123; public int x; &#125; class B &#123; public A a; &#125;class C &#123; public B b; &#125; ☁ 相等判断对象相等有两层含义：1）两对象实为同一对象，即对象的起始地址相同；2）两对象不是同一对象，但对象的特定属性值对应相等。 1234567891011121314151617/*本例表明：A的equals()与String的equals()功能不同； *前者作用等同于"=="； *后者是判断“字符串字面量的值”是否相同； **/public class Ch_4_8&#123; public static void main (String[] args) &#123; A a=new A(); A b=new A(); System.out.println(a==b); //输出false。因为a、b指向不同的对象 System.out.println(a.equals(b)); //输出false。因为a、b指向不同的对象 String s1=new String("abc"); String s2=new String("abc"); System.out.println(s1==s2); //输出false。因为s1、s2指向不同的对象 System.out.println(s1.equals(s2)); //输出true。因为s1和s2存储的字符串值相同 &#125; &#125;class A&#123;int x=5;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot笔记整理（四）]]></title>
    <url>%2F2020%2F03%2F03%2FSpringBoot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot笔记整理（一）SpringBoot笔记整理（二）SpringBoot笔记整理（三）SpringBoot笔记整理（四）1、SpringMVC自动配置以下是SpringBoot对SpringMVC nclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.自动配置了ViewResolver Support for serving static resources, including support for WebJars . registration of Converter, GenericConverter, and Formatter beans. Support for HttpMessageConverters . Automatic registration of MessageCodesResolver . Static index.html support. Custom Favicon support . Automatic use of a ConfigurableWebindingInitializer bean . If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own class of type WebMvcConfigurerAdapter but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping,RequestMappingHandlerAdapter, or ExceptionHandExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写一个配置类（@Configuration），是WebMvcConfigurationAdapter类型；不能标注@EnableWebMvc 既保留了所有的自动配置，也能用我们扩展的配置 12345678910//使用WebMvcConfigurer可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //浏览器发送/athomyit请求来到 success registry.addViewController("/athomyit").setViewName("success"); &#125;&#125; 原理：1）WebMvcAutoConfiguration是SpringMVC的自动配置类。2）在做其他自动配置时会导入：@Import（EnableWebMvcConfiguration.class） 12345678910111213141516@Configuration( proxyBeanMethods = false)public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123; //从容器中获取所有的WebMVCConfigurer @Autowired( required = false)public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125;&#125; 3）容器中所有的WebMvcConfigurer都会一起起作用 4）我们的配置类也会被调用效果：SpringMVC的自动配置和我们的拓展配置都会起作用 3、全面接管SpringMVCSpringBoot对SpringMVC的自动配置不需要了，所有的都是我们自己配置，所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot笔记整理（三）]]></title>
    <url>%2F2020%2F03%2F03%2FSpringBoot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot笔记整理（一）SpringBoot笔记整理（二）SpringBoot笔记整理（三）SpringBoot笔记整理（四）Web开发1、使用SpringBoot：1）创建SpringBoot应用，选中需要的模块2）SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来3）自己编写业务代码 自动配置原理 12xxxAutoConfiguration：帮我们给容器中自动配置组件xxxProperties：配置类来封装配置文件的内容 2、SpringBoot对静态资源的映射规则123456@ConfigurationProperties( prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); &#125; else &#123; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;"/webjars/**"&#125;).addResourceLocations(new String[]&#123;"classpath:/META-INF/resources/webjars/"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125;&#125;//配置欢迎页映射@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider)); return welcomePageHandlerMapping;&#125; 1）所有/webjars/**，都去classpath:/META-INF/resources//webjars/找资源webjars：以jar包的方式引入静态资源；https://www.webjars.org/ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 2）“/**”访问当前项目的任何资源（静态资源的文件夹） 12345&quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;,&quot;classpath:/public/&quot;&quot;/&quot;:当前项目的根路径 3）欢迎页：静态资源文件夹下的所有index.html页面，被”/“映射4）所有的/favicon.ico 都是在静态资源文件下找 3、模板引擎SpringBoot推荐的Thymeleaf：语法更简单，功能更强大3.1 引入Thymeleaf 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 3.2 Thymeleaf使用&amp;语法 12345678910111213@ConfigurationProperties( prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = "classpath:/templates/"; private String suffix = ".html"; private String mode = "HTML"; //只要把html页面放在classpath:/templates/，thymeleaf就能自动渲染 使用：3.2.1 导入thymeleaf的名称空间 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www/thymeleaf.org&quot;&gt; 3.2.2 使用thymeleaf语法 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www/thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;success&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为--&gt; &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;这里显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1）th:text：改变当前元素里面的文本内容 th：任意html属性，来替换原生属性的值2）表达式语法 1234567891011121314151617181920212223242526272829Simple expressions: Variable Expressions: $&#123;...&#125; Selection Variable Expressions: *&#123;...&#125; Message Expressions: #&#123;...&#125; Link URL Expressions: @&#123;...&#125; Fragment Expressions: ~&#123;...&#125;Literals Text literals: 'one text', 'Another one!',... Number literals: 0, 34, 3.0, 12.3,... Boolean literals: true, false Null literal: null Literal tokens: one, sometext, main,...Text operations: String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations: Binary operators: +, -, *, /, % Minus sign (unary operator): -Boolean operations: Binary operators: and, or Boolean negation (unary operator): !, notComparisons and equality: Comparators: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) Equality operators: ==, != (eq, ne) Conditional operators:If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot笔记整理（二）]]></title>
    <url>%2F2020%2F03%2F03%2FSpringBoot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot笔记整理（一）SpringBoot笔记整理（二）SpringBoot笔记整理（三）SpringBoot笔记整理（四）Spring Boot与日志（日志框架、日志配置）1、市面上的日志框架JUL、JCL、Jboss-logging、logback、log4、log4j2、slf4j……| | ||–|–||日志门面 |日志实现||JCL（Jakarta Commons Logging）、SLF4j（Simple Logging Facade for Java）、Jboss-logging| Log4j JUL（java.util.logging）、Log4j2、Logback左边选一个门面（抽象层）、右边选一个实现日志门面：SLF4J；日志实现：LogBack； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；SpringBoot选用 SLF4j和LogBack 2、SLF4j使用2.1 如何在系统中使用SLF4j开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法应该给系统里面导入slf4j的jar 和 LogBack的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架的配置文件 2.2 遗留问题a (slf4j + logback)：Spring （commons-logging）、Hibernate（jboss-logging）、MyBatis……统一日志记录，即使是和别的框架统一使用slf4j进行输出 如何让系统中所有的日志都统一到slf4j：1、将系统中其他日志框架先排除出去；2、用中间包来替换原有的日志框架；3、导入slf4j其他的实现 3、SpringBoot日志关系 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 总结：1）SpringBoot底层也是使用slf4j+logback的方式进行日志记录2）SpringBoot也把其他的日志都替换成了slf4j3）中间替换包4）如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除掉Spring框架用的是commons-logging；SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架的日志框架排除掉 4、日志使用4.1 默认配置SpringBoot默认帮我们配置好了日志 1234567891011121314151617 //记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test void contextLoads() &#123;// System.out.println(); //日志的级别：由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别：日志就只会在这个级别及以后的高级别生效 logger.trace("这是trace日志"); logger.debug("这是debug日志"); //SpringBoot默认使用的是info级别的,没有指定级别的就用SpringBoot默认规定的级别 root级别 logger.info("这是info日志"); logger.warn("这是warn日志"); logger.error("这是error日志"); &#125; 123456789日志输出格式“ %d：表示日期时间 %thread：表示线程名 %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125;：表示logger名字最长50个字符，否则按照句号分割 %msg：日志消息 %n：换行符 %d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.homyit = trace#不指定路径在当前项目下生成springboot.log日志#可以指定完整的路径#logging.file = D:/springboot.log#logging.file = springboot.log#在当前磁盘的根路径下创建spring文件夹和里面的log文件夹：使用spring.log作为默认文件#logging.path = /spring/log#在控制台输出的日志格式logging.pattern.console = %d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#指定问价中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; ===[%thread]=== %-5level=== %logger&#123;50&#125; -==== %msg%n 4.2 指定配置给类路径下放上每个日志框架自己的配置文件即可，SpringBoot就不使用默认配置了logback.xml：直接就被日志框架识别了；logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 123456789101112&lt;springProfile name=&quot;staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt;&lt;springProfile name=&quot;dev | staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;&lt;/springProfile&gt;&lt;springProfile name=&quot;!production&quot;&gt; &lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;&lt;/springProfile&gt; 否则会报错 4.3 切换日志]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot笔记整理（一）]]></title>
    <url>%2F2020%2F03%2F03%2FSpringBoot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot笔记整理（一）SpringBoot笔记整理（二）SpringBoot笔记整理（三）SpringBoot笔记整理（四）1、使用Spring Initializer快速创建Springboot项目默认生成的Spring Boot项目； 主程序已经生成了，我们只需要我们自己的逻辑 resources文件夹中目录结构static：保存所有的静态资源；js css images;templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；application.properties：Spring Boot应用的配置文件； 2、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language)YAML A Markup Language：是一个标记语言YAML isn’t Markup Language：不是一个标记语言标记语言：以前的配置文件；大多数都使用的是xxxx.xml文件；YAML：以数据为中心，比json、xml等更适合做配置文件YAML：配置例子 12server: port:8080 XML： 123&lt;server&gt; &lt;port&gt;8080&lt;/port&gt;&lt;/server&gt; 3、YAML语法 基本语法 K:(空格)V：表示一对键值对（空格必须有）；以空格的缩进来控制层级关系；只要是左对齐的一列数据都是同一个层级的 123server: port:8080 path:/hello 属性和值也是大小写敏感 值的写法 字面量：普通的值（数字、字符串、布尔）k:v：字面直接来写 字符串默认不用加上单引号或者双引号；&quot;&quot;：双引号：不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思name：”zhangsan \n lisi”：输出=》zhangsan 换行 lisi&#39;&#39;：单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串数据name：’zhangsan \n lisi’：输出=》zhangsan \n lisi对象、Map（属性和值）（键值对）：k:v：在下一行来写对象的属性和值的关系，注意缩进对象还是k:v的方式 123friends: lastName：zhangsan age：20 行内写法： 1friends:&#123;lastName:zhangsan, age:18&#125; 数组（List、Set）： 用-值表示数组中的一个元素 1234pets： - cat - dog - pig 行内写法 1pets:[cat,dog,pig] 4、配置文件值注入配置文件 123456789101112person: lastName: zhangsan age: 18 boss: false birth: 2019/11/25 maps: &#123;k1: v1,k2: v2&#125; lists: - list - zhaoliu dog: name: 小狗 age: 12 javaBean: 123456789101112@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 4.1 @ConfigurationProperties获取值和@Value比较 什么是SpEL？Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 语法类似于 EL表达式：SpEL 使用 #{…}作为定界符，所有在大框号中的字符都将被认为是 SpEL。SpEL 为 bean 的属性进行动态赋值提供了便利 通过 SpEL 可以实现：通过 bean 的 id 对 bean 进行引用 调用方法以及引用对象中的属性计算表达式的值正则表达式的匹配 什么是JSR303?JSR-303 是 JAVA EE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是Hibernate Validator。此实现与 Hibernate ORM 没有任何关系。 JSR 303 用于对 Java Bean 中的字段的值进行验证。Spring MVC 3.x 之中也大力支持 JSR-303，可以在控制器中对表单提交的数据方便地验证。注:可以使用注解的方式进行验证| | | ||–|–|–| ||@ConfigurationProperties |@Value||功能 |批量注入配置文件中的属性| 一个个指定||松散绑定（松散语法）| 支持 |不支持||SpEL |不支|持 支持||JSR303数据校验| 支持| 不支持||复杂类型封装 |支持 |不支持|无论是配置文件yml还是properties他们都能获取到值如果说，我们只是在某个业务逻辑中需要获取一下配置文件的某项值，使用@Value如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties 4.2 配置文件注入值数据校验 12345678910111213141516@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123;// @Value("$&#123;person.last-name&#125;") @Email private String lastName;// @Value("#&#123;11*2&#125;") private Integer age;// @Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4.3 @PropertySource&amp;@ImportResource@PropertySource:加载指定的配置文件 12345678910111213141516171819@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class = "Person"&gt; * &lt;property name = "lastName" value = "字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;/bean&gt; */// @Value("$&#123;person.last-name&#125;")// @Email private String lastName;// @Value("#&#123;11*2&#125;") private Integer age;// @Value("true") private Boolean boss; @ImportResource:导入Spring的配置文件，让配置文件里面的内容生效spring boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别想让spring的配置文件生效，加载进来，@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloService&quot; class=&quot;com.homyit.springboot.service.HelloService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式：推荐使用全注解的方式1、配置类========Spring配置文件2、使用@Bean给容器添加组件 1234567891011@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService()&#123; System.out.println("配置类@Bean给容器中添加组件了。。。。"); return new HelloService(); &#125;&#125; 4.4 配置文件占位符1、随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536])&#125; 2、占位符获取之前配置的值，如果没有可以使用：指定默认值 1234567891011person.last-name=张三$&#123;random.uuid&#125;#person.age=18person.age=$&#123;random.int&#125;person.birth=2019/11/25person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,c#person.dog.name=dogperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 4.5 Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml默认使用application.properties的配置 2、yml支持多文档块方式 123456789101112131415161718server: port: 8080spring: profiles: active: dev---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod 3、激活指定profile3.1 在配置文件中指定 1spring.profiles.active = dev 3.2 命令行 1--spring.profile.active = dev 可以直接在测试的时候，配置传入命令行参数3.3 虚拟机参数 1-Dspring.profile.active = dev 4.6、配置文件加载位置 spring boot 启动会扫描以下位置的application.properties或者application.ym文件作为Spring Boot 的默认配置文件 file: ./config/ file: ./ classpath: /以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容。互补配置 我们也可以通过配置spring.config.location来改变默认的配置文件位置。 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置。]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows系统、Linux系统 和 Mac OS操作系统 历史由来 与 区别？]]></title>
    <url>%2F2020%2F03%2F02%2F(%E8%BD%AC)Windows%E7%B3%BB%E7%BB%9F%E3%80%81Linux%E7%B3%BB%E7%BB%9F%20%E5%92%8C%20Mac%20OS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E5%8E%86%E5%8F%B2%E7%94%B1%E6%9D%A5%20%E4%B8%8E%20%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[目录 1 UNIX 由来 2 Linux 由来 3 Windows与Linux的主要区别 4 关于Linux的一些疑惑 参考资料 目前常见的三大操作系统：Windows系统、Linux系统 和 Mac OS操作系统。 首先，不管是Windows操作系统、Linux系统还是苹果的Mac OS操作系统，甚至包括操作系统的鼻祖UNIX操作系统，最早都是用C语言编写的。 UNIX 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，Mac OS诞生的时间和Linux时间差不多。可以说 UNIX 是操作系统中的"老大哥"，后来的 Windows , Linux 和Mac OS都参考了 UNIX。 &nbsp; 1 UNIX 由来 实际上UNIX操作系统和C语言都是由贝尔实验室的汤普森(Ken Thompson)和丹尼斯·里奇(Dennis M. Ritchie)于1971年先后改造发明的，如果说真正的操作系统，世界上只有一个，那就是UNIX操作系统。 下图是肯•汤普森 与 丹尼斯•里奇的合影，膜拜一下。(这么多胡子，天才都是不修边幅的，大神就是这么随意) UNIX的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。 可惜，由于 Multics 工程计划所追求的目标太庞大、太复杂，以至于它的开发人员都不知道要做成什么样子，最终以失败收场。 以肯•汤普森为首的贝尔实验室研究人员吸取了 Multics 工程计划失败的经验教训，于 1969 年实现了一种分时操作系统的雏形，1970 年该系统正式取名为 UNIX。 想一下英文中的前缀 Multi 和 Uni，就明白了 UNIX 的隐意。Multi 是大的意思，大而且繁；而 Uni 是小的意思，小而且巧。这是 UNIX 开发者的设计初衷，这个理念一直影响至今。 有意思的是，肯•汤普森当年开发 UNIX 的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登陆。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，UNIX 诞生了。自 1970 年后，UNIX 系统在贝尔实验室内部的程序员之间逐渐流行起来。1971-1972 年，肯•汤普森的同事丹尼斯•里奇发明了传说中的C语言，这是一种适合编写系统软件的高级语言，它的诞生是 UNIX 系统发展过程中的一个重要里程碑，它宣告了在操作系统的开发中，汇编语言不再是主宰。到了 1973 年，UNIX 系统的绝大部分源代码都用C语言进行了重写，这为提高 UNIX 系统的可移植性打下了基础（之前操作系统多采用汇编语言，对硬件依赖性强），也为提高系统软件的开发效率创造了条件。可以说，UNIX 系统与C语言是一对孪生兄弟，具有密不可分的关系。 20 世纪 70 年代初，计算机界还有一项伟大的发明——TCP/IP 协议，这是当年美国国防部接手 ARPAnet 后所开发的网络协议。美国国防部把 TCP/IP 协议与 UNIX 系统、C语言捆绑在一起，由 AT&amp;T 发行给美国各个大学非商业的许可证，这为 UNIX 系统、C语言、TCP/IP 协议的发展拉开了序幕，它们分别在操作系统、编程语言、网络协议这三个领域影响至今。肯•汤普森和丹尼斯•里奇因在计算机领域做出的杰出贡献，于 1983 年获得了计算机科学的最高奖——图灵奖 (实至名归)。 &nbsp; 下图是从UNIX衍生出来，目前常见的三大操作系统：Windows系统、Linux系统和Mac OS操作系统。 &nbsp; 首先这三个系统设计上有本质的区别。最大的区别在于Windows是一个成熟的商业操作系统，拿过来就能用，而Linux不同，它是指一个内核，苹果操作系统是UNIX的一个衍生品。 &nbsp; &nbsp; 操作系统 &nbsp; &nbsp; &nbsp; 形态 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;说明 &nbsp; Windows &nbsp; &nbsp;商业产品 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 微软公司1983年开始推出的一套商业操作系统。 &nbsp; &nbsp; &nbsp;Linux &nbsp; &nbsp;一个内核 &nbsp; &nbsp;芬兰的李纳斯·托沃兹( Linus Torvalds) 1991 年上大学时发布的, 他对当时流行的教学系统Minix (Unix的一个版本)的很多特点很不满意, 于是决定自己写一个合乎自己要求的操作系统, 并把这个内核放到了Internet 上, 供大家修改。后来经过众多世界顶尖的软件工程师的不断修改和完善。 &nbsp; Mac OS &nbsp; &nbsp; 专属系统 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 苹果公司基于FreeBSD操作系统的改造。 通过上表可以看出，其实Windows和Linux在哲学设计上是有本质区别的。Windows操作系统倾向于将更多的功能集成到操作系统内部，并将程序与内核相结合；而Linux不同于Windows，它的内核空间与用户空间有明显的界限。根据设计架构的不同，两者都可以使操作系统更加安全。而苹果操作系统只不过是UNIX的一个细小分支而已。 Linux 只是指操作系统的核心, 并没有各种应用程序, 如网络工具、多媒体软件等。因此现在市场上有很多种Linux Kernel 为核心再集成搭配各式各样的系统程序或应用工具程序组成的一套完整的操作系统。 Linux是可以任意包装自由配置的东西。任何一个人，一家公司 都可以按照自己的想法，比如加一点功能，加中文支持，作一个Linux出来。这些 Linux虽然核心部分都一样，但是他们所带的各种软件，缺省的配置都不一样。 &nbsp; Linux 分为 内核版本 和 发行版本。 Linux 内核版本就是Linux的核心版本 由官网 www.kernel.org 发布，如下图所示： &nbsp; Linux 发行版本就是各个公司的在Linux核心版本上就行包装，添加想要的内容，这就衍生出非常多的发行版本，如下图所示。譬如的redhat, CentOS, 红旗、Ubuntu等，这些都是的Linux衍生操作系统。 话说回来关于个人办公要使用什么操作系统、个人做图要用什么样的操作系统、建设网站的服务器要用什么系统，其实在行业中都有大体的规则。譬如个人PC娱乐还是Windows系统比较合适、专业做图像让是MAC系统了，建设网站大家服务器建议你还是Linux了！下面简单介绍Linux 由来，毕竟是开源的。 &nbsp; 2 Linux 由来 Linux 内核最初是由 李纳斯•托瓦兹 (Linus Torvalds) 在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版 UNIX 操作系统 Minix 太难用了，于是决定自己开发一个操作系统。第 1 版本于 1991 年 9 月发布，当时仅有 10 000 行代码。下图是李纳斯•托瓦兹（Linus Torvalds）图片，膜拜一下大神。 李纳斯•托瓦兹 (Linus Torvalds) 没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。 据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹 (Linus Torvalds)和后来陆续加入的众多 Linux 好者共同开发完成的。 李纳斯•托瓦兹 (Linus Torvalds)无疑是这个世界上最伟大的程序员之一，何况，他还搞出了全世界最大的程序员交友社区 GitHub (开源代码库及版本控制系统）。 关于 Linux Logo 的由来是一个很有意思的话题，它是一只企鹅，如下图所示，为什么选择企鹅，而不是选择狮子、老虎或者小白兔？ 当然有很多种说法，其中有一种说法：企鹅是南极洲的标志性动物，根据国际公约，南极洲为全人类共同所有，不属于世界上的任何国家，可国家都无权将南极洲纳入其版图。Linux 选择企鹅图案作为 Logo，其含义是：开放源代码的 Linux 为全人类共同所有，可公司无权将其私有。当然我比较信服这个说法，有种造福人类的使命感。 &nbsp; 3 Windows与Linux的主要区别 1、免费与收费 Linux都是免费的，Windows是付费的，只有购买Windows系统的电脑，就已经向微软付费了。 &nbsp; 2、软件与支持 Windows下可以运行绝大部分软件、玩99.999％的游戏、硬件厂商近乎100%的支持。Linux下可直接运行的软件数量和Win下比起来就是1和99的区别，而且目前选择Linux的人基本不会考虑玩游戏（虽然有能在Linux下运行的游戏，但实在太少。），同时Linux正期待更多硬件厂商的支持。 &nbsp; 3、安全性 很多人说Linux安全性高，仁者见仁智者见智了。其实我觉得这个根本没必要讨论，当Linux普及程度达到现在Windows的程度，那么Linux的漏洞、病毒、木马、后门什么的绝对会如雨后春笋般纷纷冒出，虽不敢说比Windows严重，但绝对不会比win少，说白了就是因为现在Linux的用户量太少，受关注也太少，做病毒者当然希望自己的作品流传越广越好（现在的病毒更倾向于获取非法利益，比如账号密码什么的），所以，病毒目前不会考虑少数派的Linuxer。 世上没有攻不破的系统、没有穿不透的防火墙，一件事你做不到，只能说明你水平不够，这里适用一句话：道高一尺，魔高一丈。 但就目前来说，如果你对Windows下层出不穷的病毒、木马、垃圾感到极度厌恶，那的确可以尝试一下Linux。 &nbsp; 4、开源 开源就是指对外部开放软件源代码。 如果一个小程序员写了个软件，里面有他独创的新技术，他想靠这个赚钱，甚至还为此申请了专利，这时某些团体以安全为由，要求他公开源代码（这样就可以仿制了嘛。），并且最好免费给大家使用，身边一群眼红程序员赚钱的人也在跟着起哄。一个独立商业团体的合法知识产权、资产权益遭受政治强权的公开侵占、迫害，这就是微软在欧洲所面临的开源问题（至于微软是否是奸商，这是另一码事，并不能成为打砸抢、吃大户的理由） 开源与否，软件厂商有选择的权力；是否购买使用这个产品，这才是用户的权利。 其实想深一点，如果Linux不开源，它还能有现在这个市场吗？因为很多人就是冲着开源才使用Linux的。 &nbsp; 5、使用习惯 一样的地方：桌面、图标、鼠标点击，有区别吗？不一样的是，Windows放弃了dos的字符模式，主攻图形界面，让桌面系统更易用。Linux字符模式运行的更好，图形界面还只是附带品，可有可无。根据他们的上市时间来看，只能说Linux把Windows扔掉的东西又捡回来并且发扬光大。 &nbsp; 6、技术支持 如果你不熟悉或从来没接触过电脑： 学Windows －－那身边随便一个上过网的人都可以指点你两下。学Linux－－难，需要买书或上网查阅资料。 如果你熟悉电脑和上网，那Windows和Linux其实没什么区别，网上都有海量的资料给你查。但是找修Windows电脑的人远比找一个修Linux电脑的人容易得多. Windows平台:数量和质量的优势，不过大部分为收费软件；由微软官方提供重要支持和服务 Linux平台：大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持 &nbsp; 4 关于Linux的一些疑惑 作为初学者，就是很难理解Linux有什么好，上手比较难，需要慢慢适应，下面就是之前看到的一些疑惑，记录一下。 1 Windows有完善的图形界面，而Linux为什么要学命令行。 首先，命令行绝对要比图形界面先进的多。命令行是程序员的第一界面，而图形界面是普通用户的第一界面。也许很多人会有不同意见，其实我们再向前想一步，就很清楚了。 命令行的下一步演化是什么? 很简单就是语音控制，就是把人类自然语言转化为命令 图形界面的下一步演化是什么? 是姿势控制。从目前的Windows系统来说一共只有3种姿势， 单击，双击，拖放。而更先进的IPad有拨动，画圈等。 姿势控制很简单，便于用户上手，语音控制很复杂，但是控制精度很高。作为程序员我们要求电脑完成的工作要比普通用户复杂的多，所以使用命令行会非常高效。退一步讲，图形界面本质也是命令行，只不过将姿势翻译成命令执行而已。程序员编程的代码也都是“命令行”，一条一条的指令而已。 总之，只要能打破对Linux命令行的恐惧感，接下来的事就会非常容易了。这个命令行绝对不是你简单想像中的命令行，它是非常智能化的。 &nbsp; 2 Linux有那么多目录，那么多命令，怎么记得住呢? 首先，Linux目录是Linux系统最灵魂的东西，所有的硬件都可以被抽象为文件，从而实现网络化。(Internet只不过是Unix/Linux的进一步的演化而已)。所以只要掌握了Linux目录的规律，在理解的基础上记忆就可以容易的多。另外Linux的命令行有智能化功能，可以让你少打95%以上的字符来完成命令。 绝非你所想象的傻乎乎的敲一大堆命令，那些用Linux大牛都是绝顶聪明的人，怎么可能让自己辛苦呢? &nbsp; 3 Windows有注册表，为什么Linux没有注册表？ 注册表是Windows核心组件，对整个系统进行配置。Linux是以整个文件系统作为"注册表“，Windows注册表的树形结构，可以粗略的对应Linux文件系统的树形结构。 Linux的配置文件就相当于注册表的键，或者说Linux采用是的分布式的注册表。 那么Linux为什么要这样设计呢?因为Linux是所谓的网络操作系统，所以单台电脑不是Linux的界限，如果是多台电脑组成的系统，那么分布式的管理就有着巨大的优势。例如：一个包含配置文件的磁盘的损害不会让整个系统瘫痪，而可能只是让部分功能失效。 &nbsp; &nbsp; 关于 Linux初学资料，可下载： 鸟哥的Linux私房菜 和&nbsp;&nbsp;Unix-Linux编程实践教程&nbsp;pdf文件(带书签)。 &nbsp; &nbsp; 参考资料 [1] https://www.gonet.com.cn/index.php?webduirshow-166 [2] https://www.Linuxprobe.com/Windows-Linux-distinction.html [3] https://www.cnblogs.com/supermeimei/p/5133610.html [4] http://cn.linux.vbird.org/linux_basic/0110whatislinux.php [5] http://c.biancheng.net/view/707.html &nbsp;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下生成指定大小文件（命令+Java程序）]]></title>
    <url>%2F2020%2F03%2F01%2FLinux%E4%B8%8B%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6%EF%BC%88%E5%91%BD%E4%BB%A4%2BJava%E7%A8%8B%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、dd命令of：fileName为文件名称，例如test.txt ；bs：设置一次复制的大小，例如1M；count：设置复制次数，例如100；1dd if=/dev/zero of=&lt;fileName&gt; bs=&lt;一次复制的大小&gt; count=&lt;复制的次数&gt;例如：1dd if=/dev/zero of=1.txt bs=1M count=100 2、Java快速生成两种方式都可以生成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.jxnu.test;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * @program: CreateFile * @author: xiaojing * @create: 2020-03-01-09-46 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file = new File("test.txt"); long length = 1024*1024*15; //createFixLengthFile(file, length); createFile(file, length); &#125; /** * 第一种方法 * @param file * @param length * @throws IOException */ public static void createFixLengthFile(File file, long length) throws IOException &#123; FileOutputStream fos = null; FileChannel output = null; try &#123; fos = new FileOutputStream(file); output = fos.getChannel(); output.write(ByteBuffer.allocate(1), length - 1); &#125; finally &#123; try &#123; if (output != null) &#123; output.close(); &#125; if (fos != null) &#123; fos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * * 第二种方法 * @param file * @param length * @throws IOException */ private static void createFile(File file, long length) throws IOException &#123; RandomAccessFile r = null; try &#123; r = new RandomAccessFile(file, "rw"); r.setLength(length); &#125; finally &#123; if (r != null) &#123; r.close(); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket实现客户端服务端之间的通信]]></title>
    <url>%2F2020%2F02%2F28%2FJava%20Socket%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Java Socket Java Socket编程用于在不同JRE上运行的应用程序之间的通信。 Java Socket编程可以是面向连接的或无连接的。 Socket和ServerSocket类用于面向连接的套接字编程，DatagramSocket和DatagramPacket类用于无连接套接字编程。 此Demo将进行单向客户端和服务器通信。客户端将消息发送到服务器，服务器读取消息并打印。在这里，使用了两个类：Socket和ServerSocket。Socket类用于通信客户端和服务器。通过此类，我们可以读写消息。ServerSocket类在服务器端使用。ServerSocket类的accept（）方法将阻止控制台，直到客户端连接为止。客户端成功连接后，它将在服务器端返回Socket的实例。 Socket class套接字只是机器之间通信的端点。Socket类可用于创建套接字。 重要方法| 方法 |描述 ||–|–|| 1）public InputStream getInputStream() | 返回与此socket连接的InputStream。|| 2）public OutputStream getOutputStream() |返回与此socket连接的OutputStream。||3）public synchronized void close()|关闭这个socket ServerSocket classServerSocket类可用于创建服务器套接字。该对象用于与客户端建立通信。 重要方法|方法|描述 ||–|–|| 1) public Socket accept() | 返回socket，并在服务器和客户端之间建立连接。 ||2) public synchronized void close() |关闭服务器socket| 具体实现 MyServer.java 1234567891011121314import java.io.*; import java.net.*; public class MyServer &#123; public static void main(String[] args)&#123; try&#123; ServerSocket ss=new ServerSocket(6666); Socket s=ss.accept();//建立连接 DataInputStream dis=new DataInputStream(s.getInputStream()); String str=(String)dis.readUTF(); System.out.println("message= "+str); ss.close(); &#125;catch(Exception e)&#123;System.out.println(e);&#125; &#125; &#125; MyClient.java 1234567891011121314import java.io.*; import java.net.*; public class MyClient &#123; public static void main(String[] args) &#123; try&#123; Socket s=new Socket("localhost",6666); DataOutputStream dout=new DataOutputStream(s.getOutputStream()); dout.writeUTF("Hello Server"); dout.flush(); dout.close(); s.close(); &#125;catch(Exception e)&#123;System.out.println(e);&#125; &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下Java连接数据库出现 Access denied for user 'root'@'localhost'错误]]></title>
    <url>%2F2020%2F02%2F28%2FLinux%E4%B8%8BJava%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BA%E7%8E%B0%20Access%20denied%20for%20user%20'root'%40'localhost'%20(using%20password_%20YES)%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[一、问题描述centos 7 终端键入 mysql -u root -p 输入密码后可成功访问数据库，但使用IDEA编写Java代码实现数据库连接时却出现Access denied for user ‘root’@’localhost’ (using password: YES) 错误。二、解决方法 在刚安装mysql时，系统会默认提供4种host下得root用户，如下图所示：user中有多条root记录时，mysql会优先判断是否使用了绑定的ip，所以将localhost设置成对应的Ip 就可以。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware下主机与虚拟机剪切板独立，无法直接复制粘贴]]></title>
    <url>%2F2020%2F02%2F27%2FVMware%E4%B8%8B%E4%B8%BB%E6%9C%BA%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%89%AA%E5%88%87%E6%9D%BF%E7%8B%AC%E7%AB%8B%EF%BC%8C%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%2F</url>
    <content type="text"><![CDATA[看了很多博客都说需要重新安装vmware tools，但我使用的是这种方法，亲测有效！！！ 关闭虚拟机 点击编辑虚拟机设置-&gt;选项 选择客户机隔离，勾选上启动复制粘贴即可（如果之前就已经勾选上但失效的情况再重新勾选一次即可）]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.7安装MySQL5.6并配置环境变量（详细版）]]></title>
    <url>%2F2020%2F02%2F27%2FCentOS7.7%E5%AE%89%E8%A3%85MySQL5.6%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[i. tar包下载 官网下载 https://dev.mysql.com/downloads/mysql/ 网盘获取链接：https://pan.baidu.com/s/1DpULc0qQ4hqx6HWUwRilpw提取码：tgdv ii. 安装所需环境1yum -y install make gcc-c++ cmake bison-devel ncurses-devel iii. 解压tar包，进入mysql-5.6.47文件夹后编译安装 123456tar xvf mysql-5.6.47.tar.gz #解压tar包cd mysql-5.6.47 #进入解压后的mysql-5.6.47文件夹#编译cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci make &amp;&amp; make install iv. 设置权限，执行初始化脚本。 12345678910#检查系统是否已经有mysql用户，如果没有则创建cat /etc/passwd | grep mysql cat /etc/group | grep mysqlchown -R mysql:mysql /usr/local/mysql # 修改/usr/local/mysql权限cd /usr/local/mysql # 切换目录chown -R mysql:mysql . # 将权限赋予给mysqlscripts/mysql_install_db --user=mysql # 执行初始化脚本chown -R root:mysql . #将权限设置给root用户chown -R mysql:mysql ./data #数据库存放目录设置成mysql用户mysql组chmod -R ug+rwx . #赋予读写执行权限，仅给mysql用户权限 v. 修改my.cnf配置 123456789101112131415#将mysql的配置文件拷贝到/etccp support-files/my-default.cnf /etc/my.cnf #修改my.cnf配置，添加以下内容 [mysql]default-character-set=utf8 # 设置mysql客户端默认字符集[mysqld]skip-name-resolveport = 3306 #设置3306端口basedir=/usr/local/mysql # 设置mysql的安装目录datadir=/usr/local/mysql/data # 设置mysql数据库的数据的存放目录max_connections=200 # 允许最大连接数character-set-server=utf8 # 设置默认字符集default-storage-engine=INNODB # 创建新表时将使用的默认存储引擎lower_case_table_names=1max_allowed_packet=16M vi. 启停mysql 12345# 将mysql的启动服务添加到系统服务中cp support-files/mysql.server /etc/init.d/mysql service mysql start #启动服务service mysql stop #停止服务service mysql restart #重启服务 vii. 修改root用户密码 12chkconfig --add mysql./bin/mysqladmin -u root password viii. 设置mysql环境变量 1234vim /etv/profile #修改文件# 添加以下内容，重启操作系统即可export MYSQL_HOME=/usr/local/mysqlexport PATH=$MYSQL_HOME/bin:$PATH 现在通过mysql -u root -p可以操作数据库啦！]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 /etc/profile 添加环境变量重开终端后不生效]]></title>
    <url>%2F2020%2F02%2F26%2FCentOS7%20_etc_profile%20%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%87%8D%E5%BC%80%E7%BB%88%E7%AB%AF%E5%90%8E%E4%B8%8D%E7%94%9F%E6%95%88%2F</url>
    <content type="text"><![CDATA[排查步骤如下： 查看/etc/profile里面的环境变量是否填写正确。 需要重启操作系统（很重要！！！） 将环境变量写入/etc/bashrc文件]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算与分布式系统课程学习笔记（二）——Linux基本命令的使用与熟悉]]></title>
    <url>%2F2020%2F02%2F22%2F%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[（1） jps 【显示当前系统的java进程情况，及其id号】| | ||–|–||-q | 只显示pid，不显示class名称,jar文件名和传递给main方法的参数||-m | 输出传递给main方法的参数||-l | 输出主类的完整包名或者jar文件完整路径名||-v | 输出传递给JVM的参数| 编写一个JSPDemo.java程序进行测试：（2） awk 【把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理】【使用方法】awk &#39;BEGIN{ commands } pattern{ commands } END{ commands }&#39;内置变量| | ||–|–||$0 | 整条记录|| $1~ $n|当前记录的第n个字段||FS | 输入域分隔符 默认是空格或Tab||NF |浏览记录中的域个数，就是有多少列||NR| 已经读出的记录数，就是行号||FNR |浏览文件的记录数||RS |输入记录分隔符， 默认为换行符||OFS |输出域分隔符， 默认为空格||ORS |输出记录分隔符，默认为换行符||FILENAME| 当前输入文件的名字|（3） cat【一次显示整个文件；从键盘创建一个文件；将几个文件合并为一个文件】 【使用方法】 $ cat filename；$ cat &gt; filename; $cat file1 file2 &gt; file -n 或 –number 由 1 开始对所有输出的行数编号 -b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算与分布式系统课程学习笔记（一）——云计算简介]]></title>
    <url>%2F2020%2F02%2F20%2F%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E4%BA%91%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[大数据对于系统架构的需求显式的需求 海量计算和存储 快速计算 隐式的需求 数据的快速传输 灵活性 低成本 如何实现这些需求？ 并行化（并行化的理念存在于计算机方方面面） 并行请求（分配给多个计算机） 并行线程（分配给多个处理器核心） 并行指令（同一时刻有多于一条指令） 并行数据（同一时刻有多于1个数据项 ） 硬件描述（同一时刻使用所有门电路） 规模经济（极端规模的并行化：仓库规模的计算机 WSC） 主要部件 —— 供电、制冷、建筑、网络、安全、存储、计算 优势 —— 规模经济、提高使用率 挑战 —— 能耗PUE、运维 WSC是用网络连接起来的计算和存储设备WSC的特点：1、使用相对同质的硬件和系统软件平台2、共享相同的系统管理3、大多数应用程序、中间件、系统软件都是自主开发，而传统数据中心则由第三方软件主导4、WSC运行相对小数目的超大型程序（或服务）5、通用的资源管理架构增强了部署的灵活性 虚拟化（抽象） 云计算的商业模式概述 —— 云计算的定义云计算 Cloud computing 既指作为服务通过互联网提供的应用程序（SaaS模式），又指提供这些服务的，位于数据中心的硬件和系统软件（公用计算）云：数据中心硬件与软件公有云：用即付即用的模式，开放给大众使用的云私有云：一个企业或组织内部的数据中心公用计算：给人以无限资源的错觉 —— 云计算商业模式的三大特点 按需服务 资源池 可测量的服务 —— 云计算发展的市场条件 大规模互联网应用（社交网络、多媒体）1、规模经济2、需求增长促进数据中心建设增长3、无法预测的应用增长速度Zynga，Netflix 大数据应用1、日志分析2、机器学习应用 云计算的价值云计算的分类 指令集虚拟机（Amazon EC2， 3Tera） 运行时系统虚拟机（Microsoft Azure） 框架型虚拟机（Goole AppEngine，Force.com） 折衷：灵活性/可移植性 为什么要虚拟化 资源池 聚合：将多个资源结合起来 合一：例如存储 动态：快速分配（虚拟机） 隔离：保护消费者隔离其他租客 ，例如虚拟专用网（VPN）便于管理：测试、机动性 云计算的核心思想 性能：并行化 经济性：规模化、公有云 可管理：虚拟化 从云计算到大数据 虚拟化提供了硬件资源的抽象 用户看到的接口（虚拟）计算节点（虚拟）网络（虚拟）存储 仍然是许多独立的设备：需要分布式系统编程 如何提供一个易于编程的“单一系统”感觉 分布式存储、计算框架]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware安装CentOS7超详细版]]></title>
    <url>%2F2020%2F02%2F11%2FVMware%E5%AE%89%E8%A3%85CentOS7%E8%B6%85%E8%AF%A6%E7%BB%86%E7%89%88%2F</url>
    <content type="text"><![CDATA[写在前面云计算与分布式这门课程的老师让我们使用vmware安装好centos7.6并配置好Java编译环境，刚好复习一波，下面是详细的安装过程。准备工作 VMware，我用的是VMware Workstation Pro 15，下载与安装方法就不提了毕竟重点在后头。 CentOS7镜像文件，由于7.6版本已经停更，这里我用的是7.7版本。下载地址 http://isoredirect.centos.org/centos/7/isos/x86_64习惯性选择阿里的镜像，点击下载即可。安装过程 打开vmware，点击创建新的虚拟机选择自定义配置，点击下一步这里直接默认下一步选择稍后安装操作系统，点击下一步客户机操作系统选择Linux，版本选择CentOS 7 64位，点击下一步虚拟机名称可以自定义，这里建议以见名知意为原则，位置尽量放在C盘外的其他盘符，这里我选择的是D盘。处理器数量和每个处理器的内核数可根据自己电脑配置进行选择。这里默认都选择1。同样的，虚拟机内存也依据自己电脑配置进行选择，由于我的电脑是8GB，所以这里我选2GB。网络连接选择NAT后两项默认推荐，点击下一步。)点击创建新虚拟磁盘最大磁盘大小按需分配，我给了20GB，选择将虚拟磁盘拆分成多个文件。默认点击下一步可以看到CentOS7已经添加进去了右键CentOS7,点击设置进入设置页面，点击CD/DVD,使用ISO映像文件，选择之前下载的文件即可。 开启虚拟机，见到如下页面，选择Install CentOS Linux 7,直接Enter滑动右侧滚动条选择中文=》简体中文，英文好的同学当然可以选择英文这里配置一些基本信息1、点击安装源，进入之后直接选择done，警告符号随即消失。2、软件选择：GNOME桌面，一个友好的图形化界面3、根据需要禁用Kdump4、自动分区，一般化为4个分区，如图所示 ))完成后点击开始安装安装过程中会弹出用户设置界面，填好并记住密码。)安装完成后点击重启，看到如下界面点击接受许可设置一下网络 点击完成配置现在可以使用之前创建的用户进行登录了登录成功后可看到图形化界面上网 开启windows下的VMnet8cmd窗口ping出主机ip地址打开有线设置网络=》开启，点击设置图标选择自动连接)打开终端，使用ifconfig命令获取ip地址在终端ping下windows 中VMnet8的IP地址，若出现下图所示信息，则表示linux的ip地址设置成功。此时，若windows能上网，则linux也能上网打开火狐浏览器，上网成功！]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之Web应用]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BWeb%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、web与HTTPworld Wide Web：网页网页互相链接网页包含多个对象：对象： HTML文件、JPEG图片、视频文件、动态脚本等基本HTML文件： 包含对其他对象引用的链接对象的寻址：URL（Uniform Resource Locator）：统一资源定位器Scheme：//host:port/path 2、HTTP协议概述万维网应用遵循超文本协议（HyperText Transfer Protocol）C/S结构客户——Browser：请求、接收、展示Web对象服务器——Web Server：响应客户的请求，发送对象HTTP版本1.0：RFC 19451.1：RFC 2068使用TCP传输服务：服务器在80端口等待客户的请求浏览器发起服务器的TCP连接（创建套接字Socket）服务器接受来自浏览器的TCP连接浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息关闭TCP连接 无状态：服务器不维护任何有关客户端过去所发请求的信息有协议的协议更复杂：需维护状态（历史信息）如果客户或服务器失效，会产生状态的不一致，解决这种不一致代价高 HTTP连接的两种类型1、 非持久性连接每个TCP连接最多允许传输一个对象HTTP1.0版本使用非持久性连接问题：1）每个对象需要2个RTT2）操作系统需要为每个TCP连接开销资源 2、 持久性连接每个TCP连接允许传输多个对象HTTP1.1版本默认使用持久性连接发送响应后，服务器保持TCP连接的打开后续的HTTP消息可以通过这个连接发送 HTTP请求消息请求消息：ASCII 人直接可读响应消息 Cookie技术某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密） Cookie的组件HTTP响应消息的cookie头部行HTTP请求消息的cookie头部行保存在客户端主机上的cookie文件，由浏览器管理Web服务器端的后台数据库原理作用：身份认证、购物车、推荐等 Web缓存/代理服务功能：在不访问服务器的前提下满足客户端的HTTP请求Web缓存/代理服务器：1、用户设定浏览器通过缓存进行Web访问浏览器向缓存/代理服务器发送所有的HTTP请求如果所请求对象在缓存中，缓存返回对象否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后反水给客户端并保存该对象2、缓存既充当客户端，也充当服务器3、一般由ISP（Internet服务提供商）架设条件性Get方法目标：如果缓存有最新的版本，则不需要发送请求对象缓存：在HTTP请求消息中声明所持有版本的日期服务器：如果缓存的版本是最新的，则响应消息中不包含对象]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成Spring Security（二）注册 、密码加密、修改密码]]></title>
    <url>%2F2020%2F02%2F06%2FSpringBoot%E9%9B%86%E6%88%90Spring%20Security%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B3%A8%E5%86%8C%20%E3%80%81%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E3%80%81%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[SpringBoot集成Spring Security（一）登录注销写在前面上一节创建了项目并且利用Spring Security完成了登录注销功能，这里继续说一下注册、密码加密和找回密码，代码注释较清晰。一、web层控制StudentController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.jxnu.os.controller;import com.jxnu.os.model.RespBean;import com.jxnu.os.model.Student;import com.jxnu.os.service.StudentService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * @author xiao */@RestController@RequestMapping("/student")public class StudentController &#123; @Autowired StudentService studentService; /** * 注册 * @param student * @return */ @PostMapping("/register") public RespBean register(Student student) &#123; if(studentService.register(student))&#123; return RespBean.ok("注册成功",student); &#125;else&#123; return RespBean.error("注册失败，用户名已存在"); &#125; &#125; /** * 修改密码 * @param sno * @param password * @param rePassword * @return */ @PutMapping("/modifyPass") public RespBean modifyPass(String sno,String password,String rePassword) &#123; if(studentService.modifyPass(sno,password,rePassword))&#123; return RespBean.ok("修改成功"); &#125;else&#123; return RespBean.error("修改失败,原密码错误"); &#125; &#125;&#125; 二、service层注册时对密码进行加密，修改密码时则需先解密后验证StudentService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.jxnu.os.service;import com.jxnu.os.mapper.StudentMapper;import com.jxnu.os.model.Student;import com.jxnu.os.utils.StudentUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Service;import java.util.List;/** * @author xiao */@Servicepublic class StudentService implements UserDetailsService &#123; @Autowired StudentMapper studentMapper; /** * 注册 * @param student * @return */ public boolean register(Student student) &#123; Student existUser = studentMapper.loadUserBySno(student.getUsername()); if (existUser != null) &#123; //如果用户名已存在 return false; &#125; else &#123; BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); String encode = encoder.encode(student.getPassword()); student.setPassword(encode); studentMapper.insert(student); return true; &#125; &#125; /** * 修改密码 * @param sno * @param password * @param rePassword * @return */ public boolean modifyPass(String sno,String password,String rePassword) &#123; Student student = studentMapper.loadUserBySno(sno); BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); if(encoder.matches(password,student.getPassword())) &#123; String encode = encoder.encode(rePassword); rePassword = encode; studentMapper.modifyPass(sno,rePassword); return true; &#125;else &#123; return false; &#125; &#125;&#125; 三、mapper层StudentMapper.java 12345678910111213141516package com.jxnu.os.mapper;import com.jxnu.os.model.Student;import org.apache.ibatis.annotations.Param;import java.util.List;/** * @author xiao */public interface StudentMapper &#123; int insert(Student student); int modifyPass(String sno,String rePassword);&#125; StudentMapper.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.jxnu.os.mapper.StudentMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.jxnu.os.model.Student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result column=&quot;sno&quot; property=&quot;sno&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result column=&quot;s_sex&quot; property=&quot;s_sex&quot; jdbcType=&quot;CHAR&quot;/&gt; &lt;result column=&quot;t_id&quot; property=&quot;t_id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; &lt;update id=&quot;modifyPass&quot; parameterType=&quot;com.jxnu.os.model.Student&quot;&gt; update student set password = #&#123;rePassword&#125; where sno=#&#123;sno&#125; &lt;/update&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.jxnu.os.model.Student&quot;&gt; insert into student (username,password) values (#&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;) &lt;/insert&gt;&lt;/mapper&gt;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题记录（二）]]></title>
    <url>%2F2020%2F02%2F06%2Fleetcode%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[leetcode14：最长公共前缀问题描述：编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。示例1：输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例2：输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明:所有输入只包含小写字母 a-z 。思路： 首先找出数组中长度最短的字符串，该字符串一定包含或等于最长公共前缀。定义一个空字符串s，从第一个字符串开始与最短字符串比较，若对应字符相符，s加上该字符。否则直接返回s。代码如下： 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string s = ""; if(strs.empty()) return "; //输入为空，输出空字符串 string min = strs[0]; for(int i = 1; i &lt; strs.size(); i++) //找到最短字符串 &#123; if(strs[i].size() &lt; min.size()) min = strs[i]; &#125; for(int j = 0; j &lt; min.size(); j++) //从第一个字符开始对比，若都一样，s加上该字符 &#123; for(int m = 0; m &lt; strs.size(); m++) &#123; if(min[j] != strs[m][j]) return s; &#125; s = s + min[j]; &#125; return s; &#125;&#125;; leetcode20：有效的括号问题描述：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例1：输入: &quot;()[]{}&quot;输出: true 示例2:输入: &quot;([)]&quot;输出: false 思路： 核心思想遍历字符串，左括号入栈，遇到右括号，则看是否与栈顶元素括号匹配，如果不匹配，则输出false 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isValid(string s) &#123; //核心思想遍历字符串，左括号入栈，遇到右括号，则看是否与栈顶元素括号匹配，如果不匹配，则输出false 。遍历完需要检查栈是否为空 if (s.empty()) return true; stack&lt;char&gt; stack; for(int i=0;i&lt;s.size();i++) &#123; if (s[i] == '(' || s[i] == '[' || s[i] == '&#123;') &#123; stack.push(s[i]); &#125; else&#123; if(stack.empty()) return false; if ((s[i]==')' &amp;&amp; '('!=stack.top()) || (s[i]==']' &amp;&amp; '['!=stack.top()) || ((s[i]=='&#125;' &amp;&amp; '&#123;'!=stack.top()))) &#123;return false;&#125; stack.pop(); &#125; &#125; if(stack.empty()) return true; else return false; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成Spring Security（一）登录注销]]></title>
    <url>%2F2020%2F02%2F05%2FSpringBoot%E9%9B%86%E6%88%90Spring%20Security%EF%BC%88%E4%B8%80%EF%BC%89%E7%99%BB%E5%BD%95%E6%B3%A8%E9%94%80%2F</url>
    <content type="text"><![CDATA[SpringBoot集成Spring Security（二）注册 、密码加密、修改密码写在前面Spring Security是一种基于 Spring AOP 和 Servlet 过滤器的安全框架。它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理身份确认和授权。由于最近写的项目用到了这方面知识，这里做一些总结。下面直接看代码一、创建项目这里以多模块项目为例。 多模块项目优点： 帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便各个模块的构建，而不用每次都构建整个项目，使得针对某个模块的特殊控制更为方便。二、引入pom依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 三、web层 项目最核心的代码SecurityConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * @author xiao * 使用springsecurity对用户登录、注销以及权限进行控制 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private StudentService studentService; @Autowired private ObjectMapper objectMapper; @Bean PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(studentService).passwordEncoder(new BCryptPasswordEncoder()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http// .authenticationProvider(authenticationProvider()) .httpBasic() //未登录时 .authenticationEntryPoint((request,response,authException) -&gt; &#123; response.setContentType("application/json;charset=utf-8"); response.setStatus(HttpServletResponse.SC_FORBIDDEN); PrintWriter out = response.getWriter(); RespBean error = RespBean.error("未登录"); String s = new ObjectMapper().writeValueAsString(error); out.write(s); out.flush(); out.close(); &#125;) .and() .authorizeRequests() .anyRequest().authenticated() //必须授权才能范围 .and() .formLogin() //使用自带的登录 .usernameParameter("username") .passwordParameter("password") .permitAll() //登录失败，返回json .failureHandler(new AuthenticationFailureHandler() &#123; @Override public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception) throws IOException, ServletException &#123; resp.setContentType("application/json;charset=utf-8"); resp.setStatus(HttpServletResponse.SC_UNAUTHORIZED); PrintWriter out = resp.getWriter(); RespBean respBean = RespBean.error("登录失败!"); if (exception instanceof UsernameNotFoundException || exception instanceof BadCredentialsException) &#123; respBean.setMsg("用户名或者密码输入错误，请重新输入!"); &#125; else if (exception instanceof DisabledException) &#123; respBean.setMsg("账户被禁用"); &#125; else &#123; respBean.setMsg("未知错误"); &#125; out.write(objectMapper.writeValueAsString(respBean)); out.flush(); out.close(); &#125; &#125;) //登录成功，返回json .successHandler(new AuthenticationSuccessHandler() &#123; @Override public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException &#123; resp.setContentType("application/json;charset=utf-8"); PrintWriter out = resp.getWriter(); Student student = (Student) authentication.getPrincipal(); student.setPassword(null); RespBean ok = RespBean.ok("登录成功!", student); String s = new ObjectMapper().writeValueAsString(ok); out.write(s); out.flush(); out.close(); &#125; &#125;) .and() .exceptionHandling() //没有权限，返回json .accessDeniedHandler((request,response,ex) -&gt; &#123; response.setContentType("application/json;charset=utf-8"); response.setStatus(HttpServletResponse.SC_FORBIDDEN); PrintWriter out = response.getWriter(); out.write(new ObjectMapper().writeValueAsString(RespBean.error("权限不足"))); out.flush(); out.close(); &#125;) .and() .logout() //退出成功，返回json .logoutSuccessHandler(new LogoutSuccessHandler() &#123; @Override public void onLogoutSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException &#123; resp.setContentType("application/json;charset=utf-8"); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(RespBean.ok("注销成功!"))); out.flush(); out.close(); &#125; &#125;) .permitAll(); //开启跨域访问 http.cors().disable(); //开启模拟请求，比如API POST测试工具的测试，不开启时，API POST为报403错误 http.csrf().disable(); &#125; @Override public void configure(WebSecurity web) &#123; //对于在header里面增加token等类似情况，放行所有OPTIONS请求。 web.ignoring() .antMatchers(HttpMethod.OPTIONS, "/**"); &#125;&#125; 四、mapper层 mapper下的StudentMapper.java 1234567/** * @author xiao */public interface StudentMapper &#123; Student loadUserBySno(String sno);&#125; resource下的StudentMapper.xml** 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.jxnu.os.mapper.StudentMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.jxnu.os.model.Student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result column=&quot;sno&quot; property=&quot;sno&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result column=&quot;s_sex&quot; property=&quot;s_sex&quot; jdbcType=&quot;CHAR&quot;/&gt; &lt;result column=&quot;t_id&quot; property=&quot;t_id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;loadUserByUsername&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from student where username=#&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; 五、model层 model下的Student.java注意一定要implements UserDetails 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @author xiao * 学生实体类 */public class Student implements UserDetails &#123;// //学生主键ID private Integer id; //学生姓名 private String username; //登录密码 private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; private Collection&lt;? extends GrantedAuthority&gt; authorities; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAuthorities(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this.authorities = authorities; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return this.authorities; &#125; @Override public String getPassword() &#123; return this.password; &#125; @Override public String getUsername() &#123; return this.username; &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 六、service层service下的StudentService.java 12345678910111213141516171819202122232425/** * @author xiao */@Servicepublic class StudentService implements UserDetailsService &#123; @Autowired StudentMapper studentMapper; /** * 登录 * @param username * @return * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; Student student = studentMapper.loadUserBySno(username); if (student == null) &#123; throw new UsernameNotFoundException("用户不存在"); &#125; return student; &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层协议与网络应用]]></title>
    <url>%2F2020%2F02%2F05%2F%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[网络应用的体系结构1、客户机/服务器（Client-Server， C/S）服务器： 7*24小时提供服务 永久访问地址/域名 利用大量服务器实现可拓展性 客户机： 与服务器通信，使用服务器提供的服务 间歇性接入网络 可能使用动态IP地址 不会与其他客户机直接通信例如：Web服务 2、点对点结构（Peer-to-peer，P2P） 没有永远在线的服务器 任意端系统/节点之间可以直接通信 节点间歇性接入网络 节点可能改变IP地址 缺点：难于管理 优点：高度可伸缩 3、混合结构（Hybrid） Napster 文件传输使用P2P结构 文件的搜索采用C/S结构——集中式每个节点向中央服务器登记自己的内容每个节点向中央服务器提交查询请求，查找感兴趣的内容 网络应用的进程间通信进程：主机上运行的程序客户机进程：发起通信的进程服务器进程：等待通信请求的进程注意：采用P2P架构的应用同样存在客户机进程/服务器进程之分 同一主机上运行的进程： 进程间通信机制 操作系统提供 不同主机上运行的进程： 消息交换 套接字：Socket 进程间通信利用scoket发送/接收消息实现 类似于寄信 发送方将消息送到门外邮箱 发送方依赖（门外的）传输基础设施将消息传到接收方所在主机，并送到接收方的门外 接收方从门外获取消息 传输基础设施向进程提供API 传输协议的选择 参数的设置 如何寻址进程？ 不同主机上的进程间通信，那么每个进程必须拥有标识符 如何寻址主机？——IP地址 主机有了IP地址之后，并不足以定位进程，因为同一主机上可能同时有多个进程需要通信 端口号 为主机上每个需要通信的进程分配一个端口号 HTTP Server：80 Mail Server：25 进程的标识符IP地址+端口号 应用层协议 网络应用需遵循应用层协议 公开协议 由RFC（Request For Comments）定义 允许互操作 HTTP，SMTP，…… 私有协议多数P2P文件共享应用 应用层协议的内容 消息的类型（type）请求消息响应消息 消息的语法（syntax）格式消息中有哪些字段？每个字段如何描述 字段的语义（semantics）字段中信息的含义 规则（rules)进程何时发送/响应消息 网络应用对传输服务的需求 数据丢失/可靠性某些网络应用能容忍一定的数据丢失：网络电话某些网络应用要求100%可靠的数据传输：文件传输,telnet 时间延迟有些应用在延迟足够低时才“有效”网络电话/网络游戏 带宽（bandwidth）某些应用只有在带宽达到最低要求时才“有效”：网络视频某些应用能够适应任何带宽——弹性应用：email Internet提供的传输服务]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题记录(一)]]></title>
    <url>%2F2020%2F02%2F04%2Fleetcode%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[仅为自己的学习做记录1、leetcode1：两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 我的思路：题目已经给出提示The returned array must be malloced, assume caller calls free().所以需要定义一个存放数组下标的数组，代码如下： 123456789101112131415161718192021/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;int *num = malloc(sizeof(int)*2);// 定义一个存放数组下标的数组 for(int i = 0; i &lt; numsSize - 1; i++) &#123; for(int j = i + 1; j &lt; numsSize; j++) &#123; // 两层循环 if(nums[i] + nums[j] == target) &#123; num[0] = i; num[1] = j; *returnSize = 2; return num; &#125; &#125; &#125; return 0;&#125; 2、leetcode7：整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例1：输入: 123输出: 321 示例2：输入: -123输出: -321 示例3：输入: 120输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 我的思路：整数反转，与上题思路一致。这里需要注意整数溢出。tips 12C中常量INT_MAX和INT_MIN分别表示最大最小整数，定义在头文件limits.h中。因为int占4字节32位，根据二进制编码的规则，INT_MAX = 2^31-1，INT_MIN= -2^31.C/C++中，所有超过该限值的数，都会出现溢出，出现warning，但是并不会出现error。如果想表示的整数超过了该限值，可以使用长整型long long 占8字节64位。` 代码如下： 1234567891011121314int reverse(int x) &#123; long i = 0; long t = x; while (t) &#123; i = 10 * i + (t % 10); t /= 10; &#125; if (i &lt; INT_MIN || i &gt;INT_MAX) &#123; return 0; &#125; return i; &#125; 3、leetcode9： 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例1：输入：121输出：true 示例2：输出：-121输出：false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3：输入：10输出：false从右向左读, 为 01 。因此它不是一个回文数。 我的思路：把数字倒置后与原来的数相比较即可，代码如下： 1234567891011121314151617bool isPalindrome(int x)&#123; int r = 0; int m = x; if(x&lt;0) return false; else&#123; while(x) &#123; r=r*10+x%10; x/=10; &#125; if(x==m) return false; else return true; &#125;&#125; 但是提交之后显示解答错误Line 5: Char 25: runtime error: signed integer overflow: 746384741 * 10 cannot be represented in type &#39;int&#39; (solution.c)越界int最大值查询资料后更改代码如下: 12345678910111213141516171819bool isPalindrome(int x)&#123; int temp = 0; //当x为负数，或者x的末尾为0时返回错误 if(x&lt;0 || (x%10==0 &amp;&amp; x!=0))&#123; return false; &#125; while(x&gt;temp)&#123; temp = temp*10 + x%10; x = x/10; &#125; //分奇数偶数 if(temp == x || temp/10 == x)&#123; return true; &#125; else&#123; return false; &#125; &#125; 4、leetcode13：罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例1：输入: &quot;III&quot;输出: 3 示例2：输入: &quot;IV&quot;输出: 4 示例3：输入: &quot;IX&quot;输出: 9 示例4：输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例5：输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 我的思路：遍历输入字符串，如果当前字符代表数字小于上一个字符，直接相加。否则当前值减去上一位的值*2。代码如下： 1234567891011121314151617181920212223int romanToInt(char * s)&#123; int result=0,roman=0,temp=0; while (*s)&#123; switch (*s)&#123; case 'I':temp =1;break; case 'V':temp =5;break; case 'X':temp =10;break; case 'L':temp =50;break; case 'C':temp =100;break; case 'D':temp =500;break; case 'M':temp =1000; &#125; if(temp&gt;roman)&#123; result = result + (temp - roman*2); &#125;else&#123; result = result + temp; &#125; roman = temp; &#125; return result;&#125; 5、leetcode182：查找重复的电子邮箱编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。示例： 1234567+----+---------+| Id | Email |+----+---------+| 1 | a@b.com || 2 | c@d.com || 3 | a@b.com |+----+---------+ 根据以上输入，你的查询应返回以下结果： 12345+---------+| Email |+---------+| a@b.com |+---------+ 说明：所有电子邮箱都是小写字母。我的思路：这题比较简单哈哈哈哈，代码如下： 12# Write your MySQL query statement belowselect Email from Person group by Email having count(Email)&gt;1;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络体系结构]]></title>
    <url>%2F2020%2F02%2F03%2F%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[计算机网络的体系结构 网络体系结构是从功能上描述计算机网络结构 计算机网络体系结构简称网络体系结构，是分层结构 每层遵循某个/些网络协议完成本层功能 计算机网络体系结构是计算机网络各层及其协议的集合 体系结构是一个计算机网络的功能层次及其关系的定义 体系结构是抽象的 分层网络体系结构基本概念 实体表示任何可发送或接收信息的硬件或软件进程 协议是控制两个对等实体进行通信的规则的集合，协议是“水平的” 任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是“垂直的” 下层协议的实现对上层的服务用户是透明的 同系统的相邻层实体间通过接口进行交互，通过服务访问点SAP（Service Access Point），交换原语，指定请求的特定服务 OSI（开放系统互连）参考模型1、通信过程2、数据封装3、为什么需要数据封装？ 增加控制信息–》构造协议数据单元 控制信息主要包括：地址（Address）：标识发送端/接收端差错检测编码（Error-detecting code）：用户差错检测或纠正协议控制（Protocol control）：实现协议功能的附加信息，如：优先级、服务质量、安全控制等 4、物理层简单来说就是比特数据的传输 接口特性 —》机械特性、电气特征、功能特性、规程特性 比特编码 数据率 比特同步 —》时钟同步 传输模式单工 （单向通信，如传统的电视）半双工 （可以双向通信，但只能交替进行，如对讲机 发和说不能同时进行）全双工（双向传递 ，同时发和收） 5、数据链路层 负责结点-结点数据传输 组帧 物理寻址 在帧头中增加发送端或接收端的物理地址标识数据帧的发送端或接收端 流量控制 避免淹没接收端 差错控制 检测并重传损坏或丢失帧，避免重复帧 访问控制 在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权 6、网络层功能 负责源主机到目的主机数据分组交付可能穿越多个网络 逻辑寻址全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址 路由路由器（或网关）互连网络，并路由分组至最终目的主机 路径选择 分组转发 7、传输层负责源-目的（端-端）（进程间）完整报文传输 分段与重组 SAP寻址 确保将完整报文提交给正确进程，如端口号 连接控制 流量控制 差错控制 8、会话层 对话控制建立、维护 同步在数据流中插入“同步点” 最“薄”的一层 9、表示层处理两个系统间交换信息的语法与语义问题 数据表示转化转化为主机独立的编码 加密/解密 压缩/解压缩 10、应用层 支持用户通过用户代理（如浏览器）或网络接口使用网络（服务） 典型应用层服务：文件传输（FTP）电子邮件（SMTP）Web（HTTP）TCP/IP参考模型 5层参考模型综合OSI和TCP/IP的优点 应用层：提供进程之间的通信服务，实现网络各种具体应用；FTP，SMTP，HTTP、DNS、POP 传输层：提供端到端（主机到主机）的传输服务TCP，UDP 网络层：提供不同网络之间的选路服务IP协议、ICMP、路由协议等 数据链路层：提供一段链路相邻结点的传输服务以太网、WiFi、PPP 物理层：比特传输，提供网络通信的物理规范]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cisco Packet Tracer的安装与汉化]]></title>
    <url>%2F2020%2F02%2F02%2FCisco%20Packet%20Tracer%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B1%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、下载1、官网下载首先去思科官网下载对应的压缩包。点击图中所示注册下载按钮按照提示步骤完成注册注册之后登陆，点击导航栏中资源-&gt;所有资源，即可看到各版本压缩包。PTUI文件夹下有对应的汉化包，有需要的也可以自行下载。)2、网盘获取为方便大家下载我已经把安装包和汉化包放在了百度网盘中（7.2.1版本）链接：链接：https://pan.baidu.com/s/15_HGAcYW-pfbwyyWCwVdaA提取码：li5u二、安装安装步骤比较简单1、解压缩之后双击.exe文件开始安装软件。2、一路默认next即可（中途可以更换安装目录，自己随意）3、安装完成之后，点击finsh完成安装。三、汉化1、将Simplified Chinese.ptl文件复制进languages文件夹下。2、菜单栏中选择Option-&gt;Preferences,Select Language选择对应文件后重启服务即可（我这里是已经汉化成功的界面）。大功告成！]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述（二）]]></title>
    <url>%2F2020%2F02%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网络协议 网络协议规定了通信双方具体的通信规则，包括消息的传递细节。协议的三要素：语法、语义、同步 语义：对构成协议元素的含义的解释，即“讲什么”。 语法：数据与控制信息的结构或格式，即“怎么讲”。 同步：规定了事件的执行顺序。交换的概念和分类概念：网络中间结点按照某种方式动态地分配传输线路的资源，从输入链路选择连通到输出链路的过程称为交换。分类：电路交换技术、分组交换技术、报文交换技术电路交换技术特性：1）提供面向连接的服务（拨号建立连接，通信，挂机释放连接）电路交换最典型的例子就是打电话，当打电话时，别人无法打进同一个电话，资源独占。每次打电话时首先要拨号建立连接，打完电话需要挂机释放连接，属于面向连接的服务。2）资源独占，价格高3）通信可靠性高 分组交换技术核心思想：分组：将需要传输的较大的文件或报文分成多个小的包（分组）。存储转发：分组交换机（路由器）收到分组，存储到缓存中，排队等待处理，最后选择输出链路转发。资源共享：由于存储转发使得多个用户可以共享一段链路。资源共享是宏观的。 为什么要分组？ 数据越大，传输中出错的概率越大，重传分组的代价越高 数据越大，路由器缓存越大，不利于存储转发 分组分多大最合理？ 低出错不影响路由器存储转发的前提下尽可能大 一般链路的分组最大为1500Byte 每个分组加上首部有什么作用？ 首部实现了协议的规则 使接收方能够有效的将分组还原 分组交换网的优点和缺点？ 优点：适合计算机通信，实现宏观上的资源共享，通信效率高。 缺点：存储交换排队导致网络延迟很大甚至出现网络拥塞。 报文交换技术特点：不分组、存储转发、资源共享网络的带宽和时延带宽：网络的最高数据传输率，即每秒最高能传输多少bit的数据。单位：b/s或bps（每秒钟可以发送的比特数）一个网络的带宽是该网络所有链路带宽的最小值。 吞吐量：在单位时间内实际通过某个网络（或信道、接口）的数据量，单位b/s。 吞吐量是网络实际的带宽。传播速度：信号（即电磁波）在传输介质上的传播速率，单位m/s（米/秒）或千米/小时。 分组交换网络的时延传输时延（发送时延）：数据从结点发送到链路上的时间传播时延：信号从链路的一端发送到另一端传播的时间接收时延：一般作为结点处理时延考虑结点处理时延（排队转发时延）：路由器接收数据，排队等待处理，查找转发表决定输出链路所花费的时间 分组交换网络时延的计算传输时延=数据大小/网络带宽由网络带宽、数据大小决定 传播时延=链路长度/传播速度由传播介质、传播速度、链路长度决定 分组交换网的网络拥塞网络拥塞现象：当中间节点（路由器）收到数据的速度大于发出数据的速度时，缓冲将被填满，部分分组将被丢弃，网络出现拥塞。往返时延RTTRTT（Roud-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的确认为止总共经历的时延。RTT反映了分组传输总的时延，使用ping命令可以测量RTT。时延带宽积链路的时延带宽积又称为以比特为单位的链路长度。 时延带宽积 = 传播时延 x 带宽]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络的性能指标与分组交换网络]]></title>
    <url>%2F2020%2F02%2F01%2F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[同个人网站：http://tsundere-x.top/计算机网络概述（三）计算机网络概述（一）网络协议网络协议规定了通信双方具体的通信规则，包括消息的传递细节。协议的三要素：语法、语义、同步 语义：对构成协议元素的含义的解释，即“讲什么”。 语法：数据与控制信息的结构或格式，即“怎么讲”。 同步：规定了事件的执行顺序。 交换的概念和分类概念：网络中间结点按照某种方式动态地分配传输线路的资源，从输入链路选择连通到输出链路的过程称为交换。分类：电路交换技术、分组交换技术、报文交换技术 电路交换技术 特性1）提供面向连接的服务（拨号建立连接，通信，挂机释放连接）电路交换最典型的例子就是打电话，当打电话时，别人无法打进同一个电话，资源独占。每次打电话时首先要拨号建立连接，打完电话需要挂机释放连接，属于面向连接的服务。2）资源独占，价格高3）通信可靠性高 分组交换技术 核心思想：分组：将需要传输的较大的文件或报文分成多个小的包（分组）。存储转发：分组交换机（路由器）收到分组，存储到缓存中，排队等待处理，最后选择输出链路转发。资源共享：由于存储转发使得多个用户可以共享一段链路。资源共享是宏观的。 为什么要分组？ 数据越大，传输中出错的概率越大，重传分组的代价越高 数据越大，路由器缓存越大，不利于存储转发 分组分多大最合理？ 低出错不影响路由器存储转发的前提下尽可能大 一般链路的分组最大为1500Byte 每个分组加上首部有什么作用？ 首部实现了协议的规则 使接收方能够有效的将分组还原 分组交换网的优点和缺点？ 优点：适合计算机通信，实现宏观上的资源共享，通信效率高。 缺点：存储交换排队导致网络延迟很大甚至出现网络拥塞。 报文交换技术特点：不分组、存储转发、资源共享 三种交换技术比较 网络的性能指标网络的带宽和时延带宽：网络的最高数据传输率，即每秒最高能传输多少bit的数据。单位：b/s或bps（每秒钟可以发送的比特数）一个网络的带宽是该网络所有链路带宽的最小值。 网络带宽的进一步说明 为什么20Mb/s的带宽下载速度约2.4MB/S？ 网络带宽单位：1Mb/s = 10^3^kb/s = 10^6^b/s计算机存储单位：1M = 1024K = 2^20^Byte = 8*2^20^bit 吞吐量：在单位时间内实际通过某个网络（或信道、接口）的数据量，单位b/s。 吞吐量是网络实际的带宽。 带宽是网络最高的吞吐量 传播速度：信号（即电磁波）在传输介质上的传播速率，单位m/s（米/秒）或千米/小时。 分组交换网络的时延 传输时延（发送时延）：数据从结点发送到链路上的时间传播时延：信号从链路的一端发送到另一端传播的时间接收时延：一般作为结点处理时延考虑结点处理时延（排队转发时延）：路由器接收数据，排队等待处理，查找转发表决定输出链路所花费的时间 在移动网访问部署在电信的服务器为什么会很慢？ 分组交换网络时延的计算传输时延=数据大小/网络带宽由网络带宽、数据大小决定 传播时延=链路长度/传播速度由传播介质、传播速度、链路长度决定 分组交换网的网络拥塞网络拥塞现象：当中间节点（路由器）收到数据的速度大于发出数据的速度时，缓冲将被填满，部分分组将被丢弃，网络出现拥塞。往返时延RTTRTT（Roud-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的确认为止总共经历的时延。RTT反映了分组传输总的时延，使用ping命令可以测量RTT。时延带宽积链路的时延带宽积又称为以比特为单位的链路长度。 时延带宽积 = 传播时延 x 带宽]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述（一）]]></title>
    <url>%2F2020%2F01%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[计算机网络 = 通信技术 + 计算机技术计算机网络是通信技术海域计算机技术紧密结合的产物计算机网络就是一种通信网络什么是计算机网络？广义的计算机网络定义：在协议控制下，由一台或多台计算机、若干台终端设备、数据传输设备，以及用于终端和计算机之间、或者若干台计算机之间数据流动的通信控制处理机组成的系统的集合。计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备（交换机、路由器等）与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。计算机网络就是互连的、自治的计算机集合（公认的概念） 自治-无主从关系 ： 一台计算机不能控制另一台计算机互连-互联互通 ：通过通信链路—》网络中两个节点之间的物理通道称为通信链路。通信链路的传输介质主要有双绞线、光纤和微波。 计算机网络的发展20世纪60年代：分组交换思想的提出，可能比世界上第一个网络的意义更加重大，它使得网络传输数据成为可能，并一直沿用到今天。 20世纪70~80年代：TCP/IP协议思想的提出，提供了这样一种可能：即不同厂商生产的计算机，不同结构的网络间实现互通。所以它既是一个协议簇，更是一种标准，它使得网络飞速向前发展。 20世纪90年代：Web技术真正把网络引入民用行业，使得网络行业生机勃勃，飞速发展。随着网络的逐步普及，网络用户在这个时期飞速增长，现如今各行各业都已经离不开网络 计算机网络的功能数据通信：数据通信是计算机网络最基本、最重要的功能，包括连接控制，传输控制，差错控制，流量控制，路由选择，多路复用等子功能。资源共享：包括硬件资源、软件资源和数据资源。分布式处理：当计算机网络中的某个计算机负荷过重时，可以将其处理的任务传送给网络中的其他计算机系统进行处理，利用空闲计算机资源提高整个系统的利用率。典型的有Hadoop平台。提高可靠性：计算机网络中的每台计算机可以通过网络互为替代机，一台计算机宕机了可有另一台计算机替代。负载均衡：将工作任务均衡地分配给计算机网络中的各台计算机。 计算机网络的组成物理组成（硬件、软件、协议三大部分） 1、硬件：由主机、通信处理机、通信线路（包括有线线路和无线线路）和交换设备（交换机等连接设备）组成。 2、软件：主要包括实现资源共享的软件和方便用户使用的各种工具软件（如QQ）。 3、协议：就是一种规则，如汽车在道路上行驶必须遵循交通规则一样，数据在线路上传输也必须遵循一定的规则。工作方式组成（边缘部分、核心部分）1、边缘部分：由所有链接在互联网上，供用户直接使用的主机组成，用来进行通信和资源共享—》C/S方式、P2P方式。2、核心部分：由大量的网络和链接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。 功能组成（通信子网、资源子网） 1、通信子网：由各种传输介质、通信设备和相应的网络协议组成，为网络提供数据传输、交换和控制能力，实现联网计算机之间的数据通信。包括网络层、数据链路层、物理层 2、资源子网：由主机、终端以及各种软件资源、信息资源组成，负责全网的数据处理业务，向网络用户提供各种网络资源和服务。包括应用层、表示层、会话层 局域网（Local Area Network, LAN）：一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网络。包括以太网、令牌环网等。当前的局域网主流是以太网。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。 域域网（Metropolitan Area Network，MAN）：一种介于局域网与广域网之间，覆盖一个城市的地理范围，用来将同一区域内的多个局域网互连起来的中等范围的计算机网络。这些网络通常涵盖一个大学校园或一座城市。MAN的一个重要用途是用作骨干网，通过它将位于同一城市内不同地点的主机、数据库，以及LAN等互相联接起来。 广域网（Wide Area Network，WAN）：一种用来实现不同地区的局域网或域域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网络。所覆盖的范围从几十公里到几千里。它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github托管代码以及github一些最常用的命令]]></title>
    <url>%2F2020%2F01%2F21%2F%E4%BD%BF%E7%94%A8github%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E4%BB%A5%E5%8F%8Agithub%E4%B8%80%E4%BA%9B%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[生成SSH密钥首先打开命令行工具，右键鼠标任意位置打开git bash here,然后输入以下命令cd ~/.ssh使用ssh-keygen生成密钥ssh-keygen -t rsa -C &quot;我的邮箱地址&quot;使用默认的文件名，输入密码，密钥生成成功直接复制命令行看到的密钥会失败，正确复制密钥的方法：ls一下查看是否有id_rsa.pub文件，如果有，则打开文件，复制文件里面的内容.新建仓库后点击Settings-&gt;Deploy keys将复制所得密钥粘贴至对应位置即可。 github一些最常用的命令git init 仓库初始化git status 查看工作区代码相对于暂存区的差别git add . 将当前目录下修改的所有代码从工作区添加至暂存区git commit -m ‘注释’ 将缓存区内容添加到本地仓库git push origin master 将本地版本推送到远程服务器，origin是远程主机，master表示是远程服务器上的master分支，分支名是可以修改的。]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中注解大全]]></title>
    <url>%2F2019%2F11%2F30%2FSpring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8%20%2F</url>
    <content type="text"><![CDATA[@Controller标识一个该类是Spring MVC controller 处理器，用来创建处理http请求的对象1234567@Controllerpublic class TestController&#123; @RequestMapping("test") public String test(Map&lt;String,Object&gt; map)&#123; return "hello"; &#125;&#125; @RestControllerSpring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@RestController，默认返回json格式。 1234567@RestControllerpublic class TestController&#123; @RequestMapping("/test") public String test(Map&lt;String,Object&gt; map)&#123; return "hello"; &#125;&#125; @Service用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中 @Autowired用来装配bean，都可以写在字段上，或者方法上。 默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired（required=false） @RequestMapping类定义处：提供初步的请求映射信息，相对于WEB应用的根目录。 方法处：提供进一步的细分映射信息，相对于类定义处的URL。 @RequestParam用于将请求参数区数据映射到功能处理方法的参数上 123public Resp test(@RequestParam Integer id)&#123; return Resp.success(customerInfoService.fetch(id));&#125; 这个id就是要接收从接口传递过来的参数id的值的，如果传递过来的参数名和接收的不一致，也可以如下 123public Resp test(@RequestParam(value="course_id") Integer id)&#123; return Resp.success(customerInfoService.fetch(id));&#125; 其中course_id就是接口传递的参数，id即使映射course_id的参数名 @ModelAttribute1、标记在方法上 标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。 A、在有返回的方法上： 当ModelAttribute设置了value，方法返回的值会以这个value为key，以参数接受到的值作为value，存入到Model中，如下面的方法执行之后，最终相当于model.addAttribute（“user_name”，name）;假如 @model.addAtrribute没有自定义value，则相当于model.addAttribute（“name”，name）； 12345@ModelAttribute(value="user_name")public String before2(@RequestParam(required = false) String name,Model model)&#123; System.out.println("进入了2，" + name); return name;&#125; B、在没返回的方法上： 需要手动model.add方法 12345@ModelAttributepublic void before(@RequestParam(required = false) Integer age, Model model)&#123; model.addAttribute("age",age); System.out.println("进入了1：" + age);&#125; 我们在当前类下建一个请求方法： 1234567891011@RequestMapping(value = "/mod")public Resp mod( @RequestParam(required = false) String name; @RequestParam(required = false) Integer age; Model model)&#123; System.out.println("进入mod"); System.out.println("参数接受的数值&#123;name="+name+";age="+age+"&#125;"); System.out.println("model传过来的值：" + model); return Resp.success("1"); &#125;) 在浏览器中输入访问地址并且加上参数： http://localhost:8080/api/test/mod?name = 我是哈哈 &amp; age = 12 最终输出 12345进入了1：:40进入了2：我是哈哈进入mod参数接受的数值(name = 我是哈哈， age = 18)model传来的值：&#123;age = 40, user_name = 我是哈哈 &#125; 2、标记在方法的参数上 标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。我们在上面的类中加入一个方法如下 1234567891011@RequestMapping(value="/mod2")public Resp mod2(@ModelAttribute("user_name") String user_name, @ModelAttribute("name") String name, @ModelAttribute("age") Integer age, Model model)&#123; System.out.println("进入mod2"); System.out.println("user_name:" + user_name); System.out.println("name:" + name); System.out.println("age:" + age); System.out.println("model:" + model); return Resp.success("1"); &#125; 在浏览器中输入访问地址并且加上参数： http://localhost:8080/api/test/mod2?name = 我是哈哈 &amp; age = 12 最终输出 1234567进入了1：40进入了2：我是哈哈进入了mod2user_name：我是哈哈name：我是哈哈age：40model:&#123;user_name = 我是哈哈，org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, age=40, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: 0 errors&#125;&#125; 从结果可以看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。 @Cacheable用来标记缓存查询。可用用于方法或者类中 当标记在一个方法上时表示该方法是支持缓存的， 当标记在一个类上时则表示该类所有的方法都是支持缓存的。比如@Cacheable(value=”UserCache”) 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。 但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义. 1234567@Cacheable(value="UserCache")// 使用了一个缓存名叫 accountCache public Account getUserAge(int id) &#123; //这里不用写缓存的逻辑，直接按正常业务逻辑走即可， //缓存通过切面自动切入 int age=getUser(id); return age; &#125; @CacheEvict用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。@CacheEvict(value=”UserCache”) @Resource@Resource的作用相当于@Autowired 只不过@Autowired按byType自动注入， 而@Resource默认按 byName自动注入罢了。 @Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序: 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； @PostConstruct用来标记是在项目启动的时候执行这个方法。用来修饰一个非静态的void()方法 也就是spring容器启动时就执行，多用于一些全局配置、数据字典之类的加载 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行,init()方法之前执行。PreDestroy（）方法在destroy()方法执行执行之后执行 @PreDestroy被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前 @Repository用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注 @Scope用来配置 spring bean 的作用域，它标识 bean 的作用域。 默认值是单例 singleton:单例模式,全局有且仅有一个实例 prototype:原型模式,每次获取Bean的时候会有一个新的实例 request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效 global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。 @SessionAttributes默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中 参数： names：这是一个字符串数组。里面应写需要存储到session中数据的名称。 types：根据指定参数的类型，将模型中对应类型的参数存储到session中 value：和names是一样的。 12345678910@Controller @SessionAttributes(value=&#123;"names"&#125;,types=&#123;Integer.class&#125;) public class ScopeService &#123; @RequestMapping("/testSession") public String test(Map&lt;String,Object&gt; map)&#123; map.put("names", Arrays.asList("a","b","c")); map.put("age", 12); return "hello"; &#125; &#125; @Required适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。 @Qualifier当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（三）线程的互斥与同步机制]]></title>
    <url>%2F2019%2F10%2F07%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[线程的互斥与同步机制一、互斥为何需要引入互斥机制？ 当多个线程对同一数据并发读写（至少有一个线程执行写操作）时，这种情形被称为竞争。竞争会导致数据读或写的不确定性。而有时这种不确定性是不可容忍的。 如何实现互斥？ 在并发程序设计中，通常使用锁机制来实现互斥 1、由用户标记必须原子执行的代码段，即使用synchronized关键字 2、给资源一把配有自动机制的锁 【注意】： Java将资源限定为引用型对象，并为每一对象自动配备一把锁：锁初始时处于打开状态。synchronized标记的原子代码段在访问资源前，会自动检测资源对象持有的锁是否处于打开状态。若是，则占用并同时将锁置为锁闭态，并在该代码段执行完毕后。将锁的状态值为打开态；若否，则持有该代码的线程因等待资源占用而进入阻塞态。 • 只有对象才有锁，对基本类型的数据，无法实现线程的互斥访问。 • 对于未使用synchronized标记的代码，锁机制不起作用。 • 无论正常结束还是异常退出，都将自动释放锁。 死锁和活锁 死锁：就是多个线程对临界资源的循环等待，使得这些线程均都无法获得执行。 例如：A，B，C三个线程分别占用D1、D2、D3三个临界资源，A只有获得B占用的资源D2,方能继续运行；而B只有获得C占用的资源D3，方能继续运行；C只有获得A占用的资源D1，方能继续运行。这样，A,B,C处在对资源的循环等待状态，均无法前进。 活锁：也称饥饿。就是某线程虽有执行的资格，但由于某种原因总是得不到执行。 例如：A,B,C三个线程循环访问临界资源D，但A，B的优先级相同，但均高于C。由于Java的抢占式策略，C线程可能总得不到执行。 二、同步同步（Sync） 多个线程的运行满足特定的节奏 所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 根据这个定义，Java中所有方法都是同步调用，应为必须要等到结果后才会继续执行。我们在说同步、异步的时候，一般而言是特指那些需要其他端协作或者需要一定时间完成的任务。 简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。 异步（Async） 多个线程的运行相互独立，彼此间无依赖性 异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。 举个例子简单说明下两者的区别： 同步：火车站多个窗口卖火车票，假设A窗口当卖第288张时，在这个短暂的过程中，其他窗口都不能卖这张票，也不能继续往下卖，必须这张票处理完其他窗口才能继续卖票。直白点说就是当你看见程序里出现synchronized这个关键字，将任务锁起来，当某个线程进来时，不能让其他线程继续进来，那就代表是同步了。 异步：当我们用手机下载某个视频时，我们大多数人都不会一直等着这个视频下载完，而是在下载的过程看看手机里的其他东西，比如用qq或者是微信聊聊天，这种的就是异步，你执行你的，我执行我的，互不干扰。比如上面卖火车票，如果多个窗口之间互不影响，我行我素，A窗口卖到第288张了，B窗口不管A窗口，自己也卖第288张票，那显然会出错了。 并发 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。 并行 在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事 件之间不一定要同一时刻发生。 *Java的同步机制 = 存取共享资源的互斥机制 + 线程间的通信机制* 用于线程通信的方法存在于Object类中，包括wait()、notify()、notifyAll()。wait()会暂停当前线程的执行，并释放所持有的锁，进入等待状态；notify()操作将唤醒一个等待的线程；notifyAll()将唤醒所有等待的进程。 【注意】 wait()、notify()、notifyAll()都是final方法，不允许被重写；这些方法只能直接或间接地用于临界区中，否则，将会产生非法监控锁状态异常。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（二）线程的构造和运行]]></title>
    <url>%2F2019%2F10%2F07%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[① 用Thread类构造线程对象（继承Thread类来创建并启动多线程） 123456789101112131415161718192021222324252627282930313233343536373839package cn.sxt.thread;/** * 创建线程方式一： * 1、创建：继承Thread+重写run * 2、启动：创建子类对象+start * @author 1979 * */public class StartThread extends Thread&#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println("一边听歌"); &#125; &#125; public static void main(String[] args) &#123; /* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程 * for(int i=0;i&lt;20;i++) &#123; * System.out.println("一边coding"); * &#125; */ //创建子类对象 StartThread st = new StartThread(); //启动 st.start();//不保证立即运行 由cpu调用 //st.run();//普通方法调用，只能听完歌再敲代码 for(int i=0;i&lt;20;i++) &#123; System.out.println("一边coding"); &#125; &#125;&#125; 【运行结果】 12345678一边coding一边coding...一边听歌一边听歌...一边coding一边coding 【缺点】：由于java采用单继承机制，若为实现多线程而继承了Thread，将无法再继承其他类，是非常不明智的做法。 ② 用Runnable辅助构造线程（实现Runnable接口创建线程类） 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.sxt.thread;/*** * 创建线程方式二 * 1、创建：实现Runnable+重写run * 2、启动：创建实现类对象+Thread对象+start * * 推荐：避免单继承的局限性，优先使用接口 * 方便共享资源 * @author 1979 * */public class StartRun implements Runnable&#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println("一边听歌"); &#125; &#125; public static void main(String[] args) &#123; /* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程 * for(int i=0;i&lt;20;i++) &#123; * System.out.println("一边coding"); * &#125; */ //创建实现类对象 StartRun sr = new StartRun(); //创建代理类对象 Thread t = new Thread(sr); //启动 t.start();//不保证立即运行 由cpu调用 //st.run();//普通方法调用，只能听完歌再敲代码 for(int i=0;i&lt;20;i++) &#123; System.out.println("一边coding"); &#125; &#125;&#125; 【运行结果】 12345678一边coding一边coding...一边听歌一边听歌...一边coding一边coding 12345678910111213141516171819202122232425262728293031323334353637383940package liti_07;/*本例展现这样一种方式：利用Runnable接口直接构造线程并运行 *有如下关键点： *1、希望该类中创建线程对象，就必须有线程成员，即私有变量t; *2、在构造函数中构造t引用的线程对象，注意把自己作为参数传给t; *3、还需要启动线程。由于t长设为私有，故不能直接t.start()， * 需要设置其他方法，如本例另提供一个公共的start()方法。 **/public class Ch_7_3 implements Runnable&#123; public static void main (String[] args) &#123; System.out.print("Main 开始"); Ch_7_3 m1=new Ch_7_3(1,"奇数线程"); //注意，m1依旧不是线程对象 Ch_7_3 m2=new Ch_7_3(2,"偶数线程"); m1.start(); //注意，调用的是类R自己定义的start() m2.start(); System.out.print("当前共有"+ Thread.activeCount()+"个线程"); System.out.print("Main 结束"); &#125; private int d; private Thread t; //-----新增成员 public void start()&#123; t.start(); &#125; //-----关键点2 public Ch_7_3(int x, String s)&#123; d=x; //t=new Thread(this); t.setName(s); //----关键点1 t=new Thread(this,s); &#125; public void run()&#123; for(int i=d; i&lt;50;i=i+2) System.out.print(" "+i); //Thread t=Thread.currentThread(); //---此句不再需要 System.out.print(t.getName()+"结束！"); &#125; &#125; 线程的一些常用方法 1、currentThread() 返回对当前正在执行的线程对象的引用。 2、getId() 返回此线程的标识符 3、getName() 返回此线程的名称 4、getPriority() 返回此线程的优先级 5、isAlive() 测试这个线程是否还处于活动状态。 什么是活动状态呢？ 活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。 6、sleep(long millis) 使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。 7、interrupt() 中断这个线程。 8、interrupted() 和isInterrupted() interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能 isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但不清楚状态标志 9、 setName(String name) 将此线程的名称更改为等于参数 name 。 10、isDaemon() 测试这个线程是否是守护线程。 11、setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程。 12、join() 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。 join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行 13、yield() yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。 14、setPriority(int newPriority) 更改此线程的优先级]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo如何绑定个人域名]]></title>
    <url>%2F2019%2F10%2F06%2FHexo%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[title: 3分钟教你Hexo如何绑定个人域名date: 2019-10-06 10:47:48tags: Hexo 前两天用Hexo+GitHub搭建好了自己的个人博客http://tsundere-x.top/ ，默认域名github下的二级域名：username.github.io，为了提升访问速度和博客的格调，绑定个人域名是多数人的选择。下面给大家介绍详细过程。 购买域名 国内有很多不错的域名服务商，这里我给大家推荐阿里云的万网。我购买的域名是：tsundere-x.top。 大家可以根据自身的需求购买相应的域名。点击查域名后确认域名没有被使用后即可下单购买，当然在付款之前你还需要进行邮箱验证和实名认证（虽然上面提示实名认证需要3-5天，但正常情况下其实只要一个小时左右）。 实名认证通过后进行域名解析 在此之前需要获取自己 github 的二级域名的 IP地址 。cmd下ping+自己博客的地址即可获得。 实名认证后来到域名控制台，点击解析。 进入新手指导，将得到的 IP 地址填到记录值一栏 即可。 仓库的custom domain绑定域名 进入仓库中， 点击 setting 往下滑 会看到custom domain 将自己购买的域名填写进去 。 最后一步，设置CNAME 进入Hexo根目录下的source文件夹，新建CNAME文件（文件！！！，不需要任何后缀）。 接下来 使用 hexo d -g 重新部署，就可以成功访问咯！]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（一）]]></title>
    <url>%2F2019%2F10%2F05%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%E3%80%81Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1 程序、进程、线程之间的区别与联系 三者之间的形象化理解： * 程序：代码实现了功能，就是程序，是静态的； * 进程：执行中的程序就是进程，是动态的； * 线程：进程内的一个执行单元,也是进程内的可调度实体，可以并发执行提高了进程的效率。 进程和线程的关系：（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。（3）处理机分给线程，即真正在处理机上运行的是线程。（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 线程与进程的区别: (1) 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 。 (2) 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 。 (3) 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。 (4) 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 程序与进程的区别：程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。 程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。 进程更能真实地描述并发，而程序不能；进程是由程序和数据两部分组成的。进程具有创建其他进程的功能，而程序没有。 同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程。也就是说同一程序可以对应多个进程。 2 Java的线程状态和生命周期) ==新建状态:==使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 ==就绪状态:==当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 ==运行状态:==如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 ==阻塞状态:==如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O处理完毕，线程重新转入就绪状态。 ==死亡状态:==一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this和super的用法总结]]></title>
    <url>%2F2019%2F10%2F04%2FJava%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[this this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this 的用法在 Java 中大体可以分为3种： 1.普通的直接引用 this 相当于是指向当前对象本身。 2.形参与成员名字重名，用 this 来区分：123456789101112131415161718class Person &#123; private int age = 10; public Person()&#123; System.out.println("初始化年龄："+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println("Harry's age is "+Harry.GetAge(12)); &#125;&#125; 运行结果： 1初始化年龄：10 Harry&apos;s age is 12 可以看到，这里 age 是 GetAge 成员方法的形参，this.age 是 Person 类的成员变量。 3.引用构造函数supersuper 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super 也有三种用法： 1.普通的直接引用与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员。 2.子类中的成员变量或方法与父类中的成员变量或方法同名123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = "China"; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = "Shanghai"; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 运行结果： 1Shanghai China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法 value()，只调用父类变量 name 的话，则父类 name 值为默认值 null。 3.引用构造函数 super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 123456789101112131415161718192021222324252627282930313233343536class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt("父类·无参数构造方法： "+"A Person."); &#125;//构造方法(1) Person(String name) &#123; prt("父类·含一个参数的构造方法： "+"A person's name is " + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt("子类·调用父类"无参数构造方法"： "+"A chinese coder."); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt("子类·调用父类"含一个参数的构造方法"： "+"his name is " + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt("子类：调用子类具有相同形参的构造方法：his age is " + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese("codersai"); cn = new Chinese("codersai", 18); &#125; &#125; 运行结果： 1234567父类·无参数构造方法： A Person.子类·调用父类”无参数构造方法“： A chinese coder.父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用 super 和 this 分别调用父类的构造方法和本类中其他形式的构造方法。 例子中 Chinese 类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 ==super 和 this 的异同== super(参数)：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this(参数)：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。 super() 和 this() 均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static 方法，static 语句块。 从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
