<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F11%2F22%2FCisco%20Packet%20Tracer%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B1%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[同个人网站 https://www.serendipper-x.cn/，欢迎访问 ！一、下载1、官网下载首先去思科官网下载对应的压缩包。点击图中所示注册下载按钮按照提示步骤完成注册注册之后登陆，点击导航栏中资源-&gt;所有资源，即可看到各版本压缩包。PTUI文件夹下有对应的汉化包，有需要的也可以自行下载。)2、网盘获取为方便大家下载我已经把安装包和汉化包放在了百度网盘中（7.2.1版本）链接：链接：https://pan.baidu.com/s/15_HGAcYW-pfbwyyWCwVdaA提取码：li5u二、安装安装步骤比较简单1、解压缩之后双击.exe文件开始安装软件。2、一路默认next即可（中途可以更换安装目录，自己随意）3、安装完成之后，点击finsh完成安装。三、汉化1、将Simplified Chinese.ptl文件复制进languages文件夹下。2、菜单栏中选择Option-&gt;Preferences,Select Language选择对应文件后重启服务即可（我这里是已经汉化成功的界面）。大功告成！]]></content>
  </entry>
  <entry>
    <title><![CDATA[VMware安装CentOS7超详细版]]></title>
    <url>%2F2020%2F02%2F11%2FVMware%E5%AE%89%E8%A3%85CentOS7%E8%B6%85%E8%AF%A6%E7%BB%86%E7%89%88%2F</url>
    <content type="text"><![CDATA[同个人网站 https://www.serendipper-x.cn/，欢迎访问 ！写在前面云计算与分布式这门课程的老师让我们使用vmware安装好centos7.6并配置好Java编译环境，刚好复习一波，下面是详细的安装过程。准备工作 VMware，我用的是VMware Workstation Pro 15，下载与安装方法就不提了毕竟重点在后头。 CentOS7镜像文件，由于7.6版本已经停更，这里我用的是7.7版本。下载地址 http://isoredirect.centos.org/centos/7/isos/x86_64习惯性选择阿里的镜像，点击下载即可。安装过程 打开vmware，点击创建新的虚拟机选择自定义配置，点击下一步这里直接默认下一步选择稍后安装操作系统，点击下一步客户机操作系统选择Linux，版本选择CentOS 7 64位，点击下一步虚拟机名称可以自定义，这里建议以见名知意为原则，位置尽量放在C盘外的其他盘符，这里我选择的是D盘。处理器数量和每个处理器的内核数可根据自己电脑配置进行选择。这里默认都选择1。同样的，虚拟机内存也依据自己电脑配置进行选择，由于我的电脑是8GB，所以这里我选2GB。网络连接选择NAT后两项默认推荐，点击下一步。)点击创建新虚拟磁盘最大磁盘大小按需分配，我给了20GB，选择将虚拟磁盘拆分成多个文件。默认点击下一步可以看到CentOS7已经添加进去了右键CentOS7,点击设置进入设置页面，点击CD/DVD,使用ISO映像文件，选择之前下载的文件即可。 开启虚拟机，见到如下页面，选择Install CentOS Linux 7,直接Enter滑动右侧滚动条选择中文=》简体中文，英文好的同学当然可以选择英文这里配置一些基本信息1、点击安装源，进入之后直接选择done，警告符号随即消失。2、软件选择：GNOME桌面，一个友好的图形化界面3、根据需要禁用Kdump4、自动分区，一般化为4个分区，如图所示 ))完成后点击开始安装安装过程中会弹出用户设置界面，填好并记住密码。)安装完成后点击重启，看到如下界面点击接受许可设置一下网络 点击完成配置现在可以使用之前创建的用户进行登录了登录成功后可看到图形化界面上网 开启windows下的VMnet8cmd窗口ping出主机ip地址打开有线设置网络=》开启，点击设置图标选择自动连接)打开终端，使用ifconfig命令获取ip地址在终端ping下windows 中VMnet8的IP地址，若出现下图所示信息，则表示linux的ip地址设置成功。此时，若windows能上网，则linux也能上网打开火狐浏览器，上网成功！]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述（二）]]></title>
    <url>%2F2020%2F02%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网络协议 网络协议规定了通信双方具体的通信规则，包括消息的传递细节。协议的三要素：语法、语义、同步 语义：对构成协议元素的含义的解释，即“讲什么”。 语法：数据与控制信息的结构或格式，即“怎么讲”。 同步：规定了事件的执行顺序。交换的概念和分类概念：网络中间结点按照某种方式动态地分配传输线路的资源，从输入链路选择连通到输出链路的过程称为交换。分类：电路交换技术、分组交换技术、报文交换技术电路交换技术特性：1）提供面向连接的服务（拨号建立连接，通信，挂机释放连接）电路交换最典型的例子就是打电话，当打电话时，别人无法打进同一个电话，资源独占。每次打电话时首先要拨号建立连接，打完电话需要挂机释放连接，属于面向连接的服务。2）资源独占，价格高3）通信可靠性高 分组交换技术核心思想：分组：将需要传输的较大的文件或报文分成多个小的包（分组）。存储转发：分组交换机（路由器）收到分组，存储到缓存中，排队等待处理，最后选择输出链路转发。资源共享：由于存储转发使得多个用户可以共享一段链路。资源共享是宏观的。 为什么要分组？ 数据越大，传输中出错的概率越大，重传分组的代价越高 数据越大，路由器缓存越大，不利于存储转发 分组分多大最合理？ 低出错不影响路由器存储转发的前提下尽可能大 一般链路的分组最大为1500Byte 每个分组加上首部有什么作用？ 首部实现了协议的规则 使接收方能够有效的将分组还原 分组交换网的优点和缺点？ 优点：适合计算机通信，实现宏观上的资源共享，通信效率高。 缺点：存储交换排队导致网络延迟很大甚至出现网络拥塞。 报文交换技术特点：不分组、存储转发、资源共享网络的带宽和时延带宽：网络的最高数据传输率，即每秒最高能传输多少bit的数据。单位：b/s或bps（每秒钟可以发送的比特数）一个网络的带宽是该网络所有链路带宽的最小值。 吞吐量：在单位时间内实际通过某个网络（或信道、接口）的数据量，单位b/s。 吞吐量是网络实际的带宽。传播速度：信号（即电磁波）在传输介质上的传播速率，单位m/s（米/秒）或千米/小时。 分组交换网络的时延传输时延（发送时延）：数据从结点发送到链路上的时间传播时延：信号从链路的一端发送到另一端传播的时间接收时延：一般作为结点处理时延考虑结点处理时延（排队转发时延）：路由器接收数据，排队等待处理，查找转发表决定输出链路所花费的时间 分组交换网络时延的计算传输时延=数据大小/网络带宽由网络带宽、数据大小决定 传播时延=链路长度/传播速度由传播介质、传播速度、链路长度决定 分组交换网的网络拥塞网络拥塞现象：当中间节点（路由器）收到数据的速度大于发出数据的速度时，缓冲将被填满，部分分组将被丢弃，网络出现拥塞。往返时延RTTRTT（Roud-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的确认为止总共经历的时延。RTT反映了分组传输总的时延，使用ping命令可以测量RTT。时延带宽积链路的时延带宽积又称为以比特为单位的链路长度。 时延带宽积 = 传播时延 x 带宽]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述（一）]]></title>
    <url>%2F2020%2F01%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[计算机网络 = 通信技术 + 计算机技术 计算机网络是通信技术海域计算机技术紧密结合的产物 计算机网络就是一种通信网络什么是计算机网络？广义的计算机网络定义：在协议控制下，由一台或多台计算机、若干台终端设备、数据传输设备，以及用于终端和计算机之间、或者若干台计算机之间数据流动的通信控制处理机组成的系统的集合。计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备（交换机、路由器等）与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。计算机网络就是互连的、自治的计算机集合（公认的概念） 自治-无主从关系 ： 一台计算机不能控制另一台计算机互连-互联互通 ：通过通信链路—》网络中两个节点之间的物理通道称为通信链路。通信链路的传输介质主要有双绞线、光纤和微波。 计算机网络的发展20世纪60年代：分组交换思想的提出，可能比世界上第一个网络的意义更加重大，它使得网络传输数据成为可能，并一直沿用到今天。 20世纪70~80年代：TCP/IP协议思想的提出，提供了这样一种可能：即不同厂商生产的计算机，不同结构的网络间实现互通。所以它既是一个协议簇，更是一种标准，它使得网络飞速向前发展。 20世纪90年代：Web技术真正把网络引入民用行业，使得网络行业生机勃勃，飞速发展。随着网络的逐步普及，网络用户在这个时期飞速增长，现如今各行各业都已经离不开网络 计算机网络的功能数据通信：数据通信是计算机网络最基本、最重要的功能，包括连接控制，传输控制，差错控制，流量控制，路由选择，多路复用等子功能。资源共享：包括硬件资源、软件资源和数据资源。分布式处理：当计算机网络中的某个计算机负荷过重时，可以将其处理的任务传送给网络中的其他计算机系统进行处理，利用空闲计算机资源提高整个系统的利用率。典型的有Hadoop平台。提高可靠性：计算机网络中的每台计算机可以通过网络互为替代机，一台计算机宕机了可有另一台计算机替代。负载均衡：将工作任务均衡地分配给计算机网络中的各台计算机。 计算机网络的组成物理组成（硬件、软件、协议三大部分） 1、硬件：由主机、通信处理机、通信线路（包括有线线路和无线线路）和交换设备（交换机等连接设备）组成。 2、软件：主要包括实现资源共享的软件和方便用户使用的各种工具软件（如QQ）。 3、协议：就是一种规则，如汽车在道路上行驶必须遵循交通规则一样，数据在线路上传输也必须遵循一定的规则。工作方式组成（边缘部分、核心部分）1、边缘部分：由所有链接在互联网上，供用户直接使用的主机组成，用来进行通信和资源共享—》C/S方式、P2P方式。2、核心部分：由大量的网络和链接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。 功能组成（通信子网、资源子网） 1、通信子网：由各种传输介质、通信设备和相应的网络协议组成，为网络提供数据传输、交换和控制能力，实现联网计算机之间的数据通信。包括网络层、数据链路层、物理层 2、资源子网：由主机、终端以及各种软件资源、信息资源组成，负责全网的数据处理业务，向网络用户提供各种网络资源和服务。包括应用层、表示层、会话层 局域网（Local Area Network, LAN）：一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网络。包括以太网、令牌环网等。当前的局域网主流是以太网。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。 域域网（Metropolitan Area Network，MAN）：一种介于局域网与广域网之间，覆盖一个城市的地理范围，用来将同一区域内的多个局域网互连起来的中等范围的计算机网络。这些网络通常涵盖一个大学校园或一座城市。MAN的一个重要用途是用作骨干网，通过它将位于同一城市内不同地点的主机、数据库，以及LAN等互相联接起来。 广域网（Wide Area Network，WAN）：一种用来实现不同地区的局域网或域域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网络。所覆盖的范围从几十公里到几千里。它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring中注解大全]]></title>
    <url>%2F2019%2F11%2F30%2FSpring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8%20%2F</url>
    <content type="text"><![CDATA[@Controller标识一个该类是Spring MVC controller 处理器，用来创建处理http请求的对象1234567@Controllerpublic class TestController&#123; @RequestMapping("test") public String test(Map&lt;String,Object&gt; map)&#123; return "hello"; &#125;&#125; @RestControllerSpring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@RestController，默认返回json格式。 1234567@RestControllerpublic class TestController&#123; @RequestMapping("/test") public String test(Map&lt;String,Object&gt; map)&#123; return "hello"; &#125;&#125; @Service用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中 @Autowired用来装配bean，都可以写在字段上，或者方法上。 默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired（required=false） @RequestMapping类定义处：提供初步的请求映射信息，相对于WEB应用的根目录。 方法处：提供进一步的细分映射信息，相对于类定义处的URL。 @RequestParam用于将请求参数区数据映射到功能处理方法的参数上 123public Resp test(@RequestParam Integer id)&#123; return Resp.success(customerInfoService.fetch(id));&#125; 这个id就是要接收从接口传递过来的参数id的值的，如果传递过来的参数名和接收的不一致，也可以如下 123public Resp test(@RequestParam(value="course_id") Integer id)&#123; return Resp.success(customerInfoService.fetch(id));&#125; 其中course_id就是接口传递的参数，id即使映射course_id的参数名 @ModelAttribute1、标记在方法上 标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。 A、在有返回的方法上： 当ModelAttribute设置了value，方法返回的值会以这个value为key，以参数接受到的值作为value，存入到Model中，如下面的方法执行之后，最终相当于model.addAttribute（“user_name”，name）;假如 @model.addAtrribute没有自定义value，则相当于model.addAttribute（“name”，name）； 12345@ModelAttribute(value="user_name")public String before2(@RequestParam(required = false) String name,Model model)&#123; System.out.println("进入了2，" + name); return name;&#125; B、在没返回的方法上： 需要手动model.add方法 12345@ModelAttributepublic void before(@RequestParam(required = false) Integer age, Model model)&#123; model.addAttribute("age",age); System.out.println("进入了1：" + age);&#125; 我们在当前类下建一个请求方法： 1234567891011@RequestMapping(value = "/mod")public Resp mod( @RequestParam(required = false) String name; @RequestParam(required = false) Integer age; Model model)&#123; System.out.println("进入mod"); System.out.println("参数接受的数值&#123;name="+name+";age="+age+"&#125;"); System.out.println("model传过来的值：" + model); return Resp.success("1"); &#125;) 在浏览器中输入访问地址并且加上参数： http://localhost:8080/api/test/mod?name = 我是哈哈 &amp; age = 12 最终输出 12345进入了1：:40进入了2：我是哈哈进入mod参数接受的数值(name = 我是哈哈， age = 18)model传来的值：&#123;age = 40, user_name = 我是哈哈 &#125; 2、标记在方法的参数上 标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。我们在上面的类中加入一个方法如下 1234567891011@RequestMapping(value="/mod2")public Resp mod2(@ModelAttribute("user_name") String user_name, @ModelAttribute("name") String name, @ModelAttribute("age") Integer age, Model model)&#123; System.out.println("进入mod2"); System.out.println("user_name:" + user_name); System.out.println("name:" + name); System.out.println("age:" + age); System.out.println("model:" + model); return Resp.success("1"); &#125; 在浏览器中输入访问地址并且加上参数： http://localhost:8080/api/test/mod2?name = 我是哈哈 &amp; age = 12 最终输出 1234567进入了1：40进入了2：我是哈哈进入了mod2user_name：我是哈哈name：我是哈哈age：40model:&#123;user_name = 我是哈哈，org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, age=40, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: 0 errors&#125;&#125; 从结果可以看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。 @Cacheable用来标记缓存查询。可用用于方法或者类中 当标记在一个方法上时表示该方法是支持缓存的， 当标记在一个类上时则表示该类所有的方法都是支持缓存的。比如@Cacheable(value=”UserCache”) 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。 但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义. 1234567@Cacheable(value="UserCache")// 使用了一个缓存名叫 accountCache public Account getUserAge(int id) &#123; //这里不用写缓存的逻辑，直接按正常业务逻辑走即可， //缓存通过切面自动切入 int age=getUser(id); return age; &#125; @CacheEvict用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。@CacheEvict(value=”UserCache”) @Resource@Resource的作用相当于@Autowired 只不过@Autowired按byType自动注入， 而@Resource默认按 byName自动注入罢了。 @Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序: 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； @PostConstruct用来标记是在项目启动的时候执行这个方法。用来修饰一个非静态的void()方法 也就是spring容器启动时就执行，多用于一些全局配置、数据字典之类的加载 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行,init()方法之前执行。PreDestroy（）方法在destroy()方法执行执行之后执行 @PreDestroy被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前 @Repository用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注 @Scope用来配置 spring bean 的作用域，它标识 bean 的作用域。 默认值是单例 singleton:单例模式,全局有且仅有一个实例 prototype:原型模式,每次获取Bean的时候会有一个新的实例 request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效 global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。 @SessionAttributes默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中 参数： names：这是一个字符串数组。里面应写需要存储到session中数据的名称。 types：根据指定参数的类型，将模型中对应类型的参数存储到session中 value：和names是一样的。 12345678910@Controller @SessionAttributes(value=&#123;"names"&#125;,types=&#123;Integer.class&#125;) public class ScopeService &#123; @RequestMapping("/testSession") public String test(Map&lt;String,Object&gt; map)&#123; map.put("names", Arrays.asList("a","b","c")); map.put("age", 12); return "hello"; &#125; &#125; @Required适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。 @Qualifier当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（三）线程的互斥与同步机制]]></title>
    <url>%2F2019%2F10%2F07%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[线程的互斥与同步机制一、互斥为何需要引入互斥机制？ 当多个线程对同一数据并发读写（至少有一个线程执行写操作）时，这种情形被称为竞争。竞争会导致数据读或写的不确定性。而有时这种不确定性是不可容忍的。 如何实现互斥？ 在并发程序设计中，通常使用锁机制来实现互斥 1、由用户标记必须原子执行的代码段，即使用synchronized关键字 2、给资源一把配有自动机制的锁 【注意】： Java将资源限定为引用型对象，并为每一对象自动配备一把锁：锁初始时处于打开状态。synchronized标记的原子代码段在访问资源前，会自动检测资源对象持有的锁是否处于打开状态。若是，则占用并同时将锁置为锁闭态，并在该代码段执行完毕后。将锁的状态值为打开态；若否，则持有该代码的线程因等待资源占用而进入阻塞态。 • 只有对象才有锁，对基本类型的数据，无法实现线程的互斥访问。 • 对于未使用synchronized标记的代码，锁机制不起作用。 • 无论正常结束还是异常退出，都将自动释放锁。 死锁和活锁 死锁：就是多个线程对临界资源的循环等待，使得这些线程均都无法获得执行。 例如：A，B，C三个线程分别占用D1、D2、D3三个临界资源，A只有获得B占用的资源D2,方能继续运行；而B只有获得C占用的资源D3，方能继续运行；C只有获得A占用的资源D1，方能继续运行。这样，A,B,C处在对资源的循环等待状态，均无法前进。 活锁：也称饥饿。就是某线程虽有执行的资格，但由于某种原因总是得不到执行。 例如：A,B,C三个线程循环访问临界资源D，但A，B的优先级相同，但均高于C。由于Java的抢占式策略，C线程可能总得不到执行。 二、同步同步（Sync） 多个线程的运行满足特定的节奏 所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 根据这个定义，Java中所有方法都是同步调用，应为必须要等到结果后才会继续执行。我们在说同步、异步的时候，一般而言是特指那些需要其他端协作或者需要一定时间完成的任务。 简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。 异步（Async） 多个线程的运行相互独立，彼此间无依赖性 异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。 举个例子简单说明下两者的区别： 同步：火车站多个窗口卖火车票，假设A窗口当卖第288张时，在这个短暂的过程中，其他窗口都不能卖这张票，也不能继续往下卖，必须这张票处理完其他窗口才能继续卖票。直白点说就是当你看见程序里出现synchronized这个关键字，将任务锁起来，当某个线程进来时，不能让其他线程继续进来，那就代表是同步了。 异步：当我们用手机下载某个视频时，我们大多数人都不会一直等着这个视频下载完，而是在下载的过程看看手机里的其他东西，比如用qq或者是微信聊聊天，这种的就是异步，你执行你的，我执行我的，互不干扰。比如上面卖火车票，如果多个窗口之间互不影响，我行我素，A窗口卖到第288张了，B窗口不管A窗口，自己也卖第288张票，那显然会出错了。 并发 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。 并行 在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事 件之间不一定要同一时刻发生。 *Java的同步机制 = 存取共享资源的互斥机制 + 线程间的通信机制* 用于线程通信的方法存在于Object类中，包括wait()、notify()、notifyAll()。wait()会暂停当前线程的执行，并释放所持有的锁，进入等待状态；notify()操作将唤醒一个等待的线程；notifyAll()将唤醒所有等待的进程。 【注意】 wait()、notify()、notifyAll()都是final方法，不允许被重写；这些方法只能直接或间接地用于临界区中，否则，将会产生非法监控锁状态异常。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（二）线程的构造和运行]]></title>
    <url>%2F2019%2F10%2F07%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[① 用Thread类构造线程对象（继承Thread类来创建并启动多线程） 123456789101112131415161718192021222324252627282930313233343536373839package cn.sxt.thread;/** * 创建线程方式一： * 1、创建：继承Thread+重写run * 2、启动：创建子类对象+start * @author 1979 * */public class StartThread extends Thread&#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println("一边听歌"); &#125; &#125; public static void main(String[] args) &#123; /* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程 * for(int i=0;i&lt;20;i++) &#123; * System.out.println("一边coding"); * &#125; */ //创建子类对象 StartThread st = new StartThread(); //启动 st.start();//不保证立即运行 由cpu调用 //st.run();//普通方法调用，只能听完歌再敲代码 for(int i=0;i&lt;20;i++) &#123; System.out.println("一边coding"); &#125; &#125;&#125; 【运行结果】 12345678一边coding一边coding...一边听歌一边听歌...一边coding一边coding 【缺点】：由于java采用单继承机制，若为实现多线程而继承了Thread，将无法再继承其他类，是非常不明智的做法。 ② 用Runnable辅助构造线程（实现Runnable接口创建线程类） 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.sxt.thread;/*** * 创建线程方式二 * 1、创建：实现Runnable+重写run * 2、启动：创建实现类对象+Thread对象+start * * 推荐：避免单继承的局限性，优先使用接口 * 方便共享资源 * @author 1979 * */public class StartRun implements Runnable&#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println("一边听歌"); &#125; &#125; public static void main(String[] args) &#123; /* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程 * for(int i=0;i&lt;20;i++) &#123; * System.out.println("一边coding"); * &#125; */ //创建实现类对象 StartRun sr = new StartRun(); //创建代理类对象 Thread t = new Thread(sr); //启动 t.start();//不保证立即运行 由cpu调用 //st.run();//普通方法调用，只能听完歌再敲代码 for(int i=0;i&lt;20;i++) &#123; System.out.println("一边coding"); &#125; &#125;&#125; 【运行结果】 12345678一边coding一边coding...一边听歌一边听歌...一边coding一边coding 12345678910111213141516171819202122232425262728293031323334353637383940package liti_07;/*本例展现这样一种方式：利用Runnable接口直接构造线程并运行 *有如下关键点： *1、希望该类中创建线程对象，就必须有线程成员，即私有变量t; *2、在构造函数中构造t引用的线程对象，注意把自己作为参数传给t; *3、还需要启动线程。由于t长设为私有，故不能直接t.start()， * 需要设置其他方法，如本例另提供一个公共的start()方法。 **/public class Ch_7_3 implements Runnable&#123; public static void main (String[] args) &#123; System.out.print("Main 开始"); Ch_7_3 m1=new Ch_7_3(1,"奇数线程"); //注意，m1依旧不是线程对象 Ch_7_3 m2=new Ch_7_3(2,"偶数线程"); m1.start(); //注意，调用的是类R自己定义的start() m2.start(); System.out.print("当前共有"+ Thread.activeCount()+"个线程"); System.out.print("Main 结束"); &#125; private int d; private Thread t; //-----新增成员 public void start()&#123; t.start(); &#125; //-----关键点2 public Ch_7_3(int x, String s)&#123; d=x; //t=new Thread(this); t.setName(s); //----关键点1 t=new Thread(this,s); &#125; public void run()&#123; for(int i=d; i&lt;50;i=i+2) System.out.print(" "+i); //Thread t=Thread.currentThread(); //---此句不再需要 System.out.print(t.getName()+"结束！"); &#125; &#125; 线程的一些常用方法 1、currentThread() 返回对当前正在执行的线程对象的引用。 2、getId() 返回此线程的标识符 3、getName() 返回此线程的名称 4、getPriority() 返回此线程的优先级 5、isAlive() 测试这个线程是否还处于活动状态。 什么是活动状态呢？ 活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。 6、sleep(long millis) 使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。 7、interrupt() 中断这个线程。 8、interrupted() 和isInterrupted() interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能 isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但不清楚状态标志 9、 setName(String name) 将此线程的名称更改为等于参数 name 。 10、isDaemon() 测试这个线程是否是守护线程。 11、setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程。 12、join() 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。 join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行 13、yield() yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。 14、setPriority(int newPriority) 更改此线程的优先级]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3分钟教你Hexo如何绑定个人域名]]></title>
    <url>%2F2019%2F10%2F06%2FHexo%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[前两天用Hexo+GitHub搭建好了自己的个人博客http://tsundere-x.top/ ，默认域名github下的二级域名：username.github.io，为了提升访问速度和博客的格调，绑定个人域名是多数人的选择。下面给大家介绍详细过程。 购买域名 国内有很多不错的域名服务商，这里我给大家推荐阿里云的万网。我购买的域名是：tsundere-x.top。 大家可以根据自身的需求购买相应的域名。点击查域名后确认域名没有被使用后即可下单购买，当然在付款之前你还需要进行邮箱验证和实名认证（虽然上面提示实名认证需要3-5天，但正常情况下其实只要一个小时左右）。 实名认证通过后进行域名解析 在此之前需要获取自己 github 的二级域名的 IP地址 。cmd下ping+自己博客的地址即可获得。 实名认证后来到域名控制台，点击解析。 进入新手指导，将得到的 IP 地址填到记录值一栏 即可。 仓库的custom domain绑定域名 进入仓库中， 点击 setting 往下滑 会看到custom domain 将自己购买的域名填写进去 。 最后一步，设置CNAME 进入Hexo根目录下的source文件夹，新建CNAME文件（文件！！！，不需要任何后缀）。 接下来 使用 hexo d -g 重新部署，就可以成功访问咯！]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（一）]]></title>
    <url>%2F2019%2F10%2F05%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%E3%80%81Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1 程序、进程、线程之间的区别与联系 三者之间的形象化理解： * 程序：代码实现了功能，就是程序，是静态的； * 进程：执行中的程序就是进程，是动态的； * 线程：进程内的一个执行单元,也是进程内的可调度实体，可以并发执行提高了进程的效率。 进程和线程的关系：（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。（3）处理机分给线程，即真正在处理机上运行的是线程。（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 线程与进程的区别: (1) 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 。 (2) 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 。 (3) 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。 (4) 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 程序与进程的区别：程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。 程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。 进程更能真实地描述并发，而程序不能；进程是由程序和数据两部分组成的。进程具有创建其他进程的功能，而程序没有。 同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程。也就是说同一程序可以对应多个进程。 2 Java的线程状态和生命周期) ==新建状态:==使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 ==就绪状态:==当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 ==运行状态:==如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 ==阻塞状态:==如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O处理完毕，线程重新转入就绪状态。 ==死亡状态:==一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this和super的用法总结]]></title>
    <url>%2F2019%2F10%2F04%2FJava%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[this this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this 的用法在 Java 中大体可以分为3种： 1.普通的直接引用 this 相当于是指向当前对象本身。 2.形参与成员名字重名，用 this 来区分：123456789101112131415161718class Person &#123; private int age = 10; public Person()&#123; System.out.println("初始化年龄："+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println("Harry's age is "+Harry.GetAge(12)); &#125;&#125; 运行结果： 1初始化年龄：10 Harry&apos;s age is 12 可以看到，这里 age 是 GetAge 成员方法的形参，this.age 是 Person 类的成员变量。 3.引用构造函数supersuper 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super 也有三种用法： 1.普通的直接引用与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员。 2.子类中的成员变量或方法与父类中的成员变量或方法同名123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = "China"; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = "Shanghai"; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 运行结果： 1Shanghai China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法 value()，只调用父类变量 name 的话，则父类 name 值为默认值 null。 3.引用构造函数 super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 123456789101112131415161718192021222324252627282930313233343536class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt("父类·无参数构造方法： "+"A Person."); &#125;//构造方法(1) Person(String name) &#123; prt("父类·含一个参数的构造方法： "+"A person's name is " + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt("子类·调用父类"无参数构造方法"： "+"A chinese coder."); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt("子类·调用父类"含一个参数的构造方法"： "+"his name is " + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt("子类：调用子类具有相同形参的构造方法：his age is " + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese("codersai"); cn = new Chinese("codersai", 18); &#125; &#125; 运行结果： 1234567父类·无参数构造方法： A Person.子类·调用父类”无参数构造方法“： A chinese coder.父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用 super 和 this 分别调用父类的构造方法和本类中其他形式的构造方法。 例子中 Chinese 类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 ==super 和 this 的异同== super(参数)：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this(参数)：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。 super() 和 this() 均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static 方法，static 语句块。 从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
