<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【操作系统复习】中断和异常]]></title>
    <url>%2F2021%2F03%2F10%2F%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[@TOC一、中断机制的诞生:tipping_hand_woman: 早期的计算机：各程序只能串行执行，系统资源利用率低为了解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。本质：发生中断就意味着需要操作系统介入，开展工作。二、中断的概念和作用1、当中断发生时，CPU立即进入核心态 2、当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理 3、对于不同的中断信号，会进行不同的处理 :deciduous_tree: 由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。有了中断，才能实现多道程序并发执行。 :question: 用户态、核心态之间的切换是怎么实现的？ :arrow_forward: “ 用户态 –&gt; 核心态 ” 是通过中断实现，并且中断是==唯一==途径。 :arrow_forward: “ 核心态 –&gt; 用户态 ” 的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为用户态。 三、中断的分类 四、外中断的处理过程1、执行完每个指令之后，CPU都要检查当前是否有外部中断信号 2、如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器） 3、根据中断信号类型转入相应的中断处理程序 4、恢复原进程的CPU环境并退出中断，返回原进程继续往下执行 的CPU环境并退出中断，返回原进程继续往下执行]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客 16499 解方程 （数学、Python）]]></title>
    <url>%2F2021%2F03%2F09%2F%E7%89%9B%E5%AE%A2%2016499%20%E8%A7%A3%E6%96%B9%E7%A8%8B%20%EF%BC%88%E6%95%B0%E5%AD%A6%E3%80%81Python%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/16499来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述 已知多项式方程：a0+a1x+a2x^2^+…+anx^n^=0求这个方程在[1, m]内的整数解（n和m均为正整数）。 输入描述: 第一行包含2个整数n、m，每两个整数之间用一个空格隔开。接下来的n+1行每行包含一个整数，依次为a0,a1,a2,……,an。 输出描述: 第一行输出方程在[1, m]内的整数解的个数。接下来每行一个整数，按照从小到大的顺序依次输出方程在[1, m]内的一个整数解。 枚举1~m中的所有整数，代入多项式，判断值是否为0 求一元n次多项式可以用到秦九韶算法但还是会超时，只能得70分 1234567891011121314151617n, m = list(map(int, input().split()))a = []mod = 1000000007for i in range (n+1): a.append(int(input())%mod)res = []for i in range (1, m+1): ans = a[n] for j in range (n-1,-1,-1): ans = (ans*i + a[j])%mod if ans == 0: res.append(i)print(len(res))res.sort()for i in res: print(i)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客 13822 Keep In Line（枚举与暴力、Python）]]></title>
    <url>%2F2021%2F03%2F09%2F%E7%89%9B%E5%AE%A2%2013822%20Keep%20In%20Line%EF%BC%88%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%9A%B4%E5%8A%9B%E3%80%81Python%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/13822来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 262144K，其他语言524288K64bit IO Format: %lld题目描述 又到饭点了，SK同学靠着惯性走到了食堂，但长长的队伍顿时让他失去了食欲。突然，他注意到某个窗口前的队伍里明显存在插队的现象，于是他默默记录下了同学们进队和出队的变化。对于进队，SK同学只知道队伍里多了一个人，并不知道新来的人是老老实实站到了队尾还是插到了队伍里的某个位置；对于出队，SK同学能确定是队伍里站在最前面的人出队了。初始时队伍为空，给出n条队伍进出的信息，保证已经出队的同学不会再入队，并且最终队伍也为空，现在SK同学想知道有多少不插队的好同学。 输入描述: 第一行是一个正整数T(≤ 5)，表示测试数据的组数， 对于每组测试数据， 第一行是一个整数n(1≤ n ≤ 100000)，表示这个队伍进出的信息数， 接下来n行，每行是两个字符串Opt Name，其中Opt为”in”代表进队，”out”代表出队，Name为进队或出队的人的名字， 所有信息按照时间顺序给出，名字由英文字母和阿拉伯数字组成，长度不超过10，保证每个人的名字各不相同。 输出描述: 对于每组测试数据，输出一行，包含一个整数，表示不插队的人数。 1234567891011121314示例1输入16in quailtyin hwq1352249out hwq1352249in zhuaiballlout quailtyout zhuaiballl输出2 1234首先建一个队列，里面按照入队顺序存放字符串。然后等读入出队信息的时候，如果出队是正常出队，ans++，就直接删除队首元素，如果不是正常出队，并利用map标记此字符串为1，遇到队首元素标记为1的直接出队。最后输出ans。 1234567891011121314151617181920T = int(input())for i in range(T): n = int(input()) queue = [] jumpers = &#123;&#125; ans = 0 for j in range(n): s = input().split(" ") if s[0] == 'in': queue.append(s[1]) else: while queue[0] in jumpers: del queue[0] if queue[0] != s[1]: jumpers[s[1]] = 1 else: del queue[0] ans += 1 print(ans)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客 21302 被3整除的子序列 （动态规划、Python）]]></title>
    <url>%2F2021%2F03%2F09%2F%E7%89%9B%E5%AE%A2%2021302%20%E8%A2%AB3%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%20%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81Python%EF%BC%89%2F</url>
    <content type="text"><![CDATA[时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 524288K，其他语言1048576K64bit IO Format: %lld链接：https://ac.nowcoder.com/acm/problem/21302来源：牛客网题目描述 给你一个长度为50的数字串,问你有多少个子序列构成的数字可以被3整除答案对1e9+7取模 输入描述: 输入一个字符串，由数字构成，长度小于等于50 输出描述: 输出一个整数 1234567891011121314151617181920212223242526272829303132333435示例1输入132输出3示例2输入9输出1示例3输入333输出7示例4输入123456输出23示例5输入00输出3备注:n为长度子任务1: n &lt;= 5子任务2: n &lt;= 20子任务3: 无限制 动态转移方程为： dp[i][j] += (dp[i-1][j] + dp[i-1][(j+3-m)%3]) % mod 12345678910s = input()mod = 1000000007dp = [[0] * 3 for _ in range (51)]for i in range (1, len(s)+1): m = int(s[i-1])%3 dp[i][m] = 1 for j in range (3): dp[i][j] += (dp[i-1][j] + dp[i-1][(j+3-m)%3]) % modprint(dp[len(s)][0])]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 670 最大交换 （暴力+贪心、Python）]]></title>
    <url>%2F2021%2F03%2F09%2FLeetCode%20670%20%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2%20%EF%BC%88%E6%9A%B4%E5%8A%9B%2B%E8%B4%AA%E5%BF%83%E3%80%81Python%EF%BC%89%2F</url>
    <content type="text"><![CDATA[来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-swap问题描述给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。123456789101112131415示例 1 :输入: 2736输出: 7236解释: 交换数字2和数字7。示例 2 :输入: 9973输出: 9973解释: 不需要交换。注意:给定数字的范围是 [0, 108] 方法一：暴力法 两重循环，每次交换两个相邻的数，取最大值。 12345678910111213T = int(input())for i in range (T): res = "" a = input() res = int(a) for i in range (len(a)): for j in range (i+1, len(a)): b = list(a) b[i], b[j] = b[j], b[i] m = int(''.join(b)) res = max(res, m) print(res) 方法二：贪心算法 我们将计算 last[d] = i，最后一次出现的数字 d（如果存在）的索引i。 然后，从左到右扫描数字时，如果将来有较大的数字，我们将用最大的数字交换；如果有多个这样的数字，我们将用最开始遇到的数字交换。 12345678910111213141516171819202122T = int(input())def fu(a): t = list(a) pos = [0 for _ in range (10)] # 记录每个数字出现的最后一次出现的下标 for i in range (len(a)): pos[int(a[i])] = i # 从左向右扫描，找到当前位置右边的最大的数字并交换 for i in range (len(a)-1): # 找最大，所以倒着找 for j in range (9, int(t[i]), -1): if pos[j] &gt; i: t[pos[j]], t[i] = t[i], t[pos[j]] # 只允许交换一次，因此直接返回 return int(''.join(t)) return a for v in range (T): a = input() res = fu(a) print(res)]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【操作系统复习】操作系统的运行机制与体系结构]]></title>
    <url>%2F2021%2F03%2F08%2F%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[@TOC一、两种指令、两种处理器状态、两种程序:tipping_hand_woman: ” 指令 ” 就是处理器（CPU）能识别、执行的最基本命令 特权指令： 如内存清零指令 –&gt; 不允许用户程序使用。 非特权指令： 如普通的运算指令 :grey_question: CPU如何判断当前是否可以执行特权指令？ 用程序状态寄存器（PSW）中的某标志位来标识当前处理器处于什么状态，如0为用户态，1为核心态。 用户态（目态）： 此时CPU只能执行非特权指令 核心态（管态）：特权指令、非特权指令都可以执行 :arrow_right: 两种程序 内核程序： 操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。 应用程序： 为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。 二、操作系统的内核内核 ：计算机上配置的 底层软件，是操作系统最基本、最核心的部分。 实现操作系统内核功能的那些程序就是==内核程序==。 时钟管理： 实现计时功能 中断处理： 负责实现中断机制 原语 是一种特殊的程序 处于操作系统最底层，是最接近硬件的部分 这种程序的运行具有原子性 —— 其运行只能一气呵成，不可中断 运行时间较短，调用频繁 对系统资源进行管理的功能 （有的操作系统不把这部分功能归为 “ 内核功能 ”。也就是说不同的操作系统，对内核功能的划分可能并不一样） 进程管理 存储器管理 设备管理 三、操作系统的体系结构 大内核 将操作系统的主要功能模块都作为系统内核，运行在核心态 优点：高性能 缺点：内核代码庞大，结构混乱，难以维护 微内核 只把最基本的功能保留在内核 优点：内核功能少，结构清晰，方便维护 缺点：需要频繁地在核心态和用户态之间切换，性能低]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【操作系统复习】操作系统的发展与分类]]></title>
    <url>%2F2021%2F03%2F08%2F%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[@TOC一、手工操作阶段过程： 用户把程序写在纸带上（其实就是在纸带上打孔），然后输入到计算机中，计算机随后会处理这个程序，把输出结果又放在纸带中（其实还是打孔），展示给用户看。由于用户在纸带上编写程序的速度很慢，纸带输入输出的速度也很慢，而计算机的处理速度快，所以系统资源的利用率极低。主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低 二、批处理阶段 —— 单道批处理系统引入脱机输入/输出技术（用磁带完成），并使用监督程序（操作系统的雏形）负责控制作业的输入、输出。 由于磁带录入到处理器中的速度比纸带快得多，所以单道批处理系统一定程序上缓和了人机速度矛盾，资源利用率有所提升。 主要优点： 缓解了一定程度的人机速度矛盾，资源利用率有所提升。 主要缺点： 内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。 三、批处理阶段 —— 多道批处理系统:camping: 每次往内存中输入多道程序，==操作系统正式诞生==，并引入了中断技术，由操作系统负责管理这些程序的运行。各个程序并发执行。 主要优点： 多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。 主要缺点： 用户响应时间长，没有人机交互功能（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行） :chestnut: 假设计算机需要处理三个作业： 作业一：输入1秒，计算1秒，输出1秒 作业二：输入1秒，计算1秒，输出1秒 作业三：输入1秒，计算1秒，输出1秒 采用单道批处理技术 采用多道批处理技术 四、分时操作系统计算机以==时间片==为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。 主要优点： 用户请求可以被即时响应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。 主要缺点： 不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。 五、实时操作系统在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是==及时性和可靠性==。 主要优点： 能够优先响应一些紧急任务，某些紧急任务不需时间片排队。 六、其他操作系统网络操作系统、分布式操作系统、个人计算机操作系统]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蓝桥杯 历届试题 小数第n位]]></title>
    <url>%2F2021%2F03%2F08%2F%E8%93%9D%E6%A1%A5%E6%9D%AF%20%E5%8E%86%E5%B1%8A%E8%AF%95%E9%A2%98%20%E5%B0%8F%E6%95%B0%E7%AC%ACn%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[资源限制时间限制：1.0s 内存限制：256.0MB问题描述 我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。 如果我们把有限小数的末尾加上无限多个0，它们就有了统一的形式。 本题的任务是：在上面的约定下，求整数除法小数点后的第n位开始的3位数。 输入格式 一行三个整数：a b n，用空格分开。a是被除数，b是除数，n是所求的小数后位置（0&lt;a,b,n&lt;1000000000） 输出格式 一行3位数字，表示：a除以b，小数后第n位开始的3位数字。 1234567891011121314样例输入1 8 1样例输出125样例输入1 8 3样例输出500样例输入282866 999000 6样例输出914 思路：问题可转化为 a / b * 10^n+2^ % 1000 需要用下面的公式： x/d%m = x%(d*m)/d 在求解10^n+2^时，用快速幂求解即可 123456789101112131415def qpower(a, b, mod): base = a ans = 1 while b: if b&amp;1: ans = ((ans%mod)*(base%mod))%mod base = (base%mod)*(base%mod) b &gt;&gt;= 1 return ansa, b, n = list(map(int, input().split()))mod = b*1000c = qpower(10, n+2, mod)res = (a%mod*c%mod)%modprint(res//b)]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【操作系统复习】操作系统的特征]]></title>
    <url>%2F2021%2F03%2F08%2F%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81%2F</url>
    <content type="text"><![CDATA[@[TOC]一、并发并发 ：指两个或多个事件在同一时间间隔内发生。这些事件==宏观上是同时发生==的，但==微观上是交替发生==的。并行：指两个或多个事件在同一时刻同时发生。操作系统的并发性指计算机系统中同时存在着多个运行着的程序。一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但宏观上看起来就像是在同时执行） 事实上，操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的。 二、共享共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。 所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享） :mag_right: 互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。 :mag_right: 同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。 💁 并发和共享的关系 （互为存在条件） 通过上述例子来看并发与共享的关系： 使用QQ发送文件A，同时使用微信发送文件B。 １、两个进程正在并发执行（并发性） 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义 ２、需要共享地访问硬盘资源（共享性） 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。 三、虚拟虚拟：指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。 :chestnut: 例子一 某游戏需要４GB的运行内存，QQ需要256MB的内存，迅雷需要256MB的内存，网易云音乐需要256MB的内存…… 我的电脑：4GB内存 ❓ 这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？ :arrow_forward: 这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB。这里用到的是虚拟技术中的“==时分复用技术==”。 🌰 例子二 某单核CPU的计算机中，用户打开了QQ、谷歌浏览器、QQ音乐等 :question: 既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU的电脑中能同时运行这么多个程序呢？ ▶️ 这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有6个CPU在同时为自己服务。这里用到的是虚拟技术中的“==时分复用技术==”。微观上处理机在各个微小的时间段内交替着为各个进程服务。 四、异步异步： 指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。 显然，如果失去了并发性，则系统只能串行地处理各个进程，每个进程地执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。 :balloon: 没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【操作系统复习】操作系统的概念、功能和目标]]></title>
    <url>%2F2021%2F03%2F07%2F%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[@[toc]一、概念:heavy_check_mark: 操作系统（Operating System，OS）：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的==系统软件==。二、操作系统的功能和目标 2.1 作为系统资源的管理者 :star2: 进程是一个程序的执行过程。执行前 需要将该程序放到内存中，才能被CPU处理。 :chestnut: 举一个生活中的例子（用QQ和朋友视频聊天的过程）： Step1：在各个文件夹中找到QQ安装的位置 —&gt; 逐层打开文件夹，找到QQ.exe这个程序（可执行文件）的存放位置； Step2：双击打开QQ.exe —&gt; 需要把该程序相关数据放入内存； Step3：QQ程序正常运行 —&gt; 对应的进程被处理机（CPU）处理； Step4：开始和朋友视频聊天 —&gt; 需要将摄像头设备分配给进程； 2.2 作为用户和计算机硬件之间的接口 命令接口： 允许用户==直接使用== 联机命令接口：用户说一句，系统做一句 = ==交互式==命令接口 脱机命令接口：用户说一堆，系统做一堆 = ==批处理==命令接口 程序接口： 允许用户通过程序==间接使用== 由一组==系统调用==组成（程序接口=系统接口） :paw_prints: 易懵概念： 系统调用 = 系统调用命令 = 广义指令 如：程序员在程序中调用 uesr32.dll 即可实现创建窗口等功能 GUI： 现代操作系统中最流行的图形用户接口 如windows、安卓、iOS、macOS的图形化操作界面 2.3 作为最接近硬件的层次需要提供的功能和目标：实现对硬件机器的拓展 没有任何软件支持的计算机称为==裸机==。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。 通常把覆盖了软件的机器称为==扩充机器==，又称之为==虚拟机==。 能，将裸机改造成功能更强、使用更方便的机器。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter notebook绘制热力图边缘只有一半的问题]]></title>
    <url>%2F2021%2F03%2F01%2FJupyter%20notebook%E7%BB%98%E5%88%B6%E7%83%AD%E5%8A%9B%E5%9B%BE%E8%BE%B9%E7%BC%98%E5%8F%AA%E6%9C%89%E4%B8%80%E5%8D%8A%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[同个人网站 https://www.serendipper-x.cn/，欢迎访问 ！ 添加如下代码： 123bottom, top = ax.get_ylim() ax.set_ylim(bottom + 0.5, top - 0.5)]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 绘制热力图参数详解]]></title>
    <url>%2F2021%2F03%2F01%2FPython%20%E7%BB%98%E5%88%B6%E7%83%AD%E5%8A%9B%E5%9B%BE%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[参数设置：（1）热力图输入数据参数:12345data:矩阵数据集，可以是numpy的数组（array），也可以是pandas的DataFrame。如果是DataFrame，则df的index/column信息会分别对应到heatmap的columns和rows，即pt.index是热力图的行标，pt.columns是热力图的列标 （2）热力图矩阵块颜色参数: 1234567vmax,vmin:分别是热力图的颜色取值最大和最小范围，默认是根据data数据表里的取值确定cmap:从数字到色彩空间的映射，取值是matplotlib包里的colormap名称或颜色对象，或者表示颜色的列表；改参数默认值：根据center参数设定center:数据表取值有差异时，设置热力图的色彩中心对齐值；通过设置center值，可以调整生成的图像颜色的整体深浅；设置center数据时，如果有数据溢出，则手动设置的vmax、vmin会自动改变robust:默认取值False；如果是False，且没设定vmin和vmax的值，热力图的颜色映射范围根据具有鲁棒性的分位数设定，而不是用极值设定 （3）热力图矩阵块注释参数: 12345annot(annotate的缩写):默认取值False；如果是True，在热力图每个方格写入数据；如果是矩阵，在热力图每个方格写入该矩阵对应位置数据fmt:字符串格式代码，矩阵上标识数字的数据格式，比如保留小数点后几位数字annot_kws:默认取值False；如果是True，设置热力图矩阵上数字的大小颜色字体，matplotlib包text类下的字体设置； （4）热力图矩阵块之间间隔及间隔线参数： 123linewidths:定义热力图里“表示两两特征关系的矩阵小块”之间的间隔大小linecolor:切分热力图上每个矩阵小块的线的颜色，默认值是’white’ （5）热力图颜色刻度条参数： 12345cbar:是否在热力图侧边绘制颜色刻度条，默认值是Truecbar_kws:热力图侧边绘制颜色刻度条时，相关字体设置，默认值是Nonecbar_ax:热力图侧边绘制颜色刻度条时，刻度条位置设置，默认值是None （6）square:设置热力图矩阵小块形状： 1234567891011默认值是False xticklabels,yticklabels:xticklabels控制每列标签名的输出；yticklabels控制每行标签名的输出。默认值是auto。如果是True，则以DataFrame的列名作为标签名。如果是False，则不添加行标签名。如果是列表，则标签名改为列表中给的内容。如果是整数K，则在图上每隔K个标签进行一次标注。如果是auto，则自动选择标签的标注间距，将标签名不重叠的部分(或全部)输出 （7）mask:控制某个矩阵块是否显示出来： 12345默认值是None。如果是布尔型的DataFrame，则将DataFrame里True的位置用白色覆盖掉ax:设置作图的坐标轴，一般画多个子图时需要修改不同的子图的该值]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyecharts 绘制地图]]></title>
    <url>%2F2021%2F03%2F01%2Fpyecharts%20%E7%BB%98%E5%88%B6%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031# 导入相关包from pyecharts import options as optsfrom pyecharts.charts import Map, Geo, Lindata = pd.read_csv(r'C:\Users\1979\Desktop\处理后的数据\谷物产量（公吨）（2000-2017）.csv')value = data.iloc[:,18]attr = data.iloc[:,0]# 显示世界地图def map_world() -&gt; Map: c = ( Map(init_opts=opts.InitOpts( # 设置主题 theme='wonderland')) .add("", [list(z) for z in zip(attr, value)], "world",is_map_symbol_show=False) .set_series_opts(label_opts=opts.LabelOpts(is_show=False), itemstyle_opts=&#123;'normal': &#123; 'opacity': 0.6 &#125;&#125; ) .set_global_opts( title_opts=opts.TitleOpts(title="Distribution map of global grain production",pos_right="center",pos_top="1%"), visualmap_opts=opts.VisualMapOpts(max_=710000000,min_=10), ) ) return ccountry_ = map_world()country_.render_notebook()]]></content>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【知识图谱】一、知识表示与知识建模]]></title>
    <url>%2F2021%2F02%2F21%2F%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E3%80%91%E4%B8%80%E3%80%81%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%BB%BA%E6%A8%A1%2F</url>
    <content type="text"><![CDATA[一、早期知识表示简介知识表示的重要性 知识是智能的基础 机器可以获得知识 机器可以运用知识 符合计算机要求的知识模式 计算机能存储、处理的知识表示模式 数据结构（List、Table、Tree、Graph、etc.） 知识的特性 相对正确性 一定条件下 某种环境中 …… 不确定性 存在“中间状态” “真”（“假”）程度 随机性、模糊性、经验性、不完全性 …… 可表示性&amp;可利用性 语言、文字、图形、图像、视频、音频 神经网络 概率图模型 …… 知识分类 常识性知识、领域性知识（范围） 事实性知识、过程性知识、控制性知识（作用及表示） 确定性知识、不确定性知识（确定性） 逻辑性知识、形象性知识（结构及表现形式） 早期知识表示方法 一阶谓词逻辑（First-Order Logic） 产生式规则（Production Rule） 框架（Framework） 语义网络（Semantic Network） 逻辑程序（Logic Programming） 缺省逻辑（Default Logic） 模态逻辑（Modal Logic） 待补……]]></content>
      <tags>
        <tag>知识图谱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典 例题6-6 小球（C、python）]]></title>
    <url>%2F2021%2F02%2F19%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%20%E4%BE%8B%E9%A2%986-6%20%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD%EF%BC%88python%E3%80%81C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述：有一颗二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右编号为 1，2，3，… ，2^D^ - 1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，初始全部关闭，当每次由小球落到一个开关上时，状态都会改变。当小球到达一个内结点时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所示。 一些小球从结点1处下落，最后一个小球将会落到哪里呢？输入叶子深度 D 和小球个数 I，输出第 I 个小球最后所在的叶子编号。假设 I 不超过整棵树的叶子个数，D ≤ 20。 tips:给定一颗包含2^d^个结点（其中d为树的高度）的完全二叉树，如果把结点从上到下从左到右编号为1，2，3……，则结点k的左右子结点编号分别为2k 和 2k+1。 Python: 12345678910111213141516171819while True: try: D, I = list(map(int, input().split())) n = (1&lt;&lt;D) - 1 # n是最大结点编号 s = [False for _ in range (1&lt;&lt;20)] # 初始值都为假 for i in range (I): k = 1 while True: s[k] = ~s[k] # 状态改变 if s[k] == 0: k = 2 * k + 1 else: k = 2 * k if k &gt; n: # 出界 break print (k//2) # 出界之前的叶子编号 except: break C: 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxd = 20;int main() &#123; int D, I; while(scanf("%d%d", &amp;D, &amp;I) == 2) &#123; memset(s, 0, sizeof(s)); int k, n = (1&lt;&lt;D)-1; for(int i = 0; i &lt; I; i++) &#123; k = 1; for(;;) &#123; s[k] = !s[k]; k = s[k] ? k*2 : k*2+1; if(k &gt; n) break; &#125; &#125; printf("%d\n", k/2); &#125; return 0;&#125; 如果使用题目中给的编号 I，则当 I 是奇数时，它是往左走的的第（I+1）/ 2个小球；当 I 是偶数时，它是往右走的第 I/2 个小球。这样，可以直接模拟最后一个小球的路线： 1234567891011121314while(scanf("%d%d", &amp;D, &amp;I) == 2) &#123; int k = 1; for(int i = 0; i &lt; D-1; i++) &#123; if(I%2) &#123; k = k*2; I = (I+1) / 2; &#125; else &#123; k = k*2+1; I /= 2; &#125; printf("%d\n", k) &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典 例题6-2 铁轨（C、python）]]></title>
    <url>%2F2021%2F02%2F19%2F%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%20%E4%BE%8B%E9%A2%986-2%20%E9%93%81%E8%BD%A8%EF%BC%88C%E3%80%81python%EF%BC%89%2F</url>
    <content type="text"><![CDATA[问题描述：某城市有一个火车站，铁轨铺设如图所示。有n节车厢从A方向驶入车站，按进站顺序编号为 1~n 。你的任务是判断是否能让它们按照某种特定的顺序进入 B 方向的铁轨并驶出车站。例如，出栈顺序（5 4 1 2 3）是不可能的，但（5 4 3 2 1）是可能的。为了重组车厢，你可以借助中转站 C。这是一个可以停放任意多节车厢的车站，但由于末端封顶，驶入 C 的车厢必须按照相反的顺序驶出 C。对于每个车厢，一旦从 A 移入 C ，就不能再回到 A 了；一旦从 C 移入 B，就不能回到 C 了。换句话说，在任意时刻，只能由两种选择： A -&gt; C 和 C -&gt; B。 分析： 在这里中转站 C 符合先进后出的原则，可以把它当作是栈。 C: 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;stack&gt;using namespace std;const int MAXN = 1000 + 10;int n, target[MAXN];int main()&#123; while(scanf("%d", &amp;n) == 1)&#123; stack&lt;int&gt; s; int A = 1, B = 1; for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;target[i]); int ok = 1; while(B &lt;= n)&#123; if(A == target[B])&#123; A++;B++; &#125; else if(!s.empty() &amp;&amp; s.top() == target[B])&#123; s.pop();B++; &#125; else if(A &lt;= n) s.push(A++); else&#123; ok = 0; break; &#125; &#125; printf("%s\n", ok ? "Yes" : "No"); &#125; return 0;&#125; Python: 12345678910111213141516171819202122n = int(input())target = list(map(int, input().split())) # 测试队列stack = []ok, A, B = 1, 1, 0while B &lt; n: if A == target[B]: A += 1 B += 1 elif len(stack) != 0 and stack[len(stack)-1] == target[B]: stack.pop() B += 1 elif A &lt;= n: stack.append(A) A += 1 else: ok = 0 breakif ok == 1: print ("Yes")else: print ("No")]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速幂模板（Python）]]></title>
    <url>%2F2021%2F02%2F17%2F%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF%EF%BC%88Python%EF%BC%89%2F</url>
    <content type="text"><![CDATA[首先我们需要知道下面这个公式：(a^b) mod c=((a mod c)^b) mod c现在试着用最常规的方法计算 a^b算法一：123456def spow(n, m): res = 1 for i in range (m): res *= n return resprint(spow(2, 100)) 显然这个算法的时间复杂度为 O(n)，我们需要找到一个复杂度较低的算法。对于幂次运算，例如a^5 如果直接运算，需要5次循环了。 但是如果写成 a^5 = a*((a^2)^2)，如果是这样，就仅仅需要3次运算了，一下子省了两次运算，对于这次次数低的运算都如此可观，对于次数多的运算可想而知了。 对于上面的情况，计算幂的时候，明显需要分情况考虑。 1、当b为偶数的时候，a^b = (a^2)^(b/2)；2、当b为奇数的时候，a^b = a*(a^2)((b-1)/2)。 时间复杂度降到了 O(logn) 算法二： 12345678910def qpow(n, m): res = 1 base = n while m != 0: if (m&amp;1) != 0: res = res*base base = base*base m = m &gt;&gt; 1 return resprint(qpow(2, 100)) 如果要取余 算法三： 1234567891011mod = 1000000007def qpow(n, m): res = 1 base = n while m != 0: if (m&amp;1) != 0: res = res*base%mod base = base*base%mod m = m &gt;&gt; 1 return resprint(qpow(2, 100))]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16732 序列（排列组合）]]></title>
    <url>%2F2021%2F02%2F17%2F%E7%89%9B%E5%AE%A216732%20%E5%BA%8F%E5%88%97%EF%BC%88%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/16732来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 262144K，其他语言524288K64bit IO Format: %lld题目描述 有一个长度为n的序列a，已知a[1]=a[n]=1，且对于2 &lt;= x &lt;= n，a[x] / a[x-1]是以下三个数字之一 [ 1，-2，0.5 ],问有多少种不同的序列满足题意。两个序列不同当且仅当它们有至少一个位置上的数字不同，序列a可以为任何实数。 输入描述: 一个整数 表示n (1&lt;= n &lt;= 1e3) 输出描述: 一个整数 表示答案模 10^9^ +7 直接整体来看，a[x] = a[x-1]*[1, -2, 0.5]，那么等于选出n-1个数值相乘 最后答案要是1，所以-2就必须有偶数个，同理0.5的个数要等于-2，顺序无关 12345678910111213n = int(input())import mathMOD = 1000000007def c(m, n): return math.factorial(m) // math.factorial(n) // math.factorial(m - n) % MODans = 0i = 0num = n-1while i &lt;= num // 2: ans = (ans + c(num, i) * c(num - i, i)) % MOD i += 2print(ans)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16596 计算系数（排列组合）]]></title>
    <url>%2F2021%2F02%2F17%2F%E8%AE%A1%E7%AE%97%E7%B3%BB%E6%95%B0%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/16596来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述 给定一个多项式(ax+by)k，请求出多项式展开后x^n * y^m项的系数。 输入描述: 共一行，包含5个整数，分别为a，b，k，n，m，每两个整数之间用一个空格隔开。 输出描述: 输出共1行，包含一个整数，表示所求的系数，这个系数可能很大，输出对10007取模后的结果。 12345678910111213a, b, k, n, m = list(map(int, input().split()))k1=1m1=1n1=1for i in range(1,k+1): k1 = k1*ifor i in range(1,m+1): m1 = m1*ifor i in range(1,n+1): n1 = n1*is = ((k1//(m1*n1))*a**n*b**m)%10007print(s)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智力题：64匹马8个跑道，至少需要多少轮才能挑选出最快的4匹马]]></title>
    <url>%2F2021%2F02%2F17%2F%E6%99%BA%E5%8A%9B%E9%A2%98%EF%BC%9A64%E5%8C%B9%E9%A9%AC8%E4%B8%AA%E8%B7%91%E9%81%93%EF%BC%8C%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E8%BD%AE%E6%89%8D%E8%83%BD%E6%8C%91%E9%80%89%E5%87%BA%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC%2F</url>
    <content type="text"><![CDATA[题意： 64匹马8个跑道需要多少轮才能挑选出最快的四匹马？ 解法： 1.分成八组，每组8匹马。 2.八组内部分别比赛，总共比八场，对每组的马排序。 每组的后四匹显然不是答案，直接淘汰。 现在只剩下八组，每组4匹。 3.选出八组的第一名进行比赛，后四名所在的组的所有马显然不是答案，直接淘汰。 现在只剩下前四组，每组只剩下前四匹马，总共十六匹。 4.剩下四组中，第四组的后三匹一定不是答案，因为比他们快的已经至少有四匹了（四个组的第一匹）， 同时，第三组的后两匹一定不是答案；第二组的后一匹一定不是答案。理由同上。 其实第一组的第一匹一定是答案，因为最快。 那么现在只剩下第一组3匹，第二组3匹，第三组2匹，第四组1匹。总共9匹。 5.剩下的9匹用两次选出前3匹即可。 总比赛次数为：8+1+2=11次。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16429 组合数问题（二维前缀和、杨辉三角）]]></title>
    <url>%2F2021%2F02%2F16%2F%E7%89%9B%E5%AE%A216429%20%20%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%88%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/16429来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 262144K，其他语言524288K64bit IO Format: %lld题目描述组合数表示的是从 n 个物品中选出 m 个物品的方案数。举个例子，从 (1, 2, 3) 三个物品中选择两个物品可以有 (1, 2)，(1, 3)，(2, 3) 这三种选择方法。根据组合数的定义，我们可以给出计算组合数的一般公式：其中 n! = 1×2×⋯×n。 输入描述: 第一行有两个整数 t，k，其中 t 代表该测试点总共有多少组测试数据，k 的意义见 「题目描述」。接下来 t 行每行两个整数 n，m，其中 n，m 的意义见「题目描述」。 输出描述: 1234567891011121314151617181920212223242526272829303132333435363738t, k = list(map(int, input().split()))a = [[0 for i in range(2002)] for j in range(2002)]ans = [[0 for i in range(2002)] for j in range(2002)]for i in range (2001): for j in range (1+i): if j==0: a[i][j] = 1 else: a[i][j] = (a[i-1][j] + a[i-1][j-1])%k if a[i][j] == 0: ans[i][j] = 1"""for i in range (2001): for j in range (i+1): if i==0 and j==0: continue elif i==j: ans[i][j] = ans[i][j-1] elif j==0: ans[i][j] = ans[i-1][j] else: ans[i][j] = ans[i-1][j] + ans[i][j-1] - ans[i-1][j-1] + ans[i][j]"""for i in range (2001): for j in range (2001): if i != 0: ans[i][j]+=ans[i-1][j] if j != 0: ans[i][j]+=ans[i][j-1] if i != 0 and j != 0: ans[i][j]-=ans[i-1][j-1]for i in range (t): n, m = list(map(int, input().split())) m = min(n, m) print(ans[n][m])]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二位前缀和详解]]></title>
    <url>%2F2021%2F02%2F16%2F%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[什么是二维前缀和 ?比如我们有这样一个矩阵a，如下所示：1231 2 4 35 1 2 46 3 5 9我们定义一个矩阵sum，其中那么这个矩阵就是这样的：1231 3 7 106 9 15 2212 18 29 45建立在一维前缀和之上，我们要求一个矩阵内一个任意的子矩阵的数的和，我们就可以用二维前缀和，我们还是用DP来预处理，状态和一维前缀和差不多，只不过我们多加了一维，DP[i][j] 表示（1,1）这个点与（i，j）这个点两个点分别为左上角和右下角所组成的矩阵内的数的和，好好想一下状态转移方程： DP[i][j]=DP[i-1][j]+DP[i][j-1]-DP[i-1][j-1]+map[i][j] 怎么来的呢？我们画一下图就知道了。这张图就知道了 （i，j） 可以由 （i-1，j） 和 （i,j-1） 两块构成，不过要注意两个点 1、有一块矩阵我们重复加了，也就是 （i-1，j-1） 这一块，所以我们要减去它。 2、我们这个矩阵是不完整的，由图可知我们还有一块深蓝色的没有加，也就是 （i，j） 这一点，所以我们要再加上 map[i][j] 也就是题目给出的矩阵中这一格的数。 这样我们就预处理完了，现在讲一下怎么通过我们的预处理从而快速地得出我们想要的任意子矩阵中的和，我们定义 （x1，y1） 为我们想要子矩阵的左上角， （x2，y2） 为我们想要子矩阵的右下角，然后我们画图想一想。 我们可以通过 DP[x2][y2] 来计算，我们通过图可以发现这个距离我们要的还差红色的部分看看怎么表示红色部分？我们可以分割成两块，分别是 DP[x1][y2] 和 DP[x2][y1] 我们发现有一块重复减了，所以我们再加上它即 DP[x1][y1]。 有一点注意，因为画图和定义原因我们发现边界好像不对，我们来看看，我们定义的状态是整个矩阵包括边的和，而我们要求的也是要包括边的，所以我们要再改一下，把 DP[x1][y2] 和 DP[x2][y1]和 DP[x1][y1] 分别改成 DP[x1-1][y2] 和 DP[x2][y1-1] 和 DP[x1-1][y1-1] 这样一减我们就可以得到自己想要的答案，整理可得公式，DP[x2][y2]-DP[x1-1][y2]-DP[x2][y1-1]+DP[x1-1][y1-1] 这样我们就可以做到 O（1） 之内查询，很奇妙吧，我们看一下实现代码： 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int dp[2000][2000],map[2000][2000];int main()&#123; int m,n,k;//所给的矩阵是n*m的,有k组查询 cin &gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) cin &gt;&gt;map[i][j]; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++)//预处理一波 for(int j=1;j&lt;=m;j++) dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]+map[i][j]; for(int i=1;i&lt;=k;i++)//接受查询 &#123; int x1,x2,y1,y2; cin &gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; cout &lt;&lt;(dp[x2][y2]+dp[x1-1][y1-1]-dp[x1-1][y2]-dp[x2][y1-1])&lt;&lt;endl;//O（1）查询 &#125; return 0;&#125; 参考博文:https://blog.csdn.net/qq_34990731/article/details/82807870]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客15666 又见斐波那契数列（矩阵快速幂）]]></title>
    <url>%2F2021%2F02%2F03%2F%E7%89%9B%E5%AE%A215666%20%E5%8F%88%E8%A7%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/15666来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述输入描述:第一行是一个整数T(1 ≤ T ≤ 1000)，表示样例的个数。以后每个样例一行，是一个整数n(1 ≤ n ≤ 1018)。 输出描述: 每个样例输出一行，一个整数，表示F(n) mod 1000000007。列出等式，可以求出矩阵A为：[ [1,1,1,1,1,1], [1,0,0,0,0,0], [0,0,1,3,3,1], [0,0,0,1,2,1], [0,0,0,0,1,1], [0,0,0,0,0,1],] 123456789101112131415161718192021222324252627282930313233343536GLOBAL_MOD = 1000000007T = int(input())class Solution: def f(self, n: int) -&gt; int: if n == 0 or n == 1: return n res = self.matrixpower(n-1) res = res[0][0]*1+res[0][1]*0+res[0][2]*8+res[0][3]*4+res[0][4]*2+res[0][5] res = res % GLOBAL_MOD return res def matrixpower(self, power): # res初始值为单位矩阵 res = [[1, 0, 0, 0, 0, 0],[0, 1, 0, 0, 0, 0],[0, 0, 1, 0, 0, 0],[0, 0, 0, 1, 0, 0],[0, 0, 0, 0, 1, 0],[0, 0, 0, 0, 0, 1]] base = [[1, 1, 1, 1, 1, 1],[1, 0, 0, 0, 0, 0],[0, 0, 1, 3, 3, 1],[0, 0, 0, 1, 2, 1],[0, 0, 0, 0, 1, 1],[0, 0, 0, 0, 0, 1]] # 这个是我们根据斐波那契数列的特点构造的矩阵 while power !=0: if power&amp;1 !=0: res = self.multimatrix(res, base) power = power&gt;&gt;1 base = self.multimatrix(base, base) return res def multimatrix(self, m1, m2): n = len(m1) res = [[0]*n for i in range(n)] for i in range(n): for j in range(n): for k in range(n): res[i][j] = (res[i][j]+m1[i][k] * m2[k][j])%GLOBAL_MOD return resfor i in range(T): n = int(input()) ans = Solution() print(ans.f(n))]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch中Tensor的基本用法与动手学深度学习的预备知识]]></title>
    <url>%2F2021%2F02%2F03%2FPyTorch%E4%B8%ADTensor%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[🐳🐳 第一部分是PyTorch中有关Tensor的一些基本用法，因为之前并没有系统学习过PyTorch，所以现在看书的同时慢慢学习PyTorch的知识 第二部分是原书的知识和一些自己的理解 @TOC张量 Tensor 张量包含了一个数据集合，这个数据集合就是原始值变形而来的，它可以是一个任何维度的数据。tensor的rank就是其维度。 Rank本意是矩阵的秩，不过Tensor Rank和Matrix Rank的意义不太一样，这里就还叫Rank。Tensor Rank的意义看起来更像是维度，比如Rank =1就是向量，Rank=2 就是矩阵了，Rank = 0 就是一个值。 一、PyTorch 中的Tensor在PyTorch中，torch.Tensor是存储和变换数据的主要工具。Tensor 和 NumPy 的多维数组非常类似。 首先导入PyTorch 1import torch 1.1 Tensor的创建创建一个5x3的未初始化的 Tensor 12x = torch.empty(5, 3)print(x) tensor([[5.4880e+23, 4.5886e-41, 2.7434e-24], [3.0915e-41, 4.4842e-44, 0.0000e+00], [4.4842e-44, 0.0000e+00, 2.7450e-24], [3.0915e-41, 5.4880e+23, 4.5886e-41], [4.2039e-45, 0.0000e+00, 4.6243e-44]])创建一个5x3的随机初始化的 Tensor 12x = torch.rand(5, 3) # 这里rand的用法后面会讲到print(x) tensor([[0.7787, 0.8019, 0.3431], [0.1335, 0.3062, 0.2305], [0.6151, 0.5777, 0.2794], [0.4701, 0.6086, 0.9624], [0.6524, 0.6794, 0.8206]])创建一个5x3的long类型全0的 Tensor 12x = torch.zeros(5, 3, dtype=torch.long)print(x) tensor([[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]])直接根据数据创建 12x = torch.tensor([5.5, 3])print(x) tensor([5.5000, 3.0000])通过现有的 Tensor 来创建，此方法会默认重用输入 Tensor 的一些属性，例如数据类型，除非自定义数据类型。 12345x = x.new_ones(5, 3, dtype=torch.float64) # new_ones 返回一个与size大小相同的用1填充的张量,默认具有相同的torch.dtype和torch.deviceprint(x)x = torch.randn_like(x, dtype=torch.float) # randn_like形状与输入的张量相同，指定新的数据类型print(x) tensor([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.], [1., 1., 1.]], dtype=torch.float64) tensor([[-0.9532, 0.4367, -0.1972], [ 2.1078, 0.3750, -0.2939], [-0.3682, 1.3246, -0.7197], [-0.4119, 0.2093, -0.3431], [-1.7094, 0.0638, -0.4597]])通过 shape 或者size() 来获取 Tensor 的形状 12print(x.size())print(x.shape) torch.Size([5, 3]) torch.Size([5, 3])✨ 注意：返回的torch.Size其实就是一个tuple, 支持所有tuple的操作。 1.2 Tensor的数据类型1.2.1 torch.FloatTensor此变量用于生成数据类型为浮点型的 Tensor，传递给 torch.FloatTensor 的参数可以是一个列表，也可以是一个维度值。 12a = torch.FloatTensor(2, 3) # 两行三列print(a) tensor([[5.4880e+23, 4.5886e-41, 5.4880e+23], [4.5886e-41, 1.4584e-19, 7.8458e+17]])12b = torch.FloatTensor([[2, 3], [4, 5]])print(b, b.shape, b.dtype) tensor([[2., 3.], [4., 5.]]) torch.Size([2, 2]) torch.float321.2.2 torch.IntTensor用于生成数据类型为整型的 Tensor，传递给 torch.IntTensor 的参数可以是一个列表，也可以是一个维度值。 12a = torch.IntTensor(2, 3)print(a) tensor([[1726508320, 32745, 407958368], [ 22062, 1953384789, 1701869908]], dtype=torch.int32)12b = torch.IntTensor([[2, 3], [4, 5]])print(b, b.dtype) tensor([[2, 3], [4, 5]], dtype=torch.int32) torch.int321.2.3 torch.rand用于生成数据类型为浮点型且维度指定的随机 Tensor，和在 Numpy 中使用 numpy.rand 生成随机数的方法类似，随机生成的浮点数据在 0~1区间均匀分布。 12a = torch.rand(2, 3)print(a, a.dtype) tensor([[0.8055, 0.3392, 0.5802], [0.3333, 0.7156, 0.3415]]) torch.float321.2.4 torch.randn用于生成数据类型为浮点型且维度指定的随机 Tensor，和在 Numpy 中使用 numpy.randn生成随机数的方法类似，随机生成的浮点数的取值满足均值为0，方差为1的正态分布。 12a = torch.randn(2, 3)print(a, a.dtype) tensor([[ 0.4737, 0.3686, -1.1102], [ 0.9147, -0.3446, -0.7511]]) torch.float321.2.5 torch.range用于生成数据类型为浮点型且自定义其实范围和结束范围的 Tensor，所以传递给 torch.range 的参数有三个，分别是范围的起始值，范围的结束值和步长，其中，步长用于指定从起始值到结束值的每步的数据间隔。 12a = torch.range(2, 8, 3)print(a, a.dtype) tensor([2., 5., 8.]) torch.float32 /opt/conda/lib/python3.7/site-packages/ipykernel_launcher.py:2: UserWarning: torch.range is deprecated in favor of torch.arange and will be removed in 0.5. Note that arange generates values in [start; end), not [start; end].1.2.6 torch.zeros用于生成数据类型为浮点型且维度指定的 Tensor，不过这个浮点型的 Tensor 中的元素值全部为0 12a = torch.zeros(3, 4)print(a, a.dtype) tensor([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) torch.float321.3 Tensor的运算这里通常对 Tensor 数据类型的变量进行运算，来组合一些简单或者复杂的算法，常用的 Tensor 运算如下： 1.3.1 torch.abs将参数传递到 torch.abs 后返回输入参数的绝对值作为输出，输出参数必须是一个 Tensor 数据类型的变量 1234a = torch.randn(2, 3)print(a)b = torch.abs(a)print(b) tensor([[-1.5257, 0.1174, -0.2927], [ 0.4662, 0.7019, 0.2605]]) tensor([[1.5257, 0.1174, 0.2927], [0.4662, 0.7019, 0.2605]])1.3.2 torch.add将参数传递到 torch.add 后返回输入参数的求和结果作为输出，输入参数既可以全部是 Tensor 数据类型的变量，也可以是一个 Tensor 数据类型的变量，另一个是标量。 1234567891011121314a = torch.randn(2, 3)print(a)b = torch.randn(2, 3)print(b)c = torch.add(a, b)print(c)d = torch.randn(2, 3)print(d)e = torch.add(d, 10)print(e) tensor([[-1.5090, -1.1659, -0.7795], [ 0.8453, -0.0334, 0.2251]]) tensor([[-1.5168, -1.2602, 0.8775], [ 1.8206, -0.0880, -1.1371]]) tensor([[-3.0258, -2.4261, 0.0980], [ 2.6659, -0.1213, -0.9120]]) tensor([[0.2818, 1.4852, 2.0287], [1.1209, 1.6720, 1.0154]]) tensor([[10.2818, 11.4852, 12.0287], [11.1209, 11.6720, 11.0154]])可以指定输出 123result = torch.empty(2, 3)torch.add(a, b, out=result)print(result) tensor([[-3.0258, -2.4261, 0.0980], [ 2.6659, -0.1213, -0.9120]])关于加法还有两种方式： 第一种，+号 第二种，inplace ✨ 注：PyTorch操作inplace版本都有后缀, 例如x.copy(y), x.t_() 1print(a+b) tensor([[-3.0258, -2.4261, 0.0980], [ 2.6659, -0.1213, -0.9120]])12b.add_(a)print(b) tensor([[-3.0258, -2.4261, 0.0980], [ 2.6659, -0.1213, -0.9120]])1.3.3 torch.clamp 对输入参数按照自定义的范围进行裁剪，最后将参数裁剪的结果作为输出。所以输入参数一共有三个，分别是需要进行裁剪的Tensor数据类型的变量、裁剪的上边界和裁剪的下边界， 具体的裁剪过程是：使用变量中的每个元素分别和裁剪的上边界及裁剪的下边界的值进行比较，如果元素的值小于裁剪的下边界的值，该元素就被重写成裁剪的下边界的值； 同理，如果元素的值大于裁剪的上边界的值，该元素就被重写成裁剪的上边界的值。 12345a = torch.randn(2, 3)print(a)b = torch.clamp(a, -0.1, 0.1)print(b) tensor([[ 0.5965, 2.1073, -1.2866], [-0.1101, -1.6736, -2.2357]]) tensor([[ 0.1000, 0.1000, -0.1000], [-0.1000, -0.1000, -0.1000]])1.3.4 torch.div将参数传递到 torch.div 后返回输入参数的求商结果作为输出，同样，参与运算的参数可以全部是 Tensor 数据类型的变量，也可以是 Tensor 数据类型的变量和标量的组合。 1234567891011121314a = torch.randn(2,3)print(a) b = torch.randn(2,3)print(b) c = torch.div(a,b)print(c) d = torch.randn(2,3)print(d) e = torch.div(d,10)print(e) tensor([[ 0.4518, 0.1334, 1.7579], [ 0.0349, -0.2346, 1.6790]]) tensor([[ 1.2516, -1.1198, 1.1351], [-0.6222, -0.6472, -0.0758]]) tensor([[ 0.3610, -0.1191, 1.5486], [ -0.0561, 0.3624, -22.1492]]) tensor([[ 0.2908, 0.0664, -1.4821], [ 0.4358, 0.3226, 1.0338]]) tensor([[ 0.0291, 0.0066, -0.1482], [ 0.0436, 0.0323, 0.1034]])1.3.5 torch.mul将参数传递到 torch.mul 后返回输入参数求积的结果作为输出，参与运算的参数可以全部是 Tensor 数据类型的变量，也可以是 Tensor 数据类型的变量和标量的组合。 1234567891011121314a = torch.randn(2, 3)print(a)b = torch.randn(2, 3)print(b)c = torch.mul(a, b)print(c)d = torch.randn(2, 3)print(d)e = torch.mul(d, 10)print(e) tensor([[ 0.5851, 0.2113, 0.6891], [ 1.1177, -0.0177, 1.5595]]) tensor([[ 0.9094, -0.0707, -0.3900], [ 0.2990, -0.9827, 0.7165]]) tensor([[ 0.5321, -0.0149, -0.2687], [ 0.3342, 0.0174, 1.1174]]) tensor([[-0.7012, 1.2348, 1.6156], [ 0.5412, 0.2345, -0.5753]]) tensor([[-7.0115, 12.3478, 16.1558], [ 5.4116, 2.3447, -5.7526]])1.3.6 torch.pow将参数传递到 torch.pow 后返回输入参数的求幂结果作为输出，参与运算的参数可以全部是 Tensor 数据类型的变量，也可以是 Tensor 数据类型的变量和标量的组合。 12345a = torch.randn(2, 3)print(a)b = torch.pow(a, 2)print(b) tensor([[-0.9387, 1.0499, -1.6718], [-0.3190, -1.1677, -0.0666]]) tensor([[0.8812, 1.1024, 2.7948], [0.1018, 1.3635, 0.0044]])1.3.7 torch.mm将参数传递到 torch.mm 后返回输入参数的求积结果作为输出，不过这个求积的方式和之前的 torch.mul运算方式不太样， torch.mm 运用矩阵之间的乘法规则进行计算，所以被传入的参数会被当作矩阵进行处理，参数的维度自然也要满足矩阵乘法的前提条件， 即前一个矩阵的行数必须和后一个矩阵的列数相等，否则不能进行计算。 12345678a = torch.randn(2, 3)print(a)b = torch.randn(3, 2)print(b)b = torch.mm(a, b)print(b) tensor([[ 0.1701, 0.9539, -0.3128], [-0.2466, 2.4600, -1.6023]]) tensor([[-1.0573, -1.0292], [-0.2707, 0.2992], [-1.0913, -3.1058]]) tensor([[-0.0967, 1.0818], [ 1.3436, 5.9664]])1.3.8 torch.mv将参数传递到 torch.mv 后返回输入参数的求积结果作为输出，torch.mv 运用矩阵与向量之间的乘法规则进行计算，被传入的参数中的第1个参数代表矩阵，第2个参数代表向量，顺序不能颠倒。 12345678a = torch.randn(2, 3)print(a)b = torch.randn(3)print(b)c = torch.mv(a, b)print(c) tensor([[ 1.7745, 0.8665, -0.5622], [-0.6072, 0.5540, -1.0647]]) tensor([ 0.0553, -0.5526, -1.0924]) tensor([0.2335, 0.8233])二、原书2.1 数据操作 部分操作已经在前面提及 2.1.1 索引索引出来的结果与原数据共享内存，也即修改一个，另一个会跟着修改。 12345678x = torch.randn(2, 4)print(x)y = x[:, :3]print(y)y += 1print(y)print(x[:, :3]) # 源tensor也被改了print(x) tensor([[ 0.5706, 0.3683, 1.4869, 1.2791], [-0.1592, -1.7226, -1.1192, -0.9729]]) tensor([[ 0.5706, 0.3683, 1.4869], [-0.1592, -1.7226, -1.1192]]) tensor([[ 1.5706, 1.3683, 2.4869], [ 0.8408, -0.7226, -0.1192]]) tensor([[ 1.5706, 1.3683, 2.4869], [ 0.8408, -0.7226, -0.1192]]) tensor([[ 1.5706, 1.3683, 2.4869, 1.2791], [ 0.8408, -0.7226, -0.1192, -0.9729]])除了常用的索引选择数据之外，PyTorch还提供了一些高级的选择函数: 函数 功能 index_select(input, dim, index) 在指定维度dim上选取，比如选取某些行、某些列 masked_select(input, mask,out=None) 根据布尔掩码 (boolean mask) 索引输入张量的 1D 张量 nonzero(input) 非0元素的下标 gather(input, dim, index) 根据index，在dim维度上选取数据，输出的size与index一样 index_select 12345index_select( input, dim, index) 参数： input：索引的对象 dim：表示从第几维挑选数据，类型为int值；0表示按行索引，1表示按列索引 index：表示从第一个参数维度中的哪个位置挑选数据，类型为torch.Tensor类的实例； 12print(torch.index_select(x,0,torch.tensor([0, 1])))print(torch.index_select(x,1,torch.tensor([0, 1]))) tensor([[ 1.5706, 1.3683, 2.4869, 1.2791], [ 0.8408, -0.7226, -0.1192, -0.9729]]) tensor([[ 1.5706, 1.3683], [ 0.8408, -0.7226]])masked_select 12345masked_select( input, mask, out) 参数： input(Tensor) ：需要进行索引操作的输入张量； mask(BoolTensor) ：要进行索引的布尔掩码 out(Tensor, optional) ：指定输出的张量。比如执行 torch.zeros([2, 2], out = tensor_a)，相当于执行 tensor_a = torch.zeros([2, 2])； ⚠️ 注意：「 masked_select 函数最关键的参数就是布尔掩码 mask， 传入 mask 参数的布尔张量通过 True 和 False (或 1 和 0) 来决定输入张量对应位置的元素是否保留， 既然是一一对应的关系，这就需要传入 mask 中的布尔张量和传入 input 中的输入张量形状要相同。」 123mask = x.ge(0.5)print(mask)print(torch.masked_select(x, mask)) tensor([[ True, True, True, True], [ True, False, False, False]]) tensor([1.5706, 1.3683, 2.4869, 1.2791, 0.8408])12print(x)print(torch.nonzero(x)) tensor([[ 1.5706, 1.3683, 2.4869, 1.2791], [ 0.8408, -0.7226, -0.1192, -0.9729]]) tensor([[0, 0], [0, 1], [0, 2], [0, 3], [1, 0], [1, 1], [1, 2], [1, 3]])gather 12345gather( input, dim, index) 参数： input (Tensor) – 需要进行索引操作的输入张量； dim (int) – 表示从第几维挑选数据，类型为int值； index (LongTensor) – 要收集的元素的索引； out (Tensor, optional) – 指定输出的张量。 12print(torch.gather(x, dim=1, index=torch.LongTensor([[0, 1],[0, 0]]))) # dim为1说明按列索引，[0, 1]表示第一行的第0列和第1列，就是1.5706和1.3683，同理[0, 0]是0.8408和0.8408print(torch.gather(x, dim=0, index=torch.LongTensor([[0,1,1,0],[0,0,0,0]]))) # dim为0说明按行索引，[0, 1, 1, 0]表示第0行，第1行，第1行，第0行 tensor([[1.5706, 1.3683], [0.8408, 0.8408]]) tensor([[ 1.5706, -0.7226, -0.1192, 1.2791], [ 1.5706, 1.3683, 2.4869, 1.2791]])2.1.2 改变形状用 view() 来改变 Tensor 的形状： ⚠️ 需要注意的是：-1所指的维度可以根据其他维度的值推出来，这个用法在很多地方都见过，应该要记住 123y = x.view(8)z = x.view(-1, 2) # -1所指的维度可以根据其他维度的值推出来print(x.size(), y.size(), z.size()) torch.Size([2, 4]) torch.Size([8]) torch.Size([4, 2])🔥 view()返回的新 Tensor 与源 Tensor 虽然可能有不同的 size，但是是共享 data 的，也即更改其中的一个，另外一个也会跟着改变。(顾名思义，view 仅仅是改变了对这个张量的观察角度，内部数据并未改变) 123x += 1print(x)print(y) tensor([[2.5706, 2.3683, 3.4869, 2.2791], [1.8408, 0.2774, 0.8808, 0.0271]]) tensor([2.5706, 2.3683, 3.4869, 2.2791, 1.8408, 0.2774, 0.8808, 0.0271])所以如果我们想返回一个真正新的副本（即不共享data内存）该怎么办呢？ Pytorch还提供了一个 reshape() 可以改变形状，但是此函数并不能保证返回的是其拷贝，所以不推荐使用。推荐先用 clone 创造一个副本然后再使用 view。 1234x_cp = x.clone().view(8)x -= 1print(x)print(x_cp) tensor([[ 1.5706, 1.3683, 2.4869, 1.2791], [ 0.8408, -0.7226, -0.1192, -0.9729]]) tensor([2.5706, 2.3683, 3.4869, 2.2791, 1.8408, 0.2774, 0.8808, 0.0271])✨ 使用 clone 还有一个好处是会被记录在计算图中，即梯度回传到副本时也会传到源 Tensor 另外一个常用的函数就是 item(), 它可以将一个标量 Tensor 转换成一个Python number： 123x = torch.randn(1)print(x)print(x.item()) tensor([1.0600]) 1.0599588155746462.2 线性代数另外，PyTorch还支持一些线性函数，这里提一下，免得用起来的时候自己造轮子，具体用法参考官方文档。如下表所示： 函数 功能 trace 对角线元素之和(矩阵的迹) diag 对角线元素 triu/tril 矩阵的上三角/下三角，可指定偏移量 mm/bmm 矩阵乘法，batch的矩阵乘法 addmm/addbmm/addmv/addr/baddbmm.. 矩阵运算 t 转置 dot/cross 内积/外积 inverse 求逆矩阵 svd 奇异值分解 2.3 广播机制当对两个形状不同的 Tensor 按元素运算时，可能会触发广播（broadcasting）机制：先适当复制元素使这两个 Tensor 形状相同后再按元素运算。 12345x = torch.arange(1, 3).view(1, 2)print(x)y = torch.arange(1, 4).view(3, 1)print(y)print(x + y) tensor([[1, 2]]) tensor([[1], [2], [3]]) tensor([[2, 3], [3, 4], [4, 5]])由于 x 和 y 分别是1行2列和3行1列的矩阵，如果要计算 x + y，那么 x 中第一行的2个元素被广播（复制）到了第二行和第三行， 而 y 中第一列的3个元素被广播（复制）到了第二列。如此，就可以对2个3行2列的矩阵按元素相加。 2.4 运算内存开销前面说了，索引操作是不会开辟新内存的，而像y = x + y 这样的运算是会新开内存的，然后将y指向新内存。 为了演示这一点，我们可以使用Python自带的 id 函数：如果两个实例的ID一致，那么它们所对应的内存地址相同；反之则不同。 12345x = torch.tensor([1, 2])y = torch.tensor([3, 4])id_before = id(y)y = y + xprint(id(y) == id_before) # False False如果想指定结果到原来的 y 的内存，我们可以使用前面介绍的索引来进行替换操作。在下面的例子中，我们把x + y的结果通过 [:] 写进 y 对应的内存中。 12345x = torch.tensor([1, 2])y = torch.tensor([3, 4])id_before = id(y)y[:] = y + xprint(id(y) == id_before) # True True我们还可以使用运算符全名函数中的 out 参数或者自加运算符 += (也即 add_() )达到上述效果，例如 torch.add(x, y, out=y)和 y += x(y.add_(x))。 12345x = torch.tensor([1, 2])y = torch.tensor([3, 4])id_before = id(y)torch.add(x, y, out=y) # y += x, y.add_(x)print(id(y) == id_before) # True True✨ 注：虽然 view 返回的 Tensor 与源 Tensor 是共享data的，但是依然是一个新的 Tensor（因为 Tensor 除了包含data外还有一些其他属性），二者id（内存地址）并不一致。 2.5 Tensor和NumPy相互转换我们很容易用 numpy() 和 from_numpy() 将 Tensor 和 NumPy 中的数组相互转换。 但是需要注意的一点是： 这两个函数所产生的的 Tensor 和 NumPy 中的数组共享相同的内存（所以他们之间的转换很快），改变其中一个时另一个也会改变！！！ ✨ 还有一个常用的将NumPy中的array转换成Tensor的方法就是torch.tensor(), 需要注意的是，此方法总是会进行数据拷贝（就会消耗更多的时间和空间），所以返回的Tensor和原来的数据不再共享内存。 Tensor转NumPy 使用 numpy()将 Tensor 转换成 NumPy 数组: 12345678a = torch.ones(5)b = a.numpy()print(a, b)a += 1print(a, b)b += 1print(a, b) tensor([1., 1., 1., 1., 1.]) [1. 1. 1. 1. 1.] tensor([2., 2., 2., 2., 2.]) [2. 2. 2. 2. 2.] tensor([3., 3., 3., 3., 3.]) [3. 3. 3. 3. 3.]NumPy数组转Tensor 使用from_numpy() 将 NumPy 数组转换成 Tensor : 123456789import numpy as npa = np.ones(5)b = torch.from_numpy(a)print(a, b)a += 1print(a, b)b += 1print(a, b) [1. 1. 1. 1. 1.] tensor([1., 1., 1., 1., 1.], dtype=torch.float64) [2. 2. 2. 2. 2.] tensor([2., 2., 2., 2., 2.], dtype=torch.float64) [3. 3. 3. 3. 3.] tensor([3., 3., 3., 3., 3.], dtype=torch.float64)所有在CPU上的 Tensor（除了 CharTensor）都支持与 NumPy 数组相互转换。 此外上面提到还有一个常用的方法就是直接用 torch.tensor()将 NumPy 数组转换成 Tensor， 需要注意的是该方法总是会进行数据拷贝，返回的 Tensor 和原来的数据不再共享内存。 123c = torch.tensor(a)a += 1print(a, c) [4. 4. 4. 4. 4.] tensor([3., 3., 3., 3., 3.], dtype=torch.float64)2.2.6 Tensor on GPU用方法 to() 可以将 Tensor 在CPU和GPU（需要硬件支持）之间相互移动。 12345678# 以下代码只有在PyTorch GPU版本上才会执行if torch.cuda.is_available(): device = torch.device("cuda") # GPU y = torch.ones_like(x, device=device) # 直接创建一个在GPU上的Tensor x = x.to(device) # 等价于 .to("cuda") z = x + y print(z) print(z.to("cpu", torch.double)) # to()还可以同时更改数据类型]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客14607 递推（矩阵快速幂构造)]]></title>
    <url>%2F2021%2F02%2F02%2F%E7%89%9B%E5%AE%A214607%20%E9%80%92%E6%8E%A8%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E6%9E%84%E9%80%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/14607来源：牛客网时间限制：C/C++ 2秒，其他语言4秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述 JYM和XJ转眼就从小学上了高中。在学习递推的时候，JYM在纸上随手写了一个递推关系式：an=2an-1，a0=0。写完这个递推式，JYM拿给XJ看，XJ觉得太过简单，于是大笔一挥，在等式右边又加了一个式子，变成了这样：an=2an-1+n2。JYM看到这个式子，想要算几个项来看看，可是一算就发现这个数据量太大了，你能帮他解决这个问题吗？ 输入描述: 输入数据有多组（不超过100组数据），每组数据包含一个整数N&lt;=10^18 输出描述: 一个整数X，表示递推式第n项的值。由于数字太大，因此结果对于1000000009取模后输出。 构造出来的基矩阵base: 12345678910111213141516171819202122232425262728293031323334353637GLOBAL_MOD = 1000000009class Solution: def f(self, n: int) -&gt; int: if n &lt; 2: return n res = self.matrixpower(n-1) res = res[0][0]+res[0][1]+res[0][2]+res[0][3] res = res % GLOBAL_MOD return res def matrixpower(self, power): # res初始值为单位矩阵 res = [[1, 0, 0, 0],[0, 1, 0, 0],[0, 0, 1, 0],[0, 0, 0, 1]] base = [[2, 1, 2, 1],[0, 1, 2, 1],[0, 0, 1, 1],[0, 0, 0, 1]] # 这个是我们构造的矩阵 while power !=0: if power&amp;1 !=0: res = self.multimatrix(res, base) power = power&gt;&gt;1 base = self.multimatrix(base, base) return res def multimatrix(self, m1, m2): n = len(m1) res = [[0]*n for i in range(n)] for i in range(n): for j in range(n): for k in range(n): res[i][j] = (res[i][j]+m1[i][k] * m2[k][j])%GLOBAL_MOD return reswhile True: try: n = int(input()) ans = Solution() print(ans.f(n)) except: break]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客18987 粉樱花之恋（矩阵快速幂、斐波那契数列）]]></title>
    <url>%2F2021%2F02%2F02%2F%E7%89%9B%E5%AE%A218987%20%E7%B2%89%E5%98%A4%E8%8A%B1%E4%B9%8B%E6%81%8B%EF%BC%88%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/18987来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 qn是个特别可爱的小哥哥，qy是个特别好的小姐姐，他们两个是一对好朋友 [ cp (划掉~)又是一年嘤花烂漫时，小qn于是就邀请了qy去嘤花盛开的地方去玩。当qy和qn来到了田野里时，qy惊奇的发现，嘤花花瓣以肉眼可见的速度从树上长了出来。仔细看看的话，花瓣实际上是以一定规律长出来的，而且，每次张成新的花瓣的时候，上一次的花瓣就会都落到地上，而且不会消失。花瓣生长的规律是，当次数大于等于2时，第i次长出来的花瓣个数和上一次张出来的花瓣个数的差是斐波那契数列的第i-1项。初始的时候地上没有花瓣，树上的花瓣个数为1，第一次生长的花瓣个数为1。初始的那个花瓣就落到了地上现在，小qn想知道，经过k次生长之后，树上和地上的总花瓣个数是多少?ps:斐波那契数列: f[1]=f[2]=1;f[i]=f[i-1]+f[i-2] (i&gt;=2且i ∈ N+) 输入描述: 一行一个数k 输出描述: 一行一个数m，表示第k次生长过后，树上和地上的总花瓣数是多少。由于答案会很大，请你将答案mod 998244353后输出题意不难理解，最终结果是要求斐波那契数列的前k+1项之和 ， 又因为Sn = f(n+2) - 1， 所以最后就是求 f(n+3)-1 普通的斐波那契数列求解可以用递归（时间复杂度O(2^N)），但是这里的数据太大，会超时，所以这里用矩阵快速幂（时间复杂度O（logN））来求解。 [F(n),F(n-1)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-1) F(n)的获取方法有两种 第一种，是取矩阵运算结果的第一行第一列，由[F(n),F(n-1)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-1)得，矩阵运算n-1次 第二种，取矩阵运算结果第一行元素之和，由[F(n-1),F(n-2)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-2), F(n) = F(n-1)+F(n-2),矩阵运算n-2次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849GLOBAL_MOD = 998244353k = int(input())"""题意不难理解，最终结果是要求斐波那契数列的前k+1项之和 ， 又因为Sn = f(n+2) - 1， 所以最后就是求 f(n+3)-1普通的斐波那契数列求解可以用递归（时间复杂度O(2^N)），但是这里的数据太大，会超时， 所以这里用矩阵快速幂（时间复杂度O（logN））来求解。[F(n),F(n-1)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-1)F(n)的获取方法有两种第一种，是取矩阵运算结果的第一行第一列，由[F(n),F(n-1)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-1)得，矩阵运算n-1次第二种，取矩阵运算结果第一行元素之和，由[F(n-1),F(n-2)] = [F(1), F(0)] * [[1 1] [1 0]]^(n-2), F(n) = F(n-1)+F(n-2),矩阵运算n-2次"""class Solution: def fib(self, n: int) -&gt; int: if n &lt; 2: return n res = self.matrixpower(n-1) res = res[0][0]-1 res = res % GLOBAL_MOD return res def matrixpower(self, power): # res初始值为单位矩阵 res = [[1, 0],[0, 1]] base = [[1, 1],[1, 0]] # 这个是我们根据斐波那契数列的特点构造的矩阵 while power !=0: if power&amp;1 !=0: res = self.multimatrix(res, base) power = power&gt;&gt;1 base = self.multimatrix(base, base) return res def multimatrix(self, m1, m2): n = len(m1) res = [[0]*n for i in range(n)] for i in range(n): for j in range(n): for k in range(n): res[i][j] = (res[i][j]+m1[i][k] * m2[k][j])%GLOBAL_MOD return resans = Solution()print((ans.fib(k+3)))]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客15499 Jxc军训（快速幂、逆元）]]></title>
    <url>%2F2021%2F02%2F02%2F%E7%89%9B%E5%AE%A215499%20Jxc%E5%86%9B%E8%AE%AD%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%8C%E9%80%86%E5%85%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/15499来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 262144K，其他语言524288K64bit IO Format: %lld题目描述 在文某路学车中学高一新生军训中，Jxc正站在太阳下站着军姿，对于这样的酷热的阳光，Jxc 表示非常不爽。 Jxc将天空看做一个n*n的矩阵，此时天上有m朵云，这些云会随机分布在m个不同的位置，同时太阳会随机出现在一个位置，Jxc想知道他被太阳晒到的概率是多少，由于他仍在站军姿，所以这个有趣的问题就交给了你。考虑到精度问题，Jxc只需要知道这个概率在对998244353取模意义下的值。 Tips：一个分数p/q在模意义下的值即p*q-1在模意义下的值，Xp-1\equiv≡1 (mod p) 输入描述: 输入只有一行，包含两个整数n、m。n和m的意义见题面. 输出描述: 第一行包含一个整数Ans，为答案 有关逆元的博客：https://www.cnblogs.com/linyujun/p/5194184.html 这道题里面，p = (n* n-m)q = n* nans = p/q = p*q-1 题目提示了费马小定理 X^(a-1) ≡1 (mod a) 两边同除以X X^(a-2) ≡1/X (mod a) 所以 1/X = X^(a-2)(mod a) 即 q-1 = q^(a-2)(mod a)，这里的a取 998244353，结果再乘上p即可。 123456789"""p = (n*n-m)q = n*nans = p/q = p*q-1"""n, m = list(map(int, input().split()))mod = 998244353ans = (n*n-m)*pow(n*n, mod-2, mod)%modprint(ans)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客14718 开心的涂刷]]></title>
    <url>%2F2021%2F02%2F02%2F%E7%89%9B%E5%AE%A214718%20%E5%BC%80%E5%BF%83%E7%9A%84%E6%B6%82%E5%88%B7%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/14718来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 一天小明同学拿着m种颜色的油漆去涂刷n块格子，在涂刷的过程中他发现有很多种涂色方案，并很快的算出了答案，然后他发现如果涂好颜色的格子中只要存在某两个相邻的格子颜色一样，他就会感到开心，他想知道有多少种让他开心的涂刷方案。 输入描述: 输入仅包含一行，包含两个数n，m分别表示格子数和颜色数。（1 &lt;= n &lt;= 1e12, 1 &lt;= m &lt;= 1e12) 输出描述: 输出一行包含一个整数，让小明开心的涂刷方案数。 答案对1000000007取模 一共有 mn个中所有的方案，我们只需要减去任意两个相邻的都不相同的即可， 考虑第一位，可以染色的可能有m种，如果第一位染了m种其中一种颜色， 那么第二位，只有m-1个选择，同理第三位，还是有m-1个选择， 因为第一位的颜色还可以选,所以所有的可能应该为：mn−m∗(m−1)n−1,直接快速幂即可 1234567891011"""一共有 mn个中所有的方案，我们只需要减去任意两个相邻的都不相同的即可， 考虑第一位，可以染色的可能有m种，如果第一位染了m种其中一种颜色， 那么第二位，只有m-1个选择，同理第三位，还是有m-1个选择， 因为第一位的颜色还可以选,所以所有的可能应该为：mn−m∗(m−1)n−1,直接快速幂即可"""n, m = list(map(int, input().split()))MODULE = 1000000007ans = pow(m, n, MODULE) - m * pow(m - 1, n - 1, MODULE)print(ans % MODULE)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客15187 分元宵（快速幂）]]></title>
    <url>%2F2021%2F02%2F02%2F%E7%89%9B%E5%AE%A215187%20%E5%88%86%E5%85%83%E5%AE%B5%20%EF%BC%88%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/15187来源：牛客网 时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 262144K，其他语言524288K64bit IO Format: %lld 题目描述 12s, v, w, p, A = list(map(int, input().split()))print(pow(s*v,w*p,A))]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客15324 用来作弊的药水]]></title>
    <url>%2F2021%2F02%2F02%2F%E7%89%9B%E5%AE%A215324%20%E7%94%A8%E6%9D%A5%E4%BD%9C%E5%BC%8A%E7%9A%84%E8%8D%AF%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/15324来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 在一个风雨交加的夜晚，来自异世界的不愿透露姓名的TMK同学获得了两种超强药水A、B。根据说明书，TMK知道了这两种药水的作用： (1)药水A能使人的生命值提高，每饮用1个单位能使他生命值变成原来的x倍，即每饮用p个单位能使他的生命值变成原来的x^p(x的p次方)倍。 (2)药水B能使人的能量值提高，每饮用1个单位能使他能量值变成原来的y倍，即每饮用q个单位能使他的能量值变成原来的y^q(y的q次方)倍。 于是TMK迫不及待地喝下了所有的a个单位的药水A和b个单位的药水B，他立马体会到了自己能力的超强变化，然后他看了接下来的说明书： 药水A和药水B能互相抑制对方的负面效果，一旦生命值提升的倍数和能量值提升的倍数不相等，那么在五个小时后将会发生非常严重的后果。 于是TMK同学慌了，他想知道自己提升的生命值和能量值的倍数是否相等，由于他非常慌张，所以他把计算的重任交给你了。作为埃森哲公司的一员，你觉得这个问题很简单，这得益于埃森哲公司分享知识的文化。 分享知识已成为埃森哲源远流长的文化。 埃森哲公司在帮助客户进行行之有效的知识管理的同时，它的管理层在其内部也进行了成功的知识管理的实践。如今，在埃森哲，分享知识已成为其源远流长的文化。在很大程度上，埃森哲公司的成功得益于其强大的知识管理系统。 输入描述: 第一行一个整数T，代表有T组数据。(1&lt;=T&lt;=5000)每组数据仅一行，包含四个整数x,a,y,b，意义为题目描述。(1&lt;=x,a,y,b&lt;=10^9) 输出描述: 每组数据输出一行”Yes”或”No”(不包含双引号)，表示TMK提升的生命值和能量值的倍数是否相等，相等为”Yes”，不相等为”No”。 12345678T = int(input())mod = 10000000007for i in range(T): x, a, y, b = list(map(int, input().split())) if pow(x, a, mod) == pow(y, b, mod): print("Yes") else: print("No")]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客18985 数字权重（数学、快速幂）]]></title>
    <url>%2F2021%2F02%2F02%2F%E7%89%9B%E5%AE%A218985%20%E6%95%B0%E5%AD%97%E6%9D%83%E9%87%8D%20%EF%BC%88%E6%95%B0%E5%AD%A6%EF%BC%8C%E5%BF%AB%E9%80%9F%E5%B9%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/18985来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 小a有一个n位的数字，但是它忘了各个位上的数是什么，现在请你来确定各个位上的数字，满足以下条件： 设第i位的数为ai，其中a1为最高位，an为最低位，K为给定的数字 请你求出满足条件的方案数 输入描述: 两个整数N, K若存在无解的情况，请输出0 输出描述: 一个整数表示答案，对109 + 7取模 不难通过条件二找到规律 an-a1 = K 12345678910111213"""K = an - a1所以只需要考虑首尾的方案数，然后中间n-2位的方案数就是10^(n-2)"""N, K = list(map(int, input().split()))MOD = 1000000007if 0 &lt;= K &lt;= 8: print(((9 - K) * pow(10, N - 2, MOD)) % MOD)elif -9 &lt;= K &lt;= -1: print(((10 + K) * pow(10, N - 2, MOD)) % MOD)else: print(0)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客19115 选择颜色]]></title>
    <url>%2F2021%2F02%2F02%2F%E7%89%9B%E5%AE%A219115%20%E9%80%89%E6%8B%A9%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/19115来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 n个人排成一个环形，每个人要从c种颜色中选择一个。牛牛希望相邻的人选择的颜色是不同的问有多少种方案。输出方案数对10007取模的结果。人是有顺序的，环旋转同构算不同的方案。 输入描述: 输入只有一行，包含用空格分开的两个整数，表示n和c。 输出描述: 输出一行一个整数，表示答案。 真的要好好学数学！！！ 12345678"""第一个人有c种选法， 与他相邻的人有c-1种选法，同理，剩下的人都是c-1这里有两种情况，第一种是第n个人的颜色和第一个人一样，第二种是不一样"""n, c = map(int, input().split())print(pow(c - 1, n, 10007)+(c-1)*pow(-1, n))]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客20701 神秘钥匙]]></title>
    <url>%2F2021%2F02%2F02%2F%E7%89%9B%E5%AE%A220701%20%E7%A5%9E%E7%A7%98%E9%92%A5%E5%8C%99%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/20701来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 clccle一行𝑛个人来到了一个诡异的世界，她们需要去寻找逃出这个地方的方法——找到神秘的所罗门之匙她们决定从中随机选出一些人去寻找钥匙，并在其中选出一个队长，clccle不想知道自己有多大几率被选中，她只想知道一共有多少种选择的方案 （选出的人数要在1−𝑛之间，不同的队长算不同的方案）。方案数对1000000007取模 输入描述: 第一行，一个整数𝑛。 输出描述: 一个整数，表示方案数。 要用到一点点数学的推导式 123456n = int(input())"""1Cn1 + 2Cn2 + …… +nCnn = n*2^(n-1)"""mod=1000000007print(n*pow(2,n-1,mod)%mod)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客13584 日历中的数字]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%89%9B%E5%AE%A213584%20%E6%97%A5%E5%8E%86%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/13584来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述 ElemenT马上就要毕业了，他打开日历看了看时间。发现日历上的日期都是2017-04-04这样的格式的，月和日如果不足2位数，前面都会补充0。给定一个年份和月份，ElemenT把那个月的日期都按上述格式写到纸上，他现在想知道某种数字出现了多少次。 输入描述: 多组输入每组输入一行，有3个数字y,m,x(1000&lt;=y&lt;=3000,1&lt;=m&lt;=12,0&lt;=x&lt;=9)，分别代表年份，月份，和他想知道哪个数字出现的次数。 输出描述: 每组输出一个整数，表示数字x在这个月的日期里出现了多少次。 注意闰年和月和日如果不足2位数，前面都会补充0即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243def fn(y): if (y%4 ==0 and y%100 !=0) or y%400 == 0: return True else: return Falsec1 = [1, 3, 5, 7, 8, 10, 12]c2 = [4, 6, 9, 11]c3 = [2]while True: try: res = 0 y, m, x = list(map(int, input().split())) if m in c1: d = [12, 14, 13, 5, 3, 3, 3, 3, 3, 3] n = 31 elif m in c2: d = [12, 13, 13, 4, 3, 3, 3, 3, 3, 3] n = 30 elif m in c3 and fn(y): d = [11, 13, 13, 3, 3, 3, 3, 3, 3, 3] n = 29 else: d = [11, 13, 12, 3, 3, 3, 3, 3, 3, 2] n = 28 if m &lt;= 9: d[0] += n d[m] += n elif m == 10: d[1] += n d[0] += n elif m == 11: d[1] += 2*n else: d[1] += n d[2] += n res += d[x] if str(x) in str(y): res += (str(y).count(str(x)))*n print(res) except: break]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客14386 水仙花数]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%89%9B%E5%AE%A214386%20%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/14386来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 水仙花数是指一个N位正整数（N≥3），它的每个位上的数字的N次幂之和等于它本身。例如：153=1^3+5^3+3^3。8208 = 8^4+2^4+0^4+8^4这道题请写出程序判断输入的数是否为水仙花数 输入描述: 首先输入正整数 n，表示需要判断的数的个数 (1&lt;=n&lt;=100)随后每一行输入一个数 Ai，对于每次输入判断 Ai 是否为水仙花数 输出描述: 每次判断 Ai 输出判断结果：如果是，输出 yes否则输出 no 1234567891011121314151617181920n = int(input())A = []for _ in range(n): A.append(int(input()))def fn(x): s = str(x) k = len(s) ans = 0 for i in range(k): ans += (int(s[i]))**k if ans == x: return True else: return False for i in range(n): if fn(A[i]): print("yes") else: print("no")]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客14355 翻硬币]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%89%9B%E5%AE%A214355%20%E7%BF%BB%E7%A1%AC%E5%B8%81%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/14355来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 小明正在玩一个“翻硬币”的游戏。桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。 比如，可能情形是：oo*oooo 如果同时翻转左边的两个硬币，则变为：oooo***oooo 现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？ 我们约定：把翻动相邻的两个硬币叫做一步操作，那么要求： 输入描述: 两行等长的字符串，分别表示初始状态和要达到的目标状态。每行的长度&lt;1000 输出描述: 一个整数，表示最小操作步数。开始还想着会不会有什么陷阱，结果发现直接暴力就可以。 1234567891011121314151617181920s1=list(input())s2=list(input())n = len(s1)res = 0for i in range(n-1): if(s1[i] == s2[i]): continue else: if(s1[i] == "*"): s1[i] = "o" else: s1[i] = "*" if(s1[i+1] == "*"): s1[i+1] = "o" else: s1[i+1] = "*" res += 1 if(s1 == s2): print(res) break]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客14392 猴子吃香蕉]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%89%9B%E5%AE%A214392%20%E7%8C%B4%E5%AD%90%E5%90%83%E9%A6%99%E8%95%89%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/14392来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 65536K，其他语言131072K64bit IO Format: %lld题目描述 有n只猴子，第i只猴子每过xi小时会连续吃香蕉yi小时。猴子从第二次开始每次休息结束后这只猴子连续吃香蕉的时间会增加zi小时。 给定n只猴子，每一只的xi，yi，zi，以及时间t，求在前t小时中，所有猴子共吃了多少小时。 对于一只猴子来说是这样的：从第1小时开始：休息xi小时( 1 -&gt; xi )吃yi小时( xi + 1 -&gt; xi + yi )休息xi小时吃yi+zi小时休息xi小时吃yi+zi+zi小时…… 输入描述: 第一行两个数n和t; 之后n行，第i+1行每行三个数xi,yi,zi. 输出描述: 一行一个数表示答案.开始用暴力的方法，发现会超时。然后参考了其他人的题解 ，发现可以用解方程的方法来降低时间复杂度。这其实是一个等差数列的问题。这里还要注意python3的除法结果会保留1位小数，所以要使用//。 123456789101112a1 = x+yan = a1+(n-1)d2*t = 2Sn = n*(a1+an) = n*(2*a1+(n-1)*d)ax^2+bx+c=02*a1*n+d*n^2-d*n-2*t = 0d*n^2 + (2*a1-d)n + (-2*t) = 0a = db = 2*a1-dc = -2*t 12345678910111213141516171819n, t = list(map(int, input().split()))ans = 0import mathfor i in range(n): x, y, z = list(map(int, input().split())) if z == 0: count = t/(x+y) else: a = z b = 2*x+2*y-z c = -2*t count = (-b + math.sqrt(b**2 - 4*a*c))/(2*a) count = math.floor(count) ans += y*count + count*(count-1)*z//2 tmp = t - (x+y)*count - count*(count-1)*z//2 - x if tmp &gt; 0: ans += tmp print(ans)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客13592 武藏牌牛奶促销]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%89%9B%E5%AE%A213592%20%E6%AD%A6%E8%97%8F%E7%89%8C%E7%89%9B%E5%A5%B6%E4%BF%83%E9%94%80%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/13592来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述 武藏牌牛奶为了吸引顾客，推出优惠活动，可以使用x个空的瓶身，或者y个瓶盖，去商店换一瓶全新的武藏牌牛奶。注意，一瓶牛奶包含了瓶身和瓶盖。现在小萌老师有a个空的瓶身和b个瓶盖，她想喝到尽可能多的牛奶，你知道她到底能喝到多少瓶完整的牛奶吗？ 输入描述: 多组输入每组数据第一行包含4个正整数x y a b(1&lt;=x,y,a,b&lt;=100)，意义见题目描述。 输出描述: 对于每组数据，输出一行，表示小萌老师最多能喝多少瓶完整的牛奶。如果能喝无数瓶，输出”INF”(不要输出引号)。 题目给出了范围 1&lt;=x,y,a,b&lt;=100，所以先判断能够喝无数瓶的条件，即x = 1或者 y = 1或者x和y都等于2。然后列出能兑换的条件。 12345678910111213141516171819while True: try: x, y, a, b = map(int,input().split()) bottle = 0 if (x == 1 or y == 1) or (x == 2 and y == 2): print('INF') else: while x &lt;= a or y &lt;= b: if a-x &gt;= 0: a = a-x+1 bottle += 1 b = b+1 elif b-y &gt;= 0: b = b-y+1 bottle += 1 a = a+1 print(bottle) except: break]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客14342 神奇的数字]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%89%9B%E5%AE%A214342%20%E7%A5%9E%E5%A5%87%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/14342来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 今天是Tabris和mengxiang000来到幼儿园的第6天，美丽的老师在黑板上写了几个数字：121,11,131，聪明的Tabris一眼就看出这些数字是那样的神奇——无论是正着写还是反着写都是一样的，mengxiang000想要得到更多的这样有趣的数，又因为这是二人到幼儿园的第6天，6+2=8。他们想知道长度为8的这样的数都有哪些。但是写着写着机智的Tabris发现这样神奇的数实在太多了，所以向你求助，你能帮帮他们吗？ 输入描述: 无 输出描述: 从小到大输出所有符合题意的数，每个数占一行。 12345for x in range(1000,10000): a = str(x) b = a[::-1] c = a+b print(c)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客14338 分苹果]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%89%9B%E5%AE%A214338%20%E5%88%86%E8%8B%B9%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/14338来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 今天是Tabris和mengxiang000来到幼儿园的第二天，美丽的老师决定给幼儿园的乖宝宝们发苹果，但是准备分给孩子们的苹果只有N个，幼儿园一共有M 个孩子。为了不偏袒任何一个孩子，老师决定，给每个孩子的苹果数一样多，如果不够的话从自己有的K个苹果中拿出一些分给孩子们。现在老师想知道每个孩子能分得一样多的苹果么？ 输入描述: 本题有T组数据每行有三个整数N,M,K分别代表准备分给孩子们的N个苹果，一共有M个孩子，老师有K个苹果。1≤T≤2001≤N，M，K≤100000 输出描述: 如果能使每个孩子得到的苹果数目一样输出YES，否则输出NO。 1234567891011121314T=int(input())try: for i in range(T): N, M, K = list(map(int, input().split())) if N%M == 0: print("YES") else: t = M*(N//M+1)-N if t &lt;= K: print("YES") else: print("NO")except: print("YES")]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客14350 苦逼的单身狗]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%89%9B%E5%AE%A214350%20%E8%8B%A6%E9%80%BC%E7%9A%84%E5%8D%95%E8%BA%AB%E7%8B%97%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/14350来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 双11又到了，小Z依然只是一只单身狗，对此他是如此的苦恼又无可奈何。为了在这一天脱单小Z决定向女神表白，但性格腼腆的小Z决定隐晦一点，截取一段包含’L’、’O’、’V’、’E’的英文。（顺序不限）小Z想起之前小D送给他一本英文书，决定在这里面截取一段话，小Z发现有好多种方案来截取这段话。你能知道小Z能有多少种方案截取这段话么？为了简化问题，英文文本讲不会出现空格、换行、标点符号及只有大写的情况。 输入描述: 本题有T组数据。对于每组数据只有一行文本。1≤T≤201≤文本长度≤100000 输出描述: 输出结果，并换行。 123456789101112131415161718192021222324T = int(input())for _ in range(T): s = input() n = len(s) res = 0 L = -1 O = -1 V = -1 E = -1 for i in range(n): if s[i] == 'L': L = i elif s[i] == 'O': O = i elif s[i] == 'V': V = i elif s[i] == 'E': E = i tmp = min(min(L, O), min(V, E)) #print(tmp) if tmp != -1: res += 1 + tmp print(res)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客14605 画三角]]></title>
    <url>%2F2021%2F01%2F26%2F%E7%89%9B%E5%AE%A214605%20%20%E7%94%BB%E4%B8%89%E8%A7%92%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/14605来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述 小学时，JYM和XJ刚刚学习了三角形，XJ提议把眼睛闭起来在纸上画三角形，巩固知识。为了让三角形更好地表示，JYM去拿了一张坐标纸（不要问为什么小学的他就有坐标纸），坐标纸的范围是[-1000,1000]。于是，XJ就在坐标纸上画了N个三角形（当然他也可能画了一条直线出来）。因为小学的他们还没有学习小数，所以所有的三角形顶点的坐标，都被JYM近似成了整数点。现在，JYM和XJ想知道这些三角形有没有将坐标原点包含在里面，请你编写程序解决这个问题。 输入描述: 一个整数N(N&lt;1000)，表示有N个三角形。接下来每一行有两个整数x(-1000&lt;=x&lt;=1000)和y(-1000&lt;=y&lt;=1000)，表示一个点的坐标；每三行的三个点构成一个三角形。 输出描述: 为每个三角形输出一个YES或者NO。YES表示三角形包含了坐标原点，NO表示三角没有包含坐标原点或者坐标原点在三角形的边界上或者当前的三个点不能构成三角形。 12345678910111213141516171819202122N = int(input())def Area(x1,y1,x2,y2,x3,y3): return abs(x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3) / 2for _ in range(N): a, b, c = [list(map(int, input().split())) for _ in range(3)] x1, y1, x2, y2, x3, y3 = a[0], a[1], b[0], b[1], c[0], c[1] # 面积 area = Area(x1, y1, x2, y2, x3, y3) # 分别和原点构成的三角形面积 area1 = Area(x1, y1, x2, y2, 0, 0) area2 = Area(x1, y1, x3, y3, 0, 0) area3 = Area(x2, y2, x3, y3, 0, 0) if area != (area1 + area2 + area3): # 不能构成三角形或没有包含坐标原点 print('NO') elif area1 == 0 or area2 == 0 or area3 == 0: # 原点在边界上 print('NO') else: print('YES')]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16502 螺旋矩阵]]></title>
    <url>%2F2021%2F01%2F24%2F%E7%89%9B%E5%AE%A216502%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/16502来源：牛客网题目描述 一个 n 行 n 列的螺旋矩阵可由如下方法生成：从矩阵的左上角（第 1 行第 1 列）出发，初始时向右移动；如果前方是未曾经过的格子，则继续前进，否则右转；重复上述操作直至经过矩阵中所有格子。根据经过顺序，在格子中依次填入 1, 2, 3, … , n ，便构成了一个螺旋矩阵。下图是一个 n = 4 时的螺旋矩阵。 现给出矩阵大小 n 以及 i 和 j ，请你求出该矩阵中第 i 行第 j 列的数是多少。 输入描述: 输入共一行，包含三个整数 n,i,j ，每两个整数之间用一个空格隔开，分别表示矩阵大小、待求的数所在的行号和列号。 输出描述: 输出一个整数，表示相应矩阵中第 i 行第 j 列的数。 找规律：当 i == 1 时，res = j当 i == n 时，res = 3n-2-j+1当 j == 1 时，res = 4n-2-i当 j == n 时， res = n+i-1 然后递归， 每减少一层 ==&gt; n-2, i-1, j-1，并且要加上外层的 4n-4 12345678910111213141516import syssys.setrecursionlimit(10000000)n, i, j = map(int,input().split())def fn(n, i, j): if i == 1: return j if i == n: return 3*n-2-j+1 if j == 1: return 4*n-2-i if j == n: return n+i-1 return fn(n-2, i-1, j-1)+4*n-4print(fn(n, i, j)) 这里有个问题 Python中默认的最大递归深度是989，当尝试递归第990时便出现递归深度超限的错误： RuntimeError: maximum recursion depth exceeded in comparison 可以手动设置递归调用深度： 12import syssys.setrecursionlimit(10000000)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客21781 牛兄牛弟]]></title>
    <url>%2F2021%2F01%2F24%2F%E7%89%9B%E5%AE%A221781%20%20%E7%89%9B%E5%85%84%E7%89%9B%E5%BC%9F%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/21781来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述 一群牛兄牛弟准备去一家餐厅吃饭，已知他们是按照某个顺序先后到达餐厅的，第i个到达餐厅的要求坐在离门口至少a[i]的距离 牛兄牛弟们不准备让别人知道他们是兄弟，虽然他们长得比较像，他们决定任意两个兄弟之间的距离都要大于等于d 餐厅服务员记录下他们的需求之后，开始陆续给到来的牛兄弟们排座位，服务员每次会指定一个满足要求的离门口最近的座位给新到的牛 输入描述: 第一行输入两个整数n,d第二行输入n个数a[i] 1 ≤ n ≤ 1000, 1 ≤ d,a[i] ≤ 106 输出描述: 输出n个数分别表示每一个牛的位置 12345678910111213141516171819n, d = list(map(int, input().split()))a = list(map(int, input().split()))ans = []ans.append(a[0])res = []res.append(a[0])for i in range(1, n): ans.append(a[i]) ans.sort() for j in range(len(ans)-1): if ans[j+1]-ans[j]&lt;d: res.append(max(res)+d) break else: res.append(a[i]) for i in res: print(i, end=" ")]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16464 神奇的幻方]]></title>
    <url>%2F2021%2F01%2F22%2F%E7%89%9B%E5%AE%A216464%20%20%E7%A5%9E%E5%A5%87%E7%9A%84%E5%B9%BB%E6%96%B9%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/16464来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述 幻方是一种很神奇的 N*N 矩阵：它由数字 1,2,3,…..N x N 构成，且每行、每列及两条对角线上的数字之和都相同。当 N 为奇数时，我们可以通过下方法构建一个幻方：首先将 1 写在第一行的中间。之后，按如下方式从小到大依次填写每个数 K (K=2,3,…,N x N) :1.若 (K-1) 在第一行但不在最后一列，则将 K 填在最后一行， (K-1) 所在列的右一列；2.若 (K-1) 在最后一列但不在第一行，则将 K 填在第一列， (K-1) 所在行的上一行；3.若 (K-1) 在第一行最后一列，则将 K 填在 (K-1) 的正下方；4.若 (K-1) 既不在第一行，也最后一列，如果 (K-1) 的右上方还未填数，则将 K 填在 (K-1) 的右上方，否则将 L 填在 (K-1) 的正下方。 输入描述: 一个正整数 N ，即幻方的大小。 输出描述: 共 N 行 ，每行 N 个整数，即按上述方法构造出的 N x N 的幻方，相邻两个整数之间用单空格隔开。 1234567891011121314151617181920212223242526272829N = int(input())H = []for i in range(N): H.append([]) for j in range(N): H[i].append(0)H[0][int((N-1)/2)] = 1for k in range(2, N**2+1): for i in range(N): for j in range(N): if k-1 == H[i][j]: if i==0 and j!=N-1: H[N-1][j+1]=k elif i!=0 and j==N-1: H[i-1][0]=k elif i==0 and j==N-1: H[i+1][j]=k elif i!=0 and j!=N-1: if H[i-1][j+1]==0: H[i-1][j+1]=k else: H[i+1][j]=k#print(H)for i in range(N): for j in range(N): print(H[i][j], end =" ") print(" ")]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16654 谁拿了最多奖学金]]></title>
    <url>%2F2021%2F01%2F22%2F%E7%89%9B%E5%AE%A216654%20%20%E8%B0%81%E6%8B%BF%E4%BA%86%E6%9C%80%E5%A4%9A%E5%A5%96%E5%AD%A6%E9%87%91%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/16654来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述 某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同： 1)院士奖学金，每人8000元，期末平均成绩高于80分（&gt;80），并且在本学期内发表1篇或1篇以上论文的学生均可获得； 2)五四奖学金，每人4000元，期末平均成绩高于85分（&gt;85），并且班级评议成绩高于80分（&gt;80）的学生均可获得； 3)成绩优秀奖，每人2000元，期末平均成绩高于90分（&gt;90）的学生均可获得； 4)西部奖学金，每人1000元，期末平均成绩高于85分（&gt;85）的西部省份学生均可获得； 5)班级贡献奖，每人850元，班级评议成绩高于80分（&gt;80）的学生干部均可获得； 只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是87分，班级评议成绩82分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是4850元。 现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。 输入描述: 第一行是一个整数N（1&lt;=N&lt;=100），表示学生的总数。接下来的N行每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过20的字符串（不含空格）；期末平均成绩和班级评议成绩都是0到100之间的整数（包括0和100）；是否是学生干部和是否是西部省份学生分别用一个字符表示，Y表示是，N表示不是；发表的论文数是0到10的整数（包括0和10）。每两个相邻数据项之间用一个空格分隔。 输出描述:包括三行：第一行是获得最多奖金的学生的姓名；第二行是这名学生获得的奖金总数。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入中出现最早的学生的姓名。第三行是这N个学生获得的奖学金的总数。 1234567891011121314151617181920212223242526N = int(input())info = []ans = []total = 0for i in range(N): info.append(list(map(str, input().split())))for i in range(N): res = 0 if int(info[i][2]) &gt; 80 and info[i][3] == 'Y': res += 850 if int(info[i][1]) &gt; 85 and info[i][4] == 'Y': res += 1000 if int(info[i][1]) &gt; 90: res += 2000 if int(info[i][1]) &gt; 85 and int(info[i][2]) &gt; 80: res += 4000 if int(info[i][1]) &gt; 80 and int(info[i][5]) &gt;= 1: res += 8000 total += res ans.append(res)ans1 = ans.index(max(ans))ans2 = max(ans)print(info[ans1][0])print(ans2)print(total)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16589 机器翻译]]></title>
    <url>%2F2021%2F01%2F22%2F%E7%89%9B%E5%AE%A216589%20%20%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/16589来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。 这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。 假设内存中有 M 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M−1，软件会将新单词存入一个未使用的内存单元；若内存中已存入M 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。 假设一篇英语文章的长度为N 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。 输入描述:输入共2 行。每行中两个数之间用一个空格隔开。第一行为两个正整数M 和N，代表内存容量和文章的长度。第二行为 N 个非负整数，按照文章的顺序，每个数（大小不超过 1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。 输出描述:共1 行，包含一个整数，为软件需要查词典的次数。 12345678910111213141516171819M, N = list(map(int, input().split()))words = list(map(int, input().split()))t = []res = 0for i in range(M): t.append(-1)#print(words)j = 0if N &lt;= M: print(len(set(words)))else: for i in range(N): if words[i] in t: continue t[j%M] = words[i] j += 1 res += 1 else: print(res)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客21805 字符串编码与解码]]></title>
    <url>%2F2021%2F01%2F21%2F%E7%89%9B%E5%AE%A221805%20%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/21805来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 32768K，其他语言65536K64bit IO Format: %lld题目描述给你两个长度相同的字符串a，b，现在已知b是a编码之后的结果比如a = “CAT”, b = “DOG”, 那么D其实是C,O其实是A，G其实是T 现在给你一个字符串c，如果c能够被解码出来，输出c解码后的字符串，如果不能输出@ 输入描述:输入三行，每行一个字符串，长度在50以内 输出描述:输出一个字符串 这里需要注意的是如果给出了25个字母，那么剩下的这个字母的解码情况是可以推导出来的。 12345678910111213141516171819202122232425262728a = input()b = input()c = input()l = []n = len(a)for i in range(n): l.append(b[i])res = ""d = dict(zip(b,a))all = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')m = len(set(b))# 如果给出了25个字母，那么剩下的这个可以推导出来if m==25: x = all - set(a) # 利用集合的性质进行推导 y = all - set(b) x = ''.join(x) # 字典转成字符串 y = ''.join(y) d[y] = x # 将推导出来的这个键值对添加进字典for i in range(len(c)): if c[i] not in l and m!=25: print("@") break else: res += d[c[i]]else: print(res)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客21783 牛牛的星际旅行]]></title>
    <url>%2F2021%2F01%2F21%2F%E7%89%9B%E5%AE%A221783%20%20%E7%89%9B%E7%89%9B%E7%9A%84%E6%98%9F%E9%99%85%E6%97%85%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[题目描述在一个遥远的星球上，每周有N天，牛牛去了这个星球旅游，他恰好只带了N件不同的衣服，编号为1到N每一天他会穿其中的某一件衣服，一周之内不能穿同一件衣服两次，而且假如某件衣服是在第x天穿的，那么下一次最早能穿这件衣服的时期为x+N-1现在已知牛牛在这个星球第一周穿衣服的顺序以及最后一周穿衣服的顺序，计算牛牛在这个星球上最少居住了几周 12345678910111213N = int(input())a = list(map(int, input().split()))b = list(map(int, input().split()))x = []for i in range(N+1): x.append(0)for i in range(N): x[b[i]] = ians = 0for i in range(N): ans = max(ans, i-x[a[i]])print(ans+1)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客15555 1 + 2 = 3？]]></title>
    <url>%2F2021%2F01%2F21%2F%E7%89%9B%E5%AE%A215555%201%20%2B%202%20%3D%203_%2F</url>
    <content type="text"><![CDATA[链接：https://ac.nowcoder.com/acm/problem/15555来源：牛客网时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 131072K，其他语言262144K64bit IO Format: %lld题目描述 小Y在研究数字的时候，发现了一个神奇的等式方程x⊕2x = 3x，他屈指算了一下有很多正整数x满足这个等式，比如1和2，现在问题来了，他想知道从小到大第N个满足这个等式的正整数，请你用程序帮他计算一下。 (⊕表示按位异或运算) 输入描述: 第一行是一个正整数T(T≤100)，表示查询次数。 接着有T行，每行有一个正整数N(N≤10 ^12 )，表示小Y的查询。 输出描述: 对于每一个查询N，输出第N个满足题中等式的正整数，并换行。 等式方程的意思就是 一个二进制数加上这个数左移一位2x等于这两个数的异或和 所以 x不能有相邻1，如果有相邻1的话 异或操作会消掉1 1 10 100101 100010011010 组数是斐波那契数列,每组的第一位是标志位 2^(n-1)先算出组数，通过左移操作确定标志位，再计算其他位 12345678910111213141516171819202122232425262728293031323334353637"""等式方程的意思就是 一个二进制数加上这个数左移一位2x等于这两个数的异或和所以x不能有相邻1，如果有相邻1的话 异或操作会消掉1110 100101100010011010组数是斐波那契数列"""x, y = 1, 1C = [1,2]s = 2ans = 0for i in range(59): x, y = x + y, x s += x C.append(s)def div(n): for i in range(59): if C[i] &gt;= n: break if n == 1 or n == 0: return n else: return (1 &lt;&lt; (i)) + div(n - C[i - 1] - 1)T = int(input())for _ in range(T): u = int(input()) print(div(u))]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16785 Cantor表]]></title>
    <url>%2F2021%2F01%2F21%2F%E7%89%9B%E5%AE%A216785%20%20Cantor%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[先找到第N个数在第几行第几列，然后根据规律进行计算 1234567891011N = int(input())t = 1while N-t &gt; 0: N = N-t t += 1if t%2 == 0: print("%d/%d"%(N,t-N+1))else: print("%d/%d"%(t-N+1,N))]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16662 津津的储蓄计划]]></title>
    <url>%2F2021%2F01%2F21%2F%E7%89%9B%E5%AE%A216662%20%20%E6%B4%A5%E6%B4%A5%E7%9A%84%E5%82%A8%E8%93%84%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[题目描述 津津的零花钱一直都是自己管理。每个月的月初妈妈给津津300元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。 为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上20％还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于100元或恰好100元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。 例如11月初津津手中还有83元，妈妈给了津津300元。津津预计11月的花销是180元，那么她就会在妈妈那里存200元，自己留下183元。到了11月月末，津津手中会剩下3元钱。 津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。 现在请你根据2004年1月到12月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到2004年年末，妈妈将津津平常存的钱加上20％还给津津之后，津津手中会有多少钱。 1234567891011121314151617181920m = []for i in range(12): m.append(int(input()))res = 0remain = 0if m[0] &gt; 300: print(-1)else: res += 100*((300-m[0])//100) for i in range(1, 12): remain = (remain + 300 - m[i-1]) % 100 #print(remain) if (remain + 300) &lt; m[i]: print("-%d"%(i+1)) break else: res += 100*((remain + 300 - m[i])//100) #print(res) else: print(int(res*1.2)+(remain + 300 - m[11]) % 100)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客21297 手机号码]]></title>
    <url>%2F2021%2F01%2F19%2F%E7%89%9B%E5%AE%A221297%20%20%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%2F</url>
    <content type="text"><![CDATA[题目描述给你一个整数n表示手机号码的位数再给你m个字符串表示保留的号码,比如911 110 120等问你一共有多少的手机号码不以保留号码开头 12345678910111213141516171819n, m = map(int, input().split())s = []for _ in range(m): s.append(input())sum = pow(10, n)num = 0for i in range(m): flag = False for j in range(m): if s[i].startswith(s[j]) and i!=j: flag = True break else: continue if flag == False: num += pow(10, n - len(s[i]))print(sum - num)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客21312 神秘餐馆]]></title>
    <url>%2F2021%2F01%2F19%2F%E7%89%9B%E5%AE%A221312%20%20%E7%A5%9E%E7%A7%98%E9%A4%90%E9%A6%86%2F</url>
    <content type="text"><![CDATA[题目描述一家神秘餐馆准备开放N天，牛牛 和 牛妹听到这个消息后，准备尽可能多的一起去吃午饭餐馆有M道菜，牛牛和牛妹每次来只允许点一道菜，如果在第i天买了第j道菜那么第i+7天也只能买第j道菜第i天第j道菜的价格为price[i][j]‘0’-‘9’代表0-9美元‘A’-‘Z’代表10-35美元‘a’-‘z’代表36-61美元 牛牛和牛妹一共只有budget美元，请问他们最多可以吃几天的午饭 123456789101112131415161718192021222324252627282930313233343536373839404142n, m, budget = map(int, input().split())ll = []for i in range(n): ll.append([]) for j in range(m): ll[i].append(0)l = []for i in range(n): l = input() for j in range(m): ll[i][j] = l[j]for i in range(n): for j in range(m): if '0'&lt;=ll[i][j]&lt;='9': ll[i][j] = ord(ll[i][j]) - ord('0') elif 'A'&lt;=ll[i][j]&lt;='Z': ll[i][j] = ord(ll[i][j]) - ord('A') + 10 elif 'a'&lt;=ll[i][j]&lt;='z': ll[i][j] = ord(ll[i][j]) - ord('a') + 36a = []for i in range(7): a.append([]) for j in range(m): a[i].append(0)b = []cost = [0,0,0,0,0,0,0]money = 0for i in range(n): money -= cost[i%7]; for j in range(m): a[i%7][j] += ll[i][j] b.append(a[i%7][j]) cost[i%7] = min(b) money += cost[i%7] b = [] if money &gt; budget: print(i) breakelse: print(n)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16585 统计单词数]]></title>
    <url>%2F2021%2F01%2F18%2F%E7%89%9B%E5%AE%A216585%20%20%20%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例1 ），如果给定单词仅是文章中某一单词的一部分则不算匹配 123456789101112s = input().lower()t = list(map(str, input().lower().split(" ")))# split() 可以跳过多个空格 split(' ') 碰到一个空格就会分割一次if s not in t: print(-1)else: sum = 0 n = t.count(s) index = t.index(s) for i in range(0, index): sum = sum + len(t[i]) print(n, sum + index)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16500 珠心算测试]]></title>
    <url>%2F2021%2F01%2F18%2F%E7%89%9B%E5%AE%A216500%20%20%E7%8F%A0%E5%BF%83%E7%AE%97%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[题目描述珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？最近老师出了一些测验题，请你帮忙求出答案 123456789n = int(input())a = list(map(int, input().split()))ans = []for i in range(n): for j in range(i+1, n): if a[i] + a[j] in a and a[i] + a[j] not in ans: ans.append(a[i]+a[j])print(len(ans))]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16494 生活大爆炸版石头剪刀布]]></title>
    <url>%2F2021%2F01%2F18%2F%E7%89%9B%E5%AE%A216494%20%20%E7%94%9F%E6%B4%BB%E5%A4%A7%E7%88%86%E7%82%B8%E7%89%88%E7%9F%B3%E5%A4%B4%E5%89%AA%E5%88%80%E5%B8%83%2F</url>
    <content type="text"><![CDATA[题目描述 石头剪刀布是常见的猜拳游戏：石头胜剪刀，剪刀胜布，布胜石头。如果两个人出拳一样，则不分胜负。在《生活大爆炸》第二季第8集中出现了一种石头剪刀布的升级版游戏。升级版游戏在传统的石头剪刀布游戏的基础上，增加了两个新手势： 斯波克：《星际迷航》主角之一。 蜥蜴人：《星际迷航》中的反面角色。 这五种手势的胜负关系如表一所示，表中列出的是甲对乙的游戏结果。 现在，小A和小B尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。例如：如果小A以“石头-布-石头-剪刀-蜥蜴人-斯波克”长度为6的周期出拳，那么他的出拳序列就是“石头-布-石头-剪刀-蜥蜴人-斯波克-石头-布-石头-剪刀-蜥蜴人-斯波克-……”，而如果小B以“剪刀-石头-布-斯波克-蜥蜴人”长度为5的周期出拳，那么他出拳的序列就是“剪刀-石头-布-斯波克-蜥蜴人-剪刀-石头-布-斯波克-蜥蜴人-……” 已知小A和小B一共进行N次猜拳。每一次赢的人得1分，输的得0分；平局两人都得0分。现请你统计N次猜拳结束之后两人的得分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263N, NA, NB = map(int, input().split())A = list(map(int, input().split()))B = list(map(int, input().split()))sumA = 0sumB = 0def judge(n, m): if n == 0: if m==2 or m==3: return 1 elif m == 0: return 0 else: return -1 elif n == 1: if m==0 or m==3: return 1 elif m == 1: return 0 else: return -1 elif n == 2: if m==1 or m==4: return 1 elif m == 2: return 0 else: return -1 elif n == 3: if m==2 or m==4: return 1 elif m ==3: return 0 else: return -1 elif n == 4: if m==0 or m==1: return 1 elif m==4: return 0 else: return -1posA = 0posB = 0for i in range(N): if posA==NA: posA = 0 if posB==NB: posB = 0 if judge(A[posA], B[posB])==1: sumA = sumA + 1 elif judge(A[posA], B[posB]) == 0: sumA = sumA else: sumB = sumB + 1 posA = posA + 1 posB = posB + 1 print("&#123;&#125; &#123;&#125;".format(sumA, sumB))]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16438 回文日期]]></title>
    <url>%2F2021%2F01%2F14%2F%E7%89%9B%E5%AE%A216438%20%20%E5%9B%9E%E6%96%87%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738date1 = input()date2 = input()"""判断是否是闰年"""def isLeap(year): if (year%4 == 0 and year%100 != 0) or (year%400 == 0): return 1 else: return 0"""判断是否是回文数"""def isPalindrome(year): for i in range(4): if year[7-i] != year[i]: return 0 return 1ans = 0y1 = int(date1[0:4])y2 = int(date2[0:4])for year in range(y1, y2+1): if isLeap(year): D = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] else: D = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] y = str(year) date = int(y + y[::-1]) #date = year*10000 + year%10*1000 + year%100//10*100 + year%1000//100*10 + year//1000; #date = int(year*10000 + int(y[3])*1000 + int(y[2])*100 + int(y[1])*10 + int(y[0])) #print(date) if(int(date1) &lt;= date &lt;= int(date2) and 0 &lt; (date%10000//100) &lt;= 12 and isPalindrome(str(date)) and date%100 &lt;= D[date%10000//100-1]): ans = ans + 1;print(ans)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16426 玩具谜题]]></title>
    <url>%2F2021%2F01%2F14%2F%E7%89%9B%E5%AE%A216426%20%20%E7%8E%A9%E5%85%B7%E8%B0%9C%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述 南有一套可爱的玩具小人，它们各有不同的职业。有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外，如下图：这时 singer 告诉小南一个谜题：「眼镜藏在我左数第 3 个玩具小人的右数第 1 个玩具小人的左数第 2 个玩具小人那里。」小南发现，这个谜题中玩具小人的朝向非常关键， 因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。小南一边艰难地辨认着玩具小人，一边数着：singer 朝内，左数第 3 个是 archer。archer 朝外，右数第 1 个是 thinker。thinker 朝外，左数第 2 个是 writer。所以眼镜藏在 writer 这里！虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜题具体可以描述为：有 n 个玩具小人围成一圈，已知它们的职业和朝向。现在第 1 个玩具小人告诉小南一个包含 m 条指令的谜题。其中第 i 条指令形如「左数/右数第 si 个玩具小人」。你需要输出依次数完这些指令后，到达的玩具小人的职业。 输入描述:输入的第一行包含两个正整数 n, m，表示玩具小人的个数和指令的条数。接下来 n 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 0 表示朝向圈内，1 表示朝向圈外。保证不会出现其他的数。字符串长度不超过 10 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之问用一个空格隔开。接下来 m 行，其中第 i 行包含两个整数 ai, si，表示第 i 条指令。若 ai = 0，表示向左数 si 个人；若 ai = 1，表示向右数 si 个人。保证 ai 不会出现其他的数。1 ≤ si &lt; n。 输出描述:输出一个字符串，表示从第一个读入的小人开始，依次数完 m 条指令后到达的小人的职业。 123456789101112131415161718192021222324n, m = map(int, input().split())name = []pos = []a = []s = []for _ in range(n): x1, x2 = map(str, input().split()) x1 = int(x1) pos.append(x1) name.append(x2)for _ in range(m): x3, x4 = map(int, input().split()) a.append(x3) s.append(x4)t = 0for i in range(m): if pos[t] != a[i]: t += s[i] else: t -= s[i] t = t % nprint("&#123;&#125;".format(name[t]))]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客16437 买铅笔]]></title>
    <url>%2F2021%2F01%2F14%2F%E7%89%9B%E5%AE%A216437%20%E4%B9%B0%E9%93%85%E7%AC%94%2F</url>
    <content type="text"><![CDATA[题目描述P老师需要去商店买n支铅笔作为小朋友们参加NOIP的礼物。她发现商店一共有 3 种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起见，P老师决定只买同一种包装的铅笔。商店不允许将铅笔的包装拆开，因此P老师可能需要购买超过 n 支铅笔才够给小朋友们发礼物。现在P老师想知道，在商店每种包装的数量都足够的情况下，要买够至少 n 支铅笔最少需要花费多少钱。 输入描述： 第一行包含一个正整数 n ，表示需要的铅笔数量。接下来三行，每行用 2 个正整数描述一种包装的铅笔：其中第 1 个整数表示这种 包装内铅笔的数量，第 2 个整数表示这种包装的价格。保证所有的 7 个数都是不超过 10000 的正整数。 输出描述:1 个整数，表示P老师最少需要花费的钱。 12345678910输入572 250 3030 27输出54 12345678from math import ceil n = int(input())minp = 10000000000000000000000000000for _ in range(3): c,p = map(int,input().split()) m = ceil(n/c)*p minp = min(minp,m)print(minp)]]></content>
      <tags>
        <tag>NOWCODER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流数据模型]]></title>
    <url>%2F2020%2F12%2F08%2F%E6%B5%81%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[流数据模型和传统的关系模型（Relational Model）有几个重要的区别：（1） 数据流的数据元素持续到达（2） 流数据处理系统不能控制数据元素到达的顺序（3） 数据流有可能是无限的，或者说数据流的大小是无限大（Infinite）（4） 数据流的一个数据元素被处理后，可以丢弃或者归档（Archived），一般不容易再次提取，除非目前该数据元素还在内存中。能够保存在内存中的数据元素，相对整个数据流来讲是极少量的数据。 在关系数据库的数据模型里，数据以元组（记录）的形式组织在关系中。我们可以对这些表格里的元组及其属性进行任意的增加、删除、修改。在流数据模型中，数据流可以看作 只允许进行元组添加操作 的关系表。对应关系数据库的SQL查询语句，在数据流上，我们可以使用经过扩展的SQL语句，进行数据流的查询。]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AdaBoost算法 入门]]></title>
    <url>%2F2020%2F12%2F07%2FAdaBoost%20%E7%AE%97%E6%B3%95%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[AdaBoost 是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器，即弱分类器，然后把这些弱分类器集合起来，构造一个更强的最终分类器。算法的适应性在于前一个基本分类器分错的样本会得到加强，加权后的全体样本再次用来训练下一个基本分类器。同时，在每一轮中加入一个新的弱分类器，直至达到某个预定的足够小的错误率或达到预先指定的最大迭代次数。 具体来说，整个 AdaBoost 迭代算法包含 3 个主要步骤：（1）初始化训练数据的权值分布。如果有 M 个样本，则每一个训练样本最开始时都被赋予相同的权值：1/M。 （2）训练弱分类器。在训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。在 t 轮训练结束后，根据得到的弱分类器 h_t 的性能，计算该分类器对应的权值 αt ，并由 h_t 在训练集上的分类结果对权重向量 W_i→ W(i+1) 进行更新。接着，权值更新过的样本集用于训练下一个分类器，整个训练过程如此迭代地进行下去。 （3）将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起较大的决定作用，降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起较小的决定作用。换言之，误差率低的弱分类器在最终分类器中占的权重较大，否则较小。 AdaBoost 算法的特点： AdaBoost 是一种具有很高精度的分类器，其算法具有如下特点： （1） 可以使用各种方法构建子分类器，AdaBoost 算法提供对其进行组合以及提升的框架。（2） 当使用简单分类器时，计算出的结果是可以理解的。（3） 弱分类器构造极其简单，无须做特征筛选。（4） AdaBoost 算法简单，不用调整分类器，不会导致过拟合。 AdaBoost 算法的应用： （1） 用于二值分类或多分类的应用场景。（2） 用于特征选择（Feature Selection）。（3） 无须变动原有分类器，而是通过组合出新的分类器，提升分类器的性能。 （1）D1 表示样本的初始权重分配，数据点包含两类数据，两种颜色。在 AdaBoost算法运行过程中，我们使用水平或者垂直的直线作为分类器来进行分类。算法最开始给了一个均匀分布D。因此，h_1 里的每个点的权重是0.1。 （2）利用第一个分类器进行划分，有三个数据点划分错了，根据误差公式，计算得到带权的误差为：ɛ_1 = （0.1+0.1+0.1）= 0.3。第一个分类器的权重a_1 为0.42。根据算法要求，把分错的数据点的权值变大，得到新的权重分布。 至此，根据分类的正确率得到一个新的样本权重分布 D_2 ，一个子分类器h_1。 （3）进行第2次迭代，根据分类的正确率，得到一个新的样本权重分布 D3 以及一个子分类器 h2 。（4）计算最后一个分类器的错误率和权重，得到最后一个分类器的权重为 h3。 （5）整合所有子分类器，即对其进行加权求和。从结果中看，即使简单的分类器，组合起来也能获得很好的分类效果。]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流式处理和批处理的区别]]></title>
    <url>%2F2020%2F12%2F07%2F%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86%E5%92%8C%E6%89%B9%E5%A4%84%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[流式处理（Stream Processing） 是针对 批处理（Batch Processing）来讲的，即它们是两种截然不同的数据处理模式，具有不同的特点，适用于不同的应用场合。不能简单地认为其中一种数据处理模式优于另一种数据处理模式。对于批处理来讲，首先数据被不断地采集，保存到数据库中，然后进行分析处理（包括SQL查询）。批处理适用于对大量数据（High Volume）进行处理的场合。人们需要等到整个分析处理任务完成，才能获得最终结果。由于需要处理的数据集大小以及计算机系统的计算能力的差异，整个过程有时需要耗费相当长的时间，即获得最终分析处理结果的延迟较大。批处理是最通用的数据处理模式。传统的关系数据库系统、Hadoop以及Spark大数据处理平台等，都采用了这样的数据处理模式，或者以该处理模式为主。由于需要完整地保存整个数据集，并且在上面进行分析处理，比起流式数据处理系统，人们需要投入更多的硬件资源。 批处理系统可以存取已经入库的所有数据，人们可以对数据进行复杂深入的分析，分析处理的延迟以分钟或者小时计。批处理作业（Job）一旦提交，则一直运行，直到获得最终结果或者失败退出，无需用户人工干预。这些作业在整个数据集或者某个子集上执行一系列的分析，产生分析结果。在性能方面，批处理系统主要考虑系统的吞吐能力，而不是单个分析处理任务的处理延迟（Latency）。 在流式数据处理模式里，数据持续到达，系统及时处理新到达的数据，并不断产生输出。处理过的数据一般丢弃掉，当然也可以保存起来。流式数据处理模式强调数据处理的速度（Velocity）。部分原因是数据产生的速度很快，需要及时进行处理。由于流式数据处理系统能够对新到达的数据进行及时的处理，所以它能够给决策者提供最新的事物发展变化的趋势，以便对突发事件进行及时响应，调整应对措施。 实时（Real-time）数据处理系统和流式数据处理系统：对于批量数据处理系统，当分析处理的响应速度快到一定的程度，这样的系统可以称为实时系统（响应时间达到毫秒级）或者交互式系统（响应时间达到秒级或者亚秒级）。 流式数据处理模式对每个新到达的数据元素（Data Element）或者一个比较小的时间窗口内的数据元素进行计算。数据上的计算或者分析处理相对来讲是比较简单的，不是复杂的分析处理。完成分析处理的时间，需要达到实时或者接近实时的响应时间要求。不同数据元素上的分析处理，相互之间是独立的。流式数据处理系统要尽快完成数据的处理。上游数据源无须等待下游流式数据处理系统处理完毕。 即席查询（Ad-Hoc）：即席查询是用户根据自己的需求，灵活的选择查询条件，系统能够根据用户的选择生成相应的统计报表。即席查询与普通应用查询最大的不同是普通的应用查询是定制开发的，而即席查询是由用户自定义查询条件的。 例如： 在一个电子商务网站，把每月（周、天）所有的交易记录保存起来，然后在固定的时间点，比如月末（周末、日终）进行一些SQL查询分析，这种处理模式就是批处理模式。当然，在系统不断累积交易记录的过程中，比如在某天的中午，管理者想看一下某个商品最近一段时间的销售量，他临时发起一个SQL查询，这个查询就称为即席查询。]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关联规则分析Apriori算法 简介与入门]]></title>
    <url>%2F2020%2F12%2F05%2F%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E5%88%86%E6%9E%90%20Apriori%20%E7%AE%97%E6%B3%95%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[关联规则的几个概念：关联规则是形如 X -&gt; Y 的蕴含式，表示通过 X 可以推导出 Y，X称为关联规则的左部（Left Hand Side，LHS），Y 称为关联规则的右部（Right Hand Side，RHS）。关联规则有两个指标，分别是支持度（Support）和置信度（Confidence）。关联规则A -&gt; B 的支持度（support）= P(AB)，指的是事件 A 和事件 B 同时发生的概率。置信度（confidence） = P(B|A) = P(AB) / P(A)，指的是发生事件A的基础上，发生事件B的概率。比如，如果尿布-&gt;啤酒关联规则的支持度为 30%，置信度60%，那么就表示所有的商品交易中，30% 交易同时购买了尿布和啤酒，在购买尿布的交易中，60% 的交易同时购买了啤酒。 关联规则分析需要从基础数据中挖掘出支持度和置信度都超过一定阈值的关联规则，以便在决策中应用。同时满足最小支持度阈值和最小置信度阈值的规则，称为强规则。 挖掘关联规则的主流算法为 Apriori 算法。它的基本思想是在数据集中找出同时出现概率符合预定义（Pre-defined）支持度的频繁项集，而后从以上频繁项集中，找出符合预定义置信度的关联规则。 原理： 如果某个项集是频繁的，那么它的所有子集也是频繁的。它的逆否命题是，如果一个项集是非频繁的，那么它的所有超集也是频繁的。 在上图中，已知阴影项集{商品2，商品3}是非频繁的。利用这个基础知识，我们可以知道项集 {商品0，商品2，商品3}，{商品1，商品2，商品3} 以及 {商品0，商品1，商品2，商品3} 也是非频繁的，因为它们是 {商品2，商品3} 的超集。于是在计算过程中，一旦计算出 {商品2，商品3} 的支持度，知道它是非频繁的后，就可以紧接着排除它的超集，节省了计算工作量。]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类算法支持向量机（SVM）简介与入门]]></title>
    <url>%2F2020%2F12%2F05%2F%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%EF%BC%88SVM%EF%BC%89%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[在二维平面上，把两类数据分开需要一条直线。到了3微空间，要把两类数据分开，就需要一个平面。把上述分类机制扩展到基本情形，在高维空间里，把两类数据分开，则需要一个超平面。直线和平面是超平面在2维和3维空间的表现形式。当我们处理的是100维数据时，超平面就是一个99维的对象。支持向量： 我们寻找分类函数 y=f(x)= ω^T x+b，超平面上的点代入这个分类函数，得到 f(x)=0，超平面一边的数据点代入分类函数，得到 f(x)= 1；在超平面另一边的数据点代入分类函数得到 f(x)= -1。在二维平面上，这个分类函数对应一根直线 y=f(x)=ax+b。 在二维平面上确定一根直线，就是确定上述方程中的 a 和 b。在高维空间上确定一个超平面，则需要确定 ω 向量和 b 向量。我们需要寻找一个超平面，它到两个类别数据点的距离都尽可能大，这样的超平面为最优的超平面。在上图中，中间的那根直线到两类数据点的距离是相等的，为了确定这根直线，不需要所有的数据点（向量），只需要图中显示为深色的数据点（向量），这些向量唯一确定了数据划分的直线（超平面），称为支持向量（Support Vector）。 支持向量机是一个对高维数据进行分类的分类器。数据点被划分到两个不相交的半空间（Half Space），从而实现分类，划分两个半空间的是一个超平面，SVM 分类的主要任务是寻找到和两类数据点都具有最大距离的超平面，目的是使得把两类数据点分开的划分范围最大化。]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚类算法K-Means简介与入门]]></title>
    <url>%2F2020%2F12%2F05%2F%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%20K-Means%20%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[K-Means 算法是最简单的一种聚类算法，属于无监督学习算法。聚类和分类最大的不同在于：分类的目标是事先已知的，而聚类则不一样，聚类事先不知道目标变量是什么，类别没有像分类那样被预先定义出来。假设我们的样本是 {x^(1), x^(2), x^(3),……, x^(m) }，每个 x^(i) ∈ R^n，即它是一个维向量。现在用户给定一个 k 值，要求将样本聚类成 k 个类簇。在这里，我们把整个算法成为聚类算法，聚类算法的结果是一系列的类簇。 步骤：输入：样本集 D，簇的数目 k，最大迭代次数N；输出：簇划分（ k 个簇，使平方误差最小）（1）为每个聚类选择一个初始聚类中心；（2）将样本集按照最小距离原则分配到最邻近聚类；（3）使用每个聚类的样本均值更新聚类中心；（4）重复步骤（2）（3），直到聚类中心不再发生变化；（5）输出最终的聚类中心和 k 个簇划分。 涉及距离的计算，最常用的距离是欧氏距离（Euclidean Distance），公式为：此外，还有闵可夫斯基距离： 曼哈顿距离（也称为城市街区距离，City Block Distance）： 优点：（1） 算法简单，容易实现（2） 算法速度很快（3） 对处理大数据集，该算法是相对可伸缩的和高效率的，因为它的复杂度大约是O（NKt），其中，N 为数据对象的数目，t 为迭代的次数。一般来说， K &lt;&lt;N ，t &lt;&lt;N。这个算法通常局部收敛。（4） 算法尝试找出使平方误差函数值最小的k个划分。当簇是密集的、球状或团状的，且簇与簇之间区别明显时，聚类效果较好。 缺点：（1） K是事先给定的，一个合适的 K 值难以估计。（2） 在 K-Means 算法中，首先需要根据初始类簇中心来确定一个初始划分，然后对初始划分进行优化。初始类簇中心的选择对聚类结果有较大的影响。一旦选择的不好，可能无法得到有效的聚类结果。可以使用遗传算法来选择合适的初始类簇中心。（3） 算法需要不断地进行样本分类调整，不断计算调整后的新的类簇中心，因此当数据量非常大的时，算法的时间开销是非常大的。可以利用采样策略，改进算法效率。也就是初始点的选择，以及每一次迭代完成时对数据的调整，都是建立在随机采样的样本数据的基础之上，这样可以提高算法的收敛速度。]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树简介与入门]]></title>
    <url>%2F2020%2F12%2F05%2F%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[决策树表示对象属性（比如贷款用户的年龄、是否有工作、是否有房产、信用评分等）和对象类别（是否批准其贷款申请）之间的一种映射。使用层层推理来实现最终的分类。 根节点：包含样本的全集 内部节点：对应特征属性测试 叶节点：代表决策的结果预测时，在树的内部节点处用某一属性值进行判断，根据判断结果决定进入哪个分支节点，直到到达叶节点处，得到分类结果。 这是一种基于 if-then-else 规则的有监督学习算法，决策树的这些规则通过训练得到，而不是人工制定的。 决策树是最简单的机器学习算法，它易于实现，可解释性强，完全符合人类的直观思维，有着广泛的应用。 决策树学习的三个步骤 一、特征选择 特征选择决定了使用哪些特征来做判断。在训练数据集中，每个样本的属性可能有很多个，不同属性的作用有大有小。因而特征选择的作用就是筛选出跟分类结果相关性较高的特征，也就是分类能力较强的特征。 在特征选择中通常使用的准则是：信息增益 二、决策树生成 选择好特征后，就从根节点出发，对节点计算所有特征的信息增益，选择信息增益最大的特征作为节点特征，根据该特征的不同取值建立子节点；对每个子节点使用相同的方式生成新的子节点，直到信息增益很小或者没有特征可以选择为止。 三、决策树剪枝剪枝的主要目的是对抗过拟合（模型的泛化能力差），通过主动去掉部分分支来降低过拟合的风险。 三种典型的决策树算法：ID3、C4.5、CART ID3：最早提出的决策树算法，利用信息增益来选择特征C4.5：ID3的改进版，不是直接使用信息增益，而是引入“信息增益比”指标作为特征的选择依据CART：可用于分类，也可用于回归问题。使用基尼系数取代了信息熵模型。 关于信息增益（Information Gain）： 信息熵表示的是不确定性。非均匀分布时，不确定性最大，此时熵就最大。当选择某个特征，对数据集进行分类时，分类后的数据集的信息熵会比分类之前小，其差值表示为信息增益。信息增益可以衡量某个特征对分类结果的影响大小。 对于一个数据集，特征A作用之前的信息熵计算公式为： 式中，D为训练数据集；c 为类别数量；P_i 为类别 i 样本数量占所有样本的比例。对应数据集 D，选择特征 A 作为决策树判断节点时，在特征 A 作用后的信息熵为 InfoA (D) （特征 A 作用后的信息熵计算公式），计算如下： 式中，k 为样本 D 被分为 k 个子集。]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习与数据挖掘简介]]></title>
    <url>%2F2020%2F12%2F05%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[机器学习的目的是预测（包括分类和回归）。 分类是根据输入数据，判别这些数据隶属于哪个类别。回归则是根据输入数据，计算出一个输出值。输入数据一般为一个向量，向量的各个分量也称为特征（Feature），输出则是一个类别或者一个数值。 机器学习方法分为有监督学习（Supervised Learning）、无监督学习（Unsupervised Learning）和半监督学习（Semi- Supervised Learning）。 有监督学习：是机器学习的一种类别，训练数据由输入特征和预期的输出构成，输出可以是一个连续的值（称为回归分析），或者是一个分类的类别标签（称为分类）。如：决策树、支持向量机（SVM）、K最近邻（KNN）算法。 无监督学习：没有训练样本，直接对数据进行建模。K-Means聚类算法就是典型的无监督学习算法，它的目的是把相似的对象聚集在一起。还包含：主成分分析（PCA）等。 半监督学习：是有监督学习和无监督学习相结合的一种学习方法。它研究如何利用少量的标注（Annotated）样本和大量的未标注样本进行训练和预测问题。如：半监督分类、半监督回归、半监督聚类和半监督降维算法。]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[torchvision包的主要构成]]></title>
    <url>%2F2020%2F11%2F26%2Ftorchvision%E5%8C%85%E7%9A%84%E4%B8%BB%E8%A6%81%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[torchvision包是服务于PyTorch深度学习框架的，主要用来构建计算机视觉模型。 torchvision 主要由以下几部分构成： torchvision.datasets：一些加载数据的函数及常用的数据集接口； torchvision.models：包含常用的模型结构（含预训练模型），例如AlexNet，VGG，ResNet等； torchvision.transforms：常用的图片变换，例如裁剪、旋转等； torchvision.utils：其他的一些有用的方法；]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1470. 重新排列数组]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%201470.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。示例 1：123输入：nums = [2,5,1,3,4,7], n = 3输出：[2,3,5,4,1,7] 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7] 示例 2： 12输入：nums = [1,2,3,4,4,3,2,1], n = 4输出：[1,4,2,3,3,2,4,1] 示例 3： 12输入：nums = [1,1,2,2], n = 2输出：[1,2,1,2] 12345678910111213141516class Solution &#123; public int[] shuffle(int[] nums, int n) &#123; int[] res = new int[nums.length]; int j = 0; for(int i = 0; i &lt; nums.length; i++) &#123; res[i] = nums[j]; if(i % 2 == 0) j = j + n; else j = j - n + 1; &#125; return res; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1431. 拥有最多糖果的孩子]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%201431.%20%E6%8B%A5%E6%9C%89%E6%9C%80%E5%A4%9A%E7%B3%96%E6%9E%9C%E7%9A%84%E5%AD%A9%E5%AD%90%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1： 12345678输入：candies = [2,3,5,1,3], extraCandies = 3输出：[true,true,true,false,true] 解释：孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 示例 2： 123输入：candies = [4,2,1,1,2], extraCandies = 1输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 示例 3： 12输入：candies = [12,1,12], extraCandies = 10输出：[true,false,true] 思路：先找到数组中最大的数，然后遍历数组，如果该元素加上extraCandies大于等于最大的那个数，说明该孩子可以成为拥有糖果最多的孩子。 12345678910111213141516171819202122232425class Solution &#123; public List&lt;Boolean&gt; kidsWithCandies(int[] candies, int extraCandies) &#123; List&lt;Boolean&gt; res = new ArrayList&lt;Boolean&gt;(); int max = 0; int maxIndex = 0; for(int i = 0; i &lt; candies.length; i++) &#123; if(candies[i] &gt; max) &#123; max = candies[i]; maxIndex = i; &#125; &#125; for(int j = 0; j &lt; candies.length; j++) &#123; if((candies[j] + extraCandies) &gt;= max) res.add(true); else res.add(false); &#125; return res; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 771. 宝石与石头]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%20771.%20%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[题目： 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。示例 1:12输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3 示例 2: 12输入: J = &quot;z&quot;, S = &quot;ZZ&quot;输出: 0 123456789101112131415161718class Solution &#123; public int numJewelsInStones(String J, String S) &#123; int num = 0; char[] a = new char[J.length()]; for(int i = 0; i &lt; J.length(); i++) &#123; a[i] = J.charAt(i); &#125; for(int j = 0; j &lt; S.length(); j++) for(int k = 0; k &lt; a.length; k++) &#123; if(S.charAt(j) == (a[k])) num++; &#125; return num; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1486.数组异或操作]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%201486.%20%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[题目：给你两个整数，n 和 start 。数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。请返回 nums 中所有元素按位异或（XOR）后得到的结果。示例 1：1234输入：n = 5, start = 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 &quot;^&quot; 为按位异或 XOR 运算符。 示例 2： 123输入：n = 4, start = 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8. 示例 3： 12输入：n = 1, start = 7输出：7 1234567891011121314151617class Solution &#123; public int xorOperation(int n, int start) &#123; int[] a = new int[n]; for(int i = 0; i &lt; n; i++) &#123; a[i] = start + 2 * i; &#125; int res = a[0]; for(int j = 1; j &lt; n; j++) &#123; res = res ^ a[j]; &#125; return res; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode LCP 06. 拿硬币]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%20LCP%2006.%20%E6%8B%BF%E7%A1%AC%E5%B8%81%2F</url>
    <content type="text"><![CDATA[题目：桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。示例 1：12345输入：[4,2,1]输出：4解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例 2： 123输入：[2,3,10]输出：8 12345678910111213141516class Solution &#123; public int minCount(int[] coins) &#123; int n = 0; for(int i = 0; i &lt; coins.length; i++) &#123; int m = 0; if((coins[i] % 2) != 0) m = (coins[i] / 2) + 1; else m = coins[i] / 2; n += m; &#125; return n; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 222. 完全二叉树的节点个数]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%20222.%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目：给出一个完全二叉树，求出该树的节点个数。说明：完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。示例:12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 思路：分为两种情况，第一种是左子树的高度 n 与右子树的高度 m 相同，说明左子树已经填满了，左子树的节点数加上根节点的总数为 2^n，只需遍历右子树的节点个数即可；第二种是 n 与 m 不相等，说明右子树已经填满了，右子树的节点数加上根节点的总数为 2^m，只需遍历左子树的节点个数即可。这里计算节点个数要用到递归的思想。 123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int countNodes(TreeNode root) &#123; if(root == null) return 0; int n = countLevel(root.left); int m = countLevel(root.right); if(n == m)&#123; return (countNodes(root.right) + (1&lt;&lt;n)); &#125; else&#123; return (countNodes(root.left) + (1&lt;&lt;m)); &#125; &#125; private int countLevel(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; return Math.max(countLevel(root.left), countLevel(root.right)) + 1; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1108. IP地址无效化]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%201108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96%2F</url>
    <content type="text"><![CDATA[题目：给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。 所谓无效化 IP 地址，其实就是用 &quot;[.]&quot; 代替了每个 &quot;.&quot;。示例 1：12输入：address = &quot;1.1.1.1&quot;输出：&quot;1[.]1[.]1[.]1&quot; 示例 2： 12输入：address = &quot;255.100.50.0&quot;输出：&quot;255[.]100[.]50[.]0&quot; 思路：直接使用Java的替换函数。 123456class Solution &#123; public String defangIPaddr(String address) &#123; return address.replace(".", "[.]"); &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 237. 删除链表中的节点]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%20237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目：示例 1：123输入：head = [4,5,1,9], node = 5输出：[4,1,9]解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.示例 2：123输入：head = [4,5,1,9], node = 1输出：[4,5,9]解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 123456789101112131415/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1281. 整数的各位积和之差]]></title>
    <url>%2F2020%2F11%2F24%2FLeetCode%201281.%20%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[题目：给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。示例 1：123456输入：n = 234输出：15 解释：各位数之积 = 2 * 3 * 4 = 24 各位数之和 = 2 + 3 + 4 = 9 结果 = 24 - 9 = 15示例 2：123456输入：n = 4421输出：21解释： 各位数之积 = 4 * 4 * 2 * 1 = 32 各位数之和 = 4 + 4 + 2 + 1 = 11 结果 = 32 - 11 = 21 思路：先将 int 类型转换为 String 类型，获取到每一位的值，然后计算和与乘积，返回题目所需的结果。 12345678910111213141516171819202122class Solution &#123; public int subtractProductAndSum(int n) &#123; String s = String.valueOf(n); int x = s.length(); int[] t = new int[x]; int sum = 0; int mul = 1; for(int i = 0; i &lt; x; i++)&#123; t[i] = s.charAt(i) - 48; &#125; for(int j = 0; j &lt; x; j++)&#123; sum += t[j]; mul *= t[j]; &#125; return mul - sum; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1480 一维数组的动态和]]></title>
    <url>%2F2020%2F11%2F22%2FLeetCode%201480%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目：给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。请返回 nums 的动态和。示例 1：123输入：nums = [1,2,3,4]输出：[1,3,6,10]解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 123输入：nums = [1,1,1,1,1]输出：[1,2,3,4,5]解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 12输入：nums = [3,1,2,10,1]输出：[3,4,6,16,17] 思路：遍历相加 1234567891011class Solution &#123; public int[] runningSum(int[] nums) &#123; int[] s = new int[nums.length]; s[0] = nums[0]; for(int i = 1; i &lt; nums.length; i++) s[i] = s[i-1]+nums[i]; // System.out.println(s); return s; &#125;&#125;]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白 LeetCode 5605 检查两个字符串数据是否相等]]></title>
    <url>%2F2020%2F11%2F22%2F%E5%B0%8F%E7%99%BD%20LeetCode%205605%20%E6%A3%80%E6%9F%A5%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%2F</url>
    <content type="text"><![CDATA[题目：给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。数组表示的字符串 是由数组中的所有元素 按顺序 连接形成的字符串。示例 1：123456输入：word1 = ["ab", "c"], word2 = ["a", "bc"]输出：true解释：word1 表示的字符串为 "ab" + "c" -&gt; "abc"word2 表示的字符串为 "a" + "bc" -&gt; "abc"两个字符串相同，返回 true 示例 2： 12输入：word1 = ["a", "cb"], word2 = ["ab", "c"]输出：false 示例 3： 12输入：word1 = ["abc", "d", "defg"], word2 = ["abcddefg"]输出：true 思路：先把字符串数组合并成字符串，再比较两个字符串是否相等，若相等，则返回true；否则，返回false。 1234567891011121314151617class Solution &#123; public boolean arrayStringsAreEqual(String[] word1, String[] word2) &#123; String s1 = ""; String s2 = ""; for(int i = 0; i &lt; word1.length; i++)&#123; s1 = s1.concat(word1[i]); &#125; for(int j = 0; j &lt; word2.length; j++)&#123; s2 = s2.concat(word2[j]); &#125; if(s1.equals(s2)) return true; else return false; &#125;&#125; concat() 方法：用于将指定的字符串参数连接到字符串上。]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白 LeetCode 242 有效的字母异位词]]></title>
    <url>%2F2020%2F11%2F22%2F%E5%B0%8F%E7%99%BD%20LeetCode%20242%20%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[字母异位词字符串由相同字母组成，但允许排列顺序不同。如“aaabbb” 与 “ababab” 是字母异位词，而“aabb” 与 “ab” 不是字母异位词。题目：给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。1234示例 1:输入: s = "anagram", t = "nagaram"输出: true 1234示例 2:输入: s = "rat", t = "car"输出: false 思路：先判断字符串长度是否相同，若不同，直接返回false；若相同则继续判断，给两个字符串排序，若排序后的字符串完全相等，那么返回true，否则，返回false。 12345678910111213141516171819class Solution &#123; public boolean isAnagram(String s, String t) &#123; int ls = s.length(); int lt = t.length(); if(ls != lt) return false; else &#123; char[] arrayS = s.toCharArray(); //把字符串转换为数组 char[] arrayT = t.toCharArray(); Arrays.sort(arrayS); //利用数组帮助类自动排序 Arrays.sort(arrayT); if(Arrays.equals(arrayS, arrayT)) return true; else return false; &#125; &#125; 字符串转为数组 .toCharArray() 数组排序：Arrays.sort(array) 判断数组是否相同：Arrays.equals(array1, array2)]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter notebook 导入和卸载 conda 虚拟环境]]></title>
    <url>%2F2020%2F11%2F21%2FJupyter%20notebook%20%E5%AF%BC%E5%85%A5%E5%92%8C%E5%8D%B8%E8%BD%BD%20conda%20%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一、导入进入Anaconda Prompt，激活要使用的虚拟环境。1conda activate xxx # 你要使用的虚拟环境名称安装 ipykernel 插件， 建议使用 pip 进行安装， conda 安装容易失败1pip install ipykernel安装完成之后，键入以下命令1python -m ipykernel install --name (你要导入的虚拟环境名称) --display-name (你要显示的名称) 例如：打开 jupyter notebook， 可以看到环境已经成功导入 二、删除使用命令 1jupyter kernelspec remove (你要删除的虚拟环境名称 注意不是显示名称) 例如：删除成功 ！]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leaf 叶子(张量)]]></title>
    <url>%2F2020%2F11%2F20%2Fleaf%20%E5%8F%B6%E5%AD%90(%E5%BC%A0%E9%87%8F)%2F</url>
    <content type="text"><![CDATA[在pytorch的tensor类中,有个is_leaf的属性,姑且把它作为叶子节点. is_leaf 为False的时候,则不是叶子节点, is_leaf为True的时候为叶子节点(或者叶张量)所以问题来了: leaf的作用是什么?为什么要加 leaf? 我们都知道tensor中的 requires_grad()属性，当requires_grad()为True时我们将会记录tensor的运算过程并为自动求导做准备，但是并不是每个requires_grad()设为True的值都会在backward的时候得到相应的grad，它还必须为leaf。这就说明： leaf成为了在 requires_grad()下判断是否需要保留 grad的前提条件 is_leaf() 按照惯例,所有requires_grad为False的张量(Tensor) 都为叶张量( leaf Tensor)requires_grad为True的张量(Tensor),如果他们是由用户创建的,则它们是叶张量(leaf Tensor).这意味着它们不是运算的结果,因此gra_fn为None只有是叶张量的tensor在反向传播时才会将本身的grad传入的backward的运算中. 如果想得到当前tensor在反向传播时的grad, 可以用retain_grad()这个属性 例子: &gt;&gt;&gt; a = torch.rand(10, requires_grad=True) &gt;&gt;&gt; a.is_leaf True &gt;&gt;&gt; b = torch.rand(10, requires_grad=True).cuda() &gt;&gt;&gt; b.is_leaf False # b was created by the operation that cast a cpu Tensor into a cuda Tensor &gt;&gt;&gt; c = torch.rand(10, requires_grad=True) + 2 &gt;&gt;&gt; c.is_leaf False # c was created by the addition operation &gt;&gt;&gt; d = torch.rand(10).cuda() &gt;&gt;&gt; d.is_leaf True # d does not require gradients and so has no operation creating it (that is tracked by the autograd engine) &gt;&gt;&gt; e = torch.rand(10).cuda().requires_grad_() &gt;&gt;&gt; e.is_leaf True # e requires gradients and has no operations creating it &gt;&gt;&gt; f = torch.rand(10, requires_grad=True, device="cuda") &gt;&gt;&gt; f.is_leaf True # f requires grad, has no operation creating it]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《动手学深度学习 PyTorch版》学习笔记（三）：线性回归]]></title>
    <url>%2F2020%2F10%2F09%2F%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[线性回归输出是一个连续值，因此适用于回归问题。回归问题在实际中很常见，如预测房屋价格、气温、销售额等连续值的问题。一、基本要素摘自原书模型定义设房屋的面积为 x1，房龄为 x2，售出价格为 y。我们需要建立基于输入 x1 和 x2 来计算输出 y 的表达式，也就是 模型（model） 。顾名思义，线性回归假设输出与各个输入之间是线性关系：其中 w1 和 w2 是 权重（weight），b 是 偏差（bias），且均为标量。它们是线性回归模型的 参数（parameter）。模型输出 yˆ 是线性回归对真实价格 y 的预测或估计。我们通常允许它们之间有一定误差。 模型训练 我们需要通过数据来寻找特定的模型参数值，使模型在数据上的误差尽可能小。这个过程叫作 模型训练（model training），包含三个要素： 训练数据 我们通常收集一系列的真实数据，例如多栋房屋的真实售出价格和它们对应的面积和房龄。我们希望在这个数据上面寻找模型参数来使模型的预测价格与真实价格的误差最小。在机器学习术语里，该数据集被称为 训练数据集（training data set） 或 训练集（training set） ，一栋房屋被称为一个 样本（sample） ，其真实售出价格叫作 标签（label） ，用来预测标签的两个因素叫作 特征（feature）。特征用来表征样本的特点。 损失函数 在模型训练中，我们需要衡量价格预测值与真实值之间的误差。通常我们会选取一个非负数作为误差，且数值越小表示误差越小。一个常用的选择是平方函数。它在评估索引为 i 的样本误差的表达式为：其中常数 1/2 使对平方项求导后的常数系数为1，这样在形式上稍微简单一些。显然，误差越小表示预测价格与真实价格越相近，且当二者相等时误差为0。给定训练数据集，这个误差只与模型参数相关，因此我们将它记为以模型参数为参数的函数。在机器学习里，将衡量误差的函数称为 损失函数（loss function） 。这里使用的平方误差函数也称为 平方损失（square loss） 。通常，我们用训练数据集中所有样本误差的平均来衡量模型预测的质量，即 优化算法 当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫作 解析解（analytical solution） 。本节使用的线性回归和平方误差刚好属于这个范畴。然而，大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值。这类解叫作 数值解（numerical solution）。 在求数值解的优化算法中，小批量随机梯度下降（mini-batch stochastic gradient descent） 在深度学习中被广泛使用。它的算法很简单：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch）B，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。 在训练本节讨论的线性回归模型的过程中，模型的每个参数将作如下迭代： 模型预测 二、线性回归的表示方法如果我们对训练数据集里的3个房屋样本（索引分别为1、2和3）逐一预测价格现在，我们将上面3个等式转化成矢量计算。设： 对3个房屋样本预测价格的矢量计算表达式为yˆ=Xw+b, 其中的加法运算使用了 广播机制]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《动手学深度学习 PyTorch版》学习笔记（二）：自动求梯度]]></title>
    <url>%2F2020%2F10%2F08%2F%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%B1%82%E6%A2%AF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[一、自动求梯度1、requires_grad_(), detach(), torch.no_grad()的区别参考博客：https://www.jianshu.com/p/ff74ccae25f32、.grad_fn每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function, 就是说该Tensor是不是通过某些运算得到的，若是，则grad_fn返回一个与这些运算相关的对象，否则是None。 3、梯度 grad在反向传播过程中是累加的(accumulated)，这意味着每一次运行反向传播，梯度都会累加之前的梯度，所以一般在反向传播之前需把梯度清零 .grad.data.zero_() 在y.backward()时，如果y是标量，则不需要为backward()传入任何参数；否则，需要传入一个与y同形的Tensor 1234x = torch.tensor([1.0, 2.0, 3.0, 4.0], requires_grad=True)y = 2 * xz = y.view(2, 2)print(z) 输出 12tensor([[2., 4.], [6., 8.]], grad_fn=&lt;ViewBackward&gt;) 现在 z 不是一个标量，所以在调用backward时需要传入一个和z同形的权重向量进行加权求和得到一个标量。 123v = torch.tensor([[1.0, 0.1], [0.01, 0.001]], dtype=torch.float)z.backward(v)print(x.grad) 输出 1tensor([2.0000, 0.2000, 0.0200, 0.0020]) 4、中断梯度 123456789101112x = torch.tensor(1.0, requires_grad=True)y1 = x ** 2 with torch.no_grad(): y2 = x ** 3y3 = y1 + y2print(x.requires_grad)print(y1, y1.requires_grad) # Trueprint(y2, y2.requires_grad) # Falseprint(y3, y3.requires_grad) # Truey3.backward()print(x.grad)]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《动手学深度学习 PyTorch版》学习笔记（一）：数据操作]]></title>
    <url>%2F2020%2F10%2F08%2F%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[一、数据操作在PyTorch中，torch.Tensor是存储和变换数据的主要工具。12&quot;tensor&quot;这个单词一般可译作“张量”，张量可以看作是一个多维数组。标量可以看作是0维张量，向量可以看作1维张量，矩阵可以看作是二维张量。1、torch.arange() 和torch.linspace 1234567# arange(s, e, step) =&gt; 从s到e，步长为stepx8 = torch.arange(1, 10, 2)# print(x8)# linspace(s, e, steps) =&gt; 从s到e，均匀切分成steps份x9 = torch.linspace(2,8,3)# print(x9) 2、torch.range() 和torch.arange() 的区别 1234567891011&gt;&gt;&gt; y=torch.range(1,6)&gt;&gt;&gt; ytensor([1., 2., 3., 4., 5., 6.])&gt;&gt;&gt; y.dtypetorch.float32&gt;&gt;&gt; z=torch.arange(1,6)&gt;&gt;&gt; ztensor([1, 2, 3, 4, 5])&gt;&gt;&gt; z.dtypetorch.int64 3、torch.randn与torch.rand的区别 randn 1torch.randn(*sizes, out=None) → Tensor 返回一个包含了从标准正态分布中抽取的一组随机数的张量 size：张量的形状 out：结果张量 rand 1torch.rand(*sizes, out=None) → Tensor 返回一个张量，包含了从区间[0, 1)的均匀分布中抽取的一组随机数 4、NumPy数组与Tensor的互相转换（共享内存） NumPy转Tensor：torch.from_numpy()Tensor转NumPy：numpy()另：可以使用 torch.tensor() 将NumPy数组转换成Tensor，但不再共享内存 5、Tensor on GPU 1234567if torch.cuda.is_available(): device = torch.device("cuda") # GPU y = torch.ones_like(x, device=device) # 直接创建一个在GPU上的Tensor x = x.to(device) # 等价于 .to("cuda") z = x + y print(z) print(z.to("cpu", torch.double)) # to()还可以同时更改数据类型 6、索引 索引出来的结果与元数据共享内存 1234567x = torch.tensor([[1, 2, 3], [4, 5, 6]])print(x)y = x[0, :] # 取出第一行print(y)y += 1print(y)print(x[0, :]) # 源tensor也被改了 输出 12345tensor([[1, 2, 3], [4, 5, 6]])tensor([1, 2, 3])tensor([2, 3, 4])tensor([2, 3, 4]) 7、广播机制 当对两个形状不同的Tensor按元素运算时，可能会触发广播（broadcasting）机制：先适当复制元素使这两个Tensor形状相同后再按元素运算 12345x = torch.arange(1, 3).view(1, 2)print(x)y = torch.arange(1, 4).view(3, 1)print(y)print(x + y) 输出 1234567tensor([[1, 2]])tensor([[1], [2], [3]])tensor([[2, 3], [3, 4], [4, 5]])]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[torch.randn与torch.rand的区别]]></title>
    <url>%2F2020%2F10%2F05%2Ftorch.randn%E4%B8%8Etorch.rand%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[randn1torch.randn(*sizes, out=None) → Tensor 返回一个包含了从标准正态分布中抽取的一组随机数的张量 size：张量的形状 out：结果张量 rand1torch.rand(*sizes, out=None) → Tensor [0,1)之间的均匀分布]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyTorch 之 requires_grad，requires_grad_()，grad_fn]]></title>
    <url>%2F2020%2F10%2F04%2FPyTorch%20%E4%B9%8B%20requires_grad%EF%BC%8Crequires_grad_()%EF%BC%8Cgrad_fn%2F</url>
    <content type="text"><![CDATA[x.grad_fn和x.requires_grad为x的属性 x.grad_fn：积分方法名，默认为None x.requires_grad：是否积分的属性，默认为False x.requires_grad_()：设置积分的方法，设置之后requires_grad为True 123456789101112"""Tensor"""import torch# 创建一个Tensor并设置requires_grad=Truex = torch.ones(2, 2, requires_grad=True)print(x)print(x.grad_fn)y = x + 2print(y)print(y.grad_fn)print(x.is_leaf, y.is_leaf)]]></content>
      <tags>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指定tensorflow运行的GPU或CPU设备]]></title>
    <url>%2F2020%2F07%2F29%2F%E6%8C%87%E5%AE%9Atensorflow%E8%BF%90%E8%A1%8C%E7%9A%84GPU%E6%88%96CPU%E8%AE%BE%E5%A4%87%2F</url>
    <content type="text"><![CDATA[如果 TensorFlow 指令中兼有 CPU 和 GPU 实现，当该指令分配到设备时，GPU 设备有优先权。 如果你的系统里有多个 GPU, 那么 ID 最小的 GPU 会默认使用。 当我们要指定tensorflow运行的GPU或CPU设备时，可以使用tf.device()命令 首先查看可用运算设备(CPU,GPU) 12from tensorflow.python.client import device_libprint(device_lib.list_local_devices()) 得到类似以下的输出结果 123456789101112131415[name: "/device:CPU:0"device_type: "CPU"memory_limit: 268435456locality &#123;&#125;incarnation: 13177083330855175469, name: "/device:GPU:0"device_type: "GPU"memory_limit: 10968950375locality &#123; bus_id: 1&#125;incarnation: 6161624703599064583physical_device_desc: "device: 0, name: GeForce GTX 1080 Ti, pci bus id: 0000:00:08.0, compute capability: 6.1"] name即是对应设备名称，一般来说（以各自实际情况为准，每个人的情况可能不同） 123&quot;/cpu:0&quot;：机器的 CPU。&quot;/device:GPU:0&quot;：机器的 GPU（如果有一个）。&quot;/device:GPU:1&quot;：机器的第二个 GPU（以此类推）。 使用命令tf.device()进行指定 12import osos.environ["CUDA_VISIBLE_DEVICES"] = '/device:GPU:0']]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[module ‘tensorflow‘ has no attribute ‘sparse ‘]]></title>
    <url>%2F2020%2F07%2F29%2Fmodule%20%E2%80%98tensorflow%E2%80%98%20has%20no%20attribute%20%E2%80%98sparse%20%E2%80%98%2F</url>
    <content type="text"><![CDATA[非常奇怪的一个报错，在查找资料无果的情况下选择了重装keras（应该是版本对应出现了问题），报错解决]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习环境搭建之Anaconda安装keras]]></title>
    <url>%2F2020%2F07%2F29%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B9%8BAnaconda%E5%AE%89%E8%A3%85keras%2F</url>
    <content type="text"><![CDATA[一、确定安装版本号搭环境遇到一堆坑，总结一点最重要的就是要选择好版本。 这里我们要注意tensorflow与keras的版本对应关系。见下图 二、使用pip进行安装 这里注意首先要激活对应的环境 1pip install keras==版本号 后续有时间再补充安装tensorflow-gpu以及pytorch的教程]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下进入Anaconda Prompt以及Navigator]]></title>
    <url>%2F2020%2F07%2F29%2FLinux%E4%B8%8B%E8%BF%9B%E5%85%A5Anaconda%20Prompt%E4%BB%A5%E5%8F%8ANavigator%2F</url>
    <content type="text"><![CDATA[一、进入Anaconda Promp 打开终端，cd 进Anaconda下的bin目录 1conda activate 退出 1conda deactivate 二、进入Anaconda Navigator 1anaconda-navigator]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哔哩哔哩n倍速播放视频]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9n%E5%80%8D%E9%80%9F%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%2F</url>
    <content type="text"><![CDATA[在b站看一些学习视频的时候，有时候2倍速满足不了我们的需求，可以在控制台键入以下命令实现n倍速播放视频 1document.querySelector('video').playbackRate = 3]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层的基本概念]]></title>
    <url>%2F2020%2F06%2F13%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[网络层的功能网络层负责实现各种不一样的物理网络的互联 网络层采用分组交换技术 网络层应当使用统一编址 路由器使用存储转发实现异构网络的互联 网络层关注分组从一个网络到达另一个网络的选路问题 资源子网与通信子网资源子网 负责全网的数据处理业务，向网络用户提供各种网络资源与网络服务。 传输层应用层属于资源子网，关注端到端通信 通信子网 完成网络数据传输转发等通信处理任务 网络层、数据链路层和物理层属于通信子网，负责网络通信转发 分组交换网络的路由模式路由模式的概念 分组选路的方式 网络根据路由模式分类 数据报网络：无连接不可靠的网络 虚电路网络：面向连接可靠的网络 数据报网络特点： 在网络层没有连接建立过程 路由器不维护端对端的连接状态 一般分组使用目标主机的ID（即IP地址）进行路由选择 同样的收发双方的不同分组可能经由的路径可能不同 虚电路网络特点： 发送分组之前会建立一条虚拟的电路（永久PVC或临时SVC）； 每个分组携有标签（虚电路ID），由标签来确定下一跳； 在连接建立阶段确定固定的路由，全部数据通过同一条路传递； 路由器为每个正在通信中的连接维持状态 QoS的基本概念 QoS（Quality of Service）服务质量是指允许用户在带宽、延迟、抖动、可靠性（丢包率）等方面获得可预期的服务水平的一系列技术的集合。 抖动：延迟的变化程度 数据报网络和虚电路网络比较 数据报网络：无连接，可靠性不强，可能形成环路，但是速度快，路由器的工作相对小，不容易实现QoS（服务质量保证）虚电路网络：面向连接可靠性较好，路由器需要为每个虚电路维护状态，代价较高，建立虚电路需要时间，容易实现QoS 网络层提供的服务 因特网模型：无连接不可靠灵活的数据包网络传输服务 ATM网络：面向连接可靠的虚电路传输服务 因特网的选择 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据包服务 网络在发送分组时不需要先建立连接。每一个分组（即IP数据报）独立发送，与其前后的分组无关（不进行编号） 网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序，当然也不保证分组传送的时限 因特网特点：灵活、适应性强、网络成本相对低]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP的拥塞控制机制]]></title>
    <url>%2F2020%2F06%2F13%2FTCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[拥塞： 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏，产生拥塞 若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降 拥塞控制： 保证网络能够承受现有的网络负荷 开环控制和闭环控制开环控制 在设计网络时事先将有关发生的拥塞的因素考虑周到，力求网络在工作时不产生拥塞 闭环控制 基于反馈环路的概念 监测网络系统以便检测到拥塞在何时、何处发生 将拥塞发生的信息传送到可采取行动的地方 调整网络系统的运行以解决出现的问题 TCP拥塞控制思想特性 使用拥塞窗口cwnd控制发送窗口大小 发送窗口的上限值 = Min [rwnd，cwnd] 分组超时意味着拥塞，分组收到确认则意味着网络未拥塞 拥塞则少发（拥塞窗口减小），没拥塞则多发（拥塞窗口增加） 在网络未知的情况下拥塞窗口从最小开始 收到确认拥塞窗口大小增加 为提高效率，开始窗口增加速度快，到了一定阶段窗口增加速度变慢 举例 总结两个阶段 慢启动阶段 - - - 乘法增 拥塞避免阶段 - - - 加法增 一个阈值 定义了慢启动阶段和拥塞避免阶段的分界点 超时发生时 阈值变成超时的窗口大小的一半 回到慢启动 快恢复算法 当发送端收到连续3个重复的确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半，直接进入拥塞避免阶段 LAND攻击攻击方法及原理 方法：将TCP包的源地址和目的地址，源端口和目的端口都设置成相同，导致对方死机 原理：TCP连接管理的实现存在漏洞]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议详解]]></title>
    <url>%2F2020%2F06%2F11%2FTCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、TCP的设计理念 传输层协议 端到端控制，实现分用和复用 可靠传输机制 保证端到端数据按序正确的到达、序号机制、确认机制、差错检测机制、缓存机制、重传机制、滑动窗口机制 其他机制 流量控制机制、拥塞控制机制 TCP协议的可靠传输机制TCP的首部 源端口和目的端口字段——各占2字节。端口是传输层与应用层的服务接口，类似一个地址标识。传输层的复用和分用功能都要通过端口才能实现 序号字段——占4字节。TCP连接中传送的数据流中的每一个字节都编上一个号。序号字段的值指的是本报文段所发送的数据的第一个字节的编号 确认号字段——占4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。注意，当有数据要发送给对方时，顺便确认，当没有数据发送给对方时，单独发一个确认报文 特殊标记（Flag）：每个标记占一个bit，有特殊约定 URG——紧急比特标记，当URG置为1时，表明紧急指针字段有效。通知本报文段中有紧急数据，应尽快传送，紧急数据的优先级要高。 ACK——只有当ACK置为1时，确认号字段才有效。正常情况下只有第一次握手时ACK=0 PSH（Push）——推送比特，接收方收到推送比特置为1的报文段，就尽快地将该报文段的数据交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付 RST（ReSet）——复位比特，当RST=1时，表明TCP连接中出现严重差错，必须强行释放连接，属于单方面强行断开连接 SYN——同步比特，SYN置为1，表示这是一个连接请求报文。正常情况下只有第一次握手和第二次握手时SYN等于1，其余都等于0 FIN（Final）——终止比特，用来正常释放一个连接。当FIN=1时，表明此报文段的发送端的数据已发送完毕，并请求对方释放连接，当对方确认后，会释放发送缓存 窗口字段——占2字节。窗口字段是流量控制的关键，用来控制对方发送窗口的大小，单位为字节。接收方根据自身的缓存大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限 检验和——占2字节。检验和字段检验的范围包括首部和数据这两部分，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部 紧急指针字段——占16bit，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号 TCP的确认机制序号 按字节编号 确认 期望确认：期待对方发送的下一个报文的序号 累积确认：收到某个分组的确认意味着该分组及之前所有分组都正确收到 特殊报文的确认问题 对于没有包含数据的确认报文段不再确认 对于含特殊标记的数据段，即使没有任何的数据接收，确认号也要加1 TCP 建立连接的作用作用： 使每一方能够确知对方的存在 允许双方协议一些参数（如最大报文段长度，最大窗口大小，服务质量等） 对传输实体资源进行分配 TCP的三次握手建立连接 注意：这个时候如果客户端再发请求，序号还是从x+1开始 注意： 建立连接时会初始化相关参数，分配缓存等资源 服务端收到第一次握手后默认会跟踪该连接75秒 SYN Flooding攻击 攻击原理：服务器进行第二次握手之后会在超时时间内（一般为75秒）跟踪该连接，未收到第三次握手会不断重发，消耗资源 攻击防范 缩短TCP超时时间 更改TCP的搬开连接数 TCP-z，监控TCP状态 通过防火墙、路由器等过滤网关防护 使用SYN Cookie技术 TCP的四次挥手断开连接 TCP的时间等待计时器 防止最后一个ACK丢失导致断开连接出现异常 一般等于二倍报文段寿命长度 保活计时器 防止两个TCP之间的连接长时间的空闲 TCP的重传机制 选择性重传机制 当数据超时则需要重传，需要重传定时器 TCP属于使用累积确认的选择性重传协议 重传超时时间的确定 快重传机制 当连续收到三个重复的确认，直接重传所需分组，提高效率 TCP的流量控制接收方：明确地通过TCP首部的窗口字段发送接收窗口大小，从而限制发送方发送窗口的最大值发送方：保证发送窗口大小不超过对方发送的接收窗口的大小]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口协议]]></title>
    <url>%2F2020%2F06%2F10%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[滑动窗口协议核心思想： 发送方在没有收到对方的ACK的时候可以发送多个数据包 特性 发送方使用发送窗口限制没收到确认时允许发送的数据量 必须增加序号的个数，发送方和接收方需要增加缓存 常见的两种滑动窗口协议：GBN（回退N步）和SR（选择性重传） GBN的工作方式 发送方：窗口不满则发送至窗口满，窗口满则等待，收到确认窗口向后移动，某个分组出错或丢失则重传该分组及其后面所有已发送但未被确认的分组 接收方：对按序正确到达的分组确认，乱序或错误的分组丢弃且发送最后一次正确收到的分组的确认 累计确认机制 发送方收到某个分组的确认意味着该分组及之前所有分组接收方都正确收到 GBN协议演示 SR的工作方式SR（selective repeat）选择性重传 发送方某个分组出错或丢失只重传该分组 接收方增加接收窗口（接收缓存），若收到的分组在接受窗口内且乱序，缓存该分组，等到分组按序后一起提交，接收窗口的大小一般等于发送方发送窗口的大小 也是累计确认 SR的演示 窗口大小和序号的关系 GBN窗口的最大值等于序号的个数-1 SR窗口的最大值等于序号的一半]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP协议、电子邮件系统与Telnet远程控制]]></title>
    <url>%2F2020%2F06%2F08%2FFTP%E5%8D%8F%E8%AE%AE%E3%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8ETelnet%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、FTP协议概述FTP定义 文件传输协议 用于因特网文件传输 FTP特性 使用客户端/服务器模式 使用TCP提供可靠的传输 FTP属于维护状态的协议 FTP使用两条TCP连接完成数据传输 FTP的两条连接数据连接问题 当有具体文件或目录内容传输时，临时建立数据连接 主动模式下由服务器方发起，服务器端口号20 被动模式下由客户端发起，服务器端口号不确定 二、电子邮件系统的组成电子邮件系统的组成用户代理 电子邮件客户端软件，如浏览器，Outlook，Outlook Express，Foxmail等 邮件服务器 提供邮件服务的主机，如sina邮件服务器sina.com，google的邮件服务器gmail.com 邮件发送和接收协议 HTTP，SMTP，POP，IMAP等 SMTP协议SMTP协议定义 Simple Mail Transfer Protocol：简单邮件传输协议 用于使用邮件代理发给邮件服务器或邮件服务器之间转发邮件 SMTP特性 使用TCP可靠的传送邮件报文，服务器监听端口号为25 使用命令/响应代码完成邮件传输的控制交互 SMTP只能传送7bit的ASCII码的邮件报文 SMTP采用持续连接的方式发邮件 问题1：SMTP无认证 将导致大量的垃圾邮件 ESMTP：增强型SMTP，发邮件需要用户名密码验证 问题2：SMTP只能传输ASCII码的文本文件 使用MIME多目标邮件拓展协议 MIME使用BASE64编码或QP编码将非ASCII码转为ASCII码 邮件接收协议简介 用户收取邮件常用的协议 POP（Post Office Protocol邮局协议）：服务器端口默认110 IMAP（Internet Mail Access Protocol）【因特网邮件访问协议】：服务器默认端口143 HTTP POP3协议 IMAP协议 IMAP具备和POP一样的邮件下载功能 IMAP允许只读取邮件中的某一个部分 IMAP提供操作的三种模式1、在线方式：邮件保留在Mail服务器端，客户端可以对其进行管理。其使用方式与WebMail相类似2、离线方式：邮件保留在客户端，客户端可以对其进行管理3、分离方式：邮件的一部分在Mail服务器端，一部分在客户端 三、Telnet远程控制 Telnet用于终端使用命令行方式对服务器进行远程控制。端口号为TCP的23 Telnet的客户端称为VTY（虚拟终端），Telnet不安全，明文传输，可以用更安全的SSH协议替代]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP报文的格式]]></title>
    <url>%2F2020%2F06%2F08%2FHTTP%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、HTTP请求报文的格式 两个回车换行表示首部的结尾 注意：HTTP协议首部使用ASCII码作为编码方式 HTTP请求报文提交表单时会包含数据 二、HTTP响应报文格式]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[www万维网和HTTP协议]]></title>
    <url>%2F2020%2F06%2F06%2Fwww%E4%B8%87%E7%BB%B4%E7%BD%91%E5%92%8CHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[万维网的相关概念万维网的客户端程序 浏览器：IE、firefox、chrome 万维网的服务器端软件 IIS，Tomcat、Apache 万维网的模式 采用C/S模式 Web页面 由文字、图片、声音、视频等多种对象组成 HTTP协议 Web页面传输方式 如何标志分布在因特网上的万维网文档？ 使用整个因特网范围内唯一的统一资源定位符URL（Uniform Resource Locator）来标识万维网上的各种文档 &lt;URL的访问方式&gt;：// &lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; &lt;URL的访问方式&gt;ftp：文件传送协议http：超文本传送协议https：基于安全的套接层的http协议 &lt;主机&gt;：存放资源的主机在因特网中的域名或IP地址&lt;端口&gt;：根据协议有默认值，如http为80端口，https为443，默认端口可以省略&lt;路径&gt;：文件在主机中的相对位置，当路径省略时自动打开默认文档 HTTP协议概述定义 超文本传输（hypertext transfer protocol）协议。 定义WEB页面在因特网上的交互方式的应用层协议。 WEB页面传输需要可靠传输吗？需要，使用TCP协议作为传输层，服务器默认端口号为80 页面文本和链接的对象怎么传输？ HTTP1.0：RFC 1945定义 HTTP1.1：RFC 2068定义 HTTP1.0默认特性非持续连接：传完一个对象就断开连接，获得对象至少需要2 RTTS（建立连接和获取对象），每次传送都要受到TCP初始化时慢启动影响非流水线作业方式 HTTP1.1的默认特性持续连接：一条TCP连接传多个对象流水线作业方式 HTTP协议首部的格式 HTTP请求报文 HTTP响应报文 HTTP协议的设计原则 满足协议的功能 注意协议的拓展性 便于程序处理 注意协议的通信效率 其他细节的处理]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS域名系统详解]]></title>
    <url>%2F2020%2F06%2F04%2FDNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、分层次的域名结构 顶级域名、 二级域名、 三级域名、 四级域名 二、因特网的域名结构 因特网采用了层次树状结构的命名方法，称为域名，如：www.jxnu.edu.cn三级域名：如www表示万维网二级域名：如jxnu表示江西师大一级域名：如edu表示教育网顶级域名：如cn表示中国 一个域名可以对应多个IP吗？可以一个IP可以对应多个域名吗？可以 三、域名服务器的工作方式1、域名服务器的分类域名系统是分级别的，所以域名服务器也是有层次的，域名服务器本身也有域名 本地域名服务器 针对主机而言，主机首先将DNS请求发给本地的域名服务器 根域名服务器 用于解释.com、.net等顶级域名的服务器 权威域名服务器 能够权威的解释某个域名和IP对应的服务器 2、DNS的查询方式DNS递归查询服务器与服务器DNS迭代查询主机与服务器 DNS的查询优化 问题：每次访问网页都需要首先进行DNS请求，效率不高，如何能够提高效率？ 使用缓存机制可以提高效率—— 客户端短期内会将DNS映射缓存—— DNS服务器从上级DNS服务器获得的DNS映射会缓存—— 缓存的映射必须有生存时间 缓存的利与弊讨论—— 导致有时无法及时获得更新的DNS映射—— 导致DNS的负载均衡无效 DNS的负载均衡 将一个域名对应多个IP（多台相同的服务器），域名服务器收到域名查询请求时将IP轮流分配给不同的客户端，使得不同的客户端访问不同的服务器，实现服务器的负载均衡。 DNS的反向查询 DNS查询模式包括正向查询和反向查询 正向查询根据域名找IP（包括递归查询和迭代查询） 反向查询是指通过IP地址获得相应的域名 DNS协议格式 DNS服务器使用TCP/UDP的53端口 客户端浏览器发出的DNS查询使用UDP DNS服务器之间同步DNS记录使用TCP DNS协议报文包括两种 DNS请求报文 DNS响应报文 为合理定义DNS记录，DNS协议采用资源记录的结构表示 DNS资源记录（Resource Record） RR格式：（name, value, type, ttl, class）name：域名 value：根据type的不同，意义不同ttl：该记录在缓存中能停留的时间，0表示不能缓存class：RR的类别代码，默认为0001，表示因特网type：RR类型|type| value ||–|–|| A | 域名对应的IP地址 ||AAAA|域名对应的IPv6地址||NS|域名对应的权威域名服务器名称||CNAME|域名对应的别名||MX|域名对应的邮件服务器的名称||PTR|name对应的 名字（反向查询）| DNS的报文格式 hosts文件hosts文件的域名和IP的对应优先DNS查询结果]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层相关概念]]></title>
    <url>%2F2020%2F06%2F04%2F%E5%BA%94%E7%94%A8%E5%B1%82%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[一、应用层概述1、应用层协议基本概念应用层的功能 应用层协议定义了应用程序需交换的报文、所需采取的动作和最终通信数据的应用 应用层位于协议栈的最高层次 应用层协议提供不同主机之间进程与进程之间的通信 用户代理实现应用层协议 套接字IP+端口号，唯一确定某台主机某个进程IP地址唯一确定某主机在因特网上的位置，32位二进制，采用点分十进制表示，例如192.168.1.1端口号唯一确定某台主机的某个通信进程，16位二进制，一般用十进制表示，例如80端口端口号是应用进程的入口标识，是一个存放在传输层首部的一个字段的值（2^16 - 1 = 65535） 包括TCP端口号和UDP端口号 一个进程可能使用多个端口号 端口号范围 端口类型 0到1023 公认端口、一般分配给固定的服务进程，用于某种应用的服务端 1024到49151 可注册端口（随机使用端口）随机分配给客户端进程，或者用于某些非公认应用程序 49152到65535 私有端口或临时端口、一般分配给某些P2P应用程序，使用较少 网络应用层协议 服务器端端口号 协议 DNS 53 TCP/UDP HTTP 80 TCP HTTPS 443 TCP FTP 20,21 TCP SMTP 25 TCP POP 110 TCP TELNET 23 TCP 网络应用的模式 C/S 模式的网络应用 目前大多数网络应用采用C/S模式 客户端首先发起请求，再由服务器端响应提供服务 P2P（peer to peer） 任意主机既是客户端又是服务器 主机之间是对等的 迅雷，BT等常见下载软件均提供P2P下载模式 网络应用需要的服务 可靠性保证 应用数据能否保证按序，正确的到达对方 带宽保证 应用数据传输能否保证最小带宽 实时性保证 数据是否保证在规定时间内到达对方 网络应用使用的传输层协议一般原则 对可靠性要求高的使用TCP作为传输层，对速度要求高，可靠性要求低的使用UDP作为传输层 TCP提供面向连接可靠的传输服务 UDP提供无连接不可靠的传输服务 因特网的传输层不提供带宽保证、实时性保证服务]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教学5层网络体系结构——分层之后数据的发送和接收]]></title>
    <url>%2F2020%2F06%2F03%2F%E6%95%99%E5%AD%A65%E5%B1%82%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%88%86%E5%B1%82%E4%B9%8B%E5%90%8E%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%2F</url>
    <content type="text"><![CDATA[协议分层后数据发送过程发送方层层封装接收方层层解封装 唯一加尾部的是数据链路层 思考发送方某层封装完如何知道该交给哪个下层封装？ 应用层选择传输层由应用程序决定，传输层选择网络层由固定的搭配，例如因特网只有IP协议，网络层选择数据链路层由网卡的类型决定。 接收方某层解封装后如何知道该交给上层哪个协议处理？ 每个协议都应该有个上层协议的标识，让接收方处理本层之后交给正确的上层协议 每一层协议的首部有何作用？ 实现本层次的特定功能，提供相邻层次协议的接口等 例如网络层IP协议中包含IP地址等信息 协议分层的进一步讨论 协议是对等的 收发双方某层协议必须相同 服务是垂直的 下层为上层提供服务 层次实现是透明的 某层的实现细节对其他层次透明 层与层之间必须提供接口 某层只需知道相邻层次的接口]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络——因特网的接入技术]]></title>
    <url>%2F2020%2F06%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E6%8E%A5%E5%85%A5%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[因特网接入与ISPISP：Internet服务供应商，为接入Internet提供基本的服务一、模拟拨号 早期使用调制解调器（Modem）和常规的语音级电话线路 早期使用最为广泛，最大带宽56Kb/s【下一首歌差不多要30分钟、上网就不能打电话】 拨号调制解调器的作用：数字信号和模拟信号的转换 二、综合业务数字网络（ISDN） 综合业务数字网络（ISDN）是一种电路交换技术，能够让PSTN本地环路传输数字信号，从而实现更高容量的交换连接。 最大带宽128kb/s 三、非对称数字用户线路（ADSL） 上行和下行带宽不对称（因为下载比上传重要） 采用频分复用技术利用普通电话线提供高宽带服务 四、有线电视带宽 也称为HFC光纤同轴混合网 采用光纤和有线电视网络传输数据的带宽接入技术 五、光纤接入网点到点的网络、路边交换网络、无源光网络（PON）六、专线接入专线业务主要应用于用户的局域网互联或快速浏览互联网特点： 专线专用、24小时在线、实现双向数据同步传输，上网速度快、质量稳定、丢包率低、更具安全性 七、无线网络 WLAN：无线局域网技术，也称WIFI技术 WIMAX：无线城域网技术 4G/5G：第四代移动通信技术]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因特网的硬件组成]]></title>
    <url>%2F2020%2F06%2F03%2F%E5%9B%A0%E7%89%B9%E7%BD%91%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[终端系统 主机、服务器、PDA 通信介质 有线介质：双绞线、同轴电缆、光纤 无线介质：无线电波、卫星 中间设备 路由器、交换机等 路由器路由器的产生 由思科公司创始人伯塞克发明 路由器的特性和作用 存储转发机制 连接异构的网络 交换机交换机的特性 交换机一般都指以太网交换机 存储转发机制和其他转发机制 交换机的作用 将终端设备连接成一个局域网（以太网） 网络的有线传输介质 双绞线屏蔽双绞线（STP）：抗干扰性好，但不易安装布线非屏蔽双绞线（UTP）：抗干扰性较差，但容易安装布线，目前使用范围最广根据性能分类：1、根据电气性能分为：3类、5类、超5类、6类、7类2、3类用于10Mb/s以太网，5类用于100Mb/s以太网，超5类，6类，7类用于千兆网3、目前的布线建议采用超5类以上4、UTP使用RJ-45水晶头作为连接器 UTP的接线标准T568B接线方式：对主机而言：1,2引脚发数据、3,6引脚收数据、1,3高电平、2,6低电平接线原则：1 2 3 6，橙绿蓝棕 半全半全 直通线和交叉线直通线：两端都使用T568B连线，一般用于不同设备之间交叉线：一端使用T568B，一端使用T568A，一般用于相同或相近设备之间tips:主机和路由器之间相连用交叉现 UTP的性能讨论 衰减 由距离决定，理论不能超过100m 距离过长导致衰减过大 串扰 线对之间的干扰，在水晶头上尤为突出（因为没有绞合） 水晶头上串扰最大 回波损耗（反射） 当信号遇到不连续的阻抗会朝相反方向反射，产生干扰 线歪曲过度或水晶头上容易产生较强的回波损耗（反射干扰） 同轴电缆 50Ω同轴，多用于早期以太网 70Ω同轴，用于有线电视 屏蔽较好，不容易安装，目前在计算机网络中使用不多 光纤工作原理 通过光的全反射传输信号 特性 抗干扰性强，衰减小，传输距离长 分成多模光纤和单模光纤 随着价格的不断下降应用日益普及 注意事项 可以歪曲、不能折 两根成对实现全双工 注意激光伤害眼睛]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络基本概念]]></title>
    <url>%2F2020%2F06%2F01%2F%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[计算机网络的分类按照网络拓扑结构划分计算机网络拓扑结构是指网络中各个站点相互连接的形式星型、环型、总线型、树型、网状型、无限蜂窝型 按照网络作用范围划分广域网WAN（Wide Area Network）：作用范围通常为几十到几千公里 一种用来实现不同地区的局域网或城域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网络。所覆盖的范围从几十公里到几千公里。 城域网MAN（Metropolitan Area Network）：作用距离约为5~50公里 一种介于局域网与广域网之间，覆盖一个城市的地理范围，用来将同一区域内的多个局域网互连起来的中等范围的计算机网络 接入网AN（Access Network）：又称为本地接入网或居民接入网。 接入网是一类比较特殊的计算机网络，用于将用户接入互联网。 接入网指骨干网络到用户终端之间的所有设备。其长度一般为几百米到几公里，有时称为“最后一公里” 局域网LAN（Local Area Network）：局限在较小的范围（如1公里左右） 定义：一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网络 局域网包括：以太网、令牌环网等 当前的局域网主流是以太网 个人局域网PAN（Personal Area Network）：范围很小，大约在10米左右TIPS： 若中央处理机之间的距离非常近（如仅1米的数量级甚至更小些），则一般就称之为多处理机系统，而不称它为计算机网络 按照网络使用者划分公用网（public network） 按规定交纳费用的人都可以使用的网络。因此也可称为公众网 专用网（private network） 为特殊业务工作的需要而建造的网络]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无类别地址CIDR概述]]></title>
    <url>%2F2020%2F05%2F31%2F%E6%97%A0%E7%B1%BB%E5%88%AB%E5%9C%B0%E5%9D%80CIDR%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[问题 IPv4的地址空间最终将全部耗尽 子网掩码无法改变IP地址的分配方式，无法缓解IP地址危机 CIDR概述 CIDR是无类别域间路由 CIDR取消了IP地址的分类限制，可以取IP地址的任意前缀作为网络号 CIDR改善了IP地址的分配方式，缓解了IP地址危机 CIDR可以利用层次网络和路由汇总减小路由器中路由表的规模，提高转发速度 CIDR地址说明CIDR地址的网络地址由前缀或掩码决定 128.14.32.5/20表示该IP地址前20位为网络号，后12位为主机号，即掩码为255.255.240.0CIDR地址的网络地址和广播地址本质不变 主机号全0为网络地址，全1为广播地址 128.14.32.0/32表示一个网络地址，即一个CIDR地址块 路由汇总 路由汇总指将多个网络地址汇总为一个网络地址 路由汇总必须与层次物理网络结合 路由汇总能极大的减少路由器上路由表的规模 VLSM中，多个子网可以汇总成一个分类地址块或一个子网地址块 CIDR地址中，多个网络（可以是分类网络）可以汇总成一个CIDR地址块，形成超网 192.168.0（00000000）.0/24192.168.1（00000001）.0/24 路由汇总192.168.2（00000010）.0/24 ====⇒ 192.168.0.0/22四个网段的前22位相同保留，192.168.3（00000011）.0/24 ====⇒ 后10位作为汇总后的主机部分，用0表示]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定长掩码地址划分与VLSM子网划分]]></title>
    <url>%2F2020%2F05%2F31%2F%E5%AE%9A%E9%95%BF%E6%8E%A9%E7%A0%81%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86%E4%B8%8EVLSM%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[定长掩码地址划分案例若某个公司得到一个C类网络地址210.33.15.0，假如所有子网的掩码都一样，该如何划分子网？步骤一：确定子网个数7个子网，其中4个局域网，3个广域网步骤2：确定每个子网所需IP个数步骤3：确定子网掩码 过去规定不能使用子网号全0和全1的子网 C类网络，7个子网，需要借4位作为子网号，掩码为255.255.255.240，该掩码下每个子网可以使用14个IP地址 总部需要25个IP，出现子网和主机数的矛盾 子网数与主机数矛盾的解决方法 申请更大的地址块 让一个物理网络包含多个IP子网 使用子网0 使用可变长子网掩码VLSM 最终规划方案：假设采用子网0的方式解决子网数和主机数的冲突，使用子网掩码255.255.255.224（11100000）子网0：210.33.15.000hhhhh ，主机号不能全0或全1 所以范围为210.33.15.1（00000001）~ 210.33.15.30（00011110）子网1：210.33.15.001hhhhh ，主机号不能全0或全1 所以范围为210.33.15.33 （00100001）~ 210.33.15.62（00111110）子网2：210.33.15.010hhhhh ，主机号不能全0或全1 所以范围为210.33.15.65（01000001）~ 210.33.15.94（01011110）…… VLSM划分子网步骤 按照主机数的需求从多到少或从少到多排序 每个子网根据主机IP的需求确定主机号的位数，从而确定子网号的位数，确定子网掩码 一定要保证某个子网不会成为其他子网的细分子网，即子网划分不能重复]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAT与DHCP协议]]></title>
    <url>%2F2020%2F05%2F31%2FNAT%E4%B8%8EDHCP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[DHCP概述DHCP产生的原因大型网络中静态配置IP地址容易出现地址冲突定义DHCP：动态主机配置协议，用于主机自动获得IP地址、子网掩码、网关地址、DNS服务器地址，租用期等相关信息。采用C/S模式。DHCP给运行服务器软件、且位置固定的计算机指派一个永久地址，给运行客户端软件的计算机分配一个临时地址。DHCP的设计思考问题1： DHCP协议如何找到服务器？答：通过广播，广播的目标地址是255.255.255.255（对自己所在的本局域网发广播）【在不知道目标在哪的时候可以采用广播的方式进行通信】 问题2： 多个客户端同时请求IP，服务器该如何分辨？答：通过MAC地址 问题3： 服务器是否能够给某个客户分配固定的IP地址？答：可以并且有些情况下是有必要的【如何实现：通过MAC地址，固定MAC地址给固定的IP地址】 问题4： DHCP服务器如何保证分配的IP地址是唯一的？答：在服务器分配某一个IP地址的时候，发广播去问局域网上所有的主机有没有人的IP地址是将要分配的这个IP地址，如果没有收到回复，那么可以分配。 问题5： DHCP协议如果要实现某个客户端的IP动态变化，该如何处理？答：使用租用期 问题6 DHCP协议的报文应当包含几种？答：DHCPDISCOVER、DHCPOFFER、DHCPREQUEST、DHCPACK、DHCPREQUEST DHCP基于UDP工作，DHCP服务器运行在67号端口，DHCP客户运行在68号端口。【为什么使用UDP而不是TCP？】因为DHCP要使用广播，1对多的传输模式只能用UDP 若DHCP服务器不响应步骤6的请求报文DHCPREQUEST，则在租用期过了87.5%时，DHCP客户必须重新发送请求报文DHCPREQUEST（重复步骤6），然后又继续后面的步骤。 DHCP客户可随时提前终止服务器所提供的租用期，这时只需向DHCP服务器发送释放报文DHCPRELEASE即可。 DHCP中继代理 并不是每个网络上都有DHCP服务器，这样会使DHCP服务器的数量太多。现在是每一个网络至少有一个DHCP中继代理，它配置了DHCP服务器的IP地址信息。 当DHCP中继代理收到主机发送的发现报文后，就以单播方式向DHCP服务器转发此报文，并等待其回答。收到DHCP服务器回答的提供报文后，DHCP中继代理再将此提供报文发回给主机。 一个网络如果没有DHCP服务器，至少需要一个DHCP中继代理，它配置了DHCP服务器的IP地址信息。 ipconfig命令： ipconfig/release：释放IP地址 ipconfig/renew：重新使用DHCP获取IP地址 禁止主机通过DHCP获取IP： 禁用系统服务中的DHCP client服务]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BGP协议]]></title>
    <url>%2F2020%2F05%2F26%2FBGP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[概述 BGP是目前“唯一”的EGP协议，用于AS之间传递路由信息，目前版本为4 为什么需要BGP？ 不同AS自治系统的管理部门不同，路由策略不同 AS之间的路由不强调最优路径，更强调路由控制和路由策略 IGP与BGP对比 IGP关注如何自动学习最优路径，如何提高路由收敛速度，有明确的算法 BGP关注如何将人为控制策略应用到BGP上，强调路由控制的灵活性，无需明确的算法 BGP的特性 在不考虑路由控制和路由策略的情况下，使用距离矢量（路径矢量）算法，默认以AS为单位计算代价，即到达目的网络最优路径是经过的AS最少的。 使用TCP作为传输层，端口号为179 支持CIDR技术 路由信息中可以携带丰富的路由属性，提供丰富的路由控制机制和路由策略 路由更新机制：只发送增量路由，非周期更新 不支持负载均衡，只选一条最“优”路径 BGP发言人和AS 也称为AS网关路由器，位于AS边界 既运行IGP，又运行BGP BGP的邻居 两个BGP路由器只要能建立TCP连接就能成为邻居 BGP的邻居建立由管理员手动配置，不是自动寻找 BGP的两种邻居关系IBGP和EBGPEBGP：两个BGP邻居不在同一个AS，IBGP：两个BGP邻居位于同一个AS 从IBGP学习到的路由是否需要通告给其他IBGP邻居？ 如果通告可能出现环路 如果不通告在部分互联网IBGP中会使得路由更新失效 例如：B，E不是IBGP邻居，B获得的路由不告诉E，F也无法得到路由信息 IBGP的水平分割原则 默认BGP认为BGP网络时全互联的，从IBGP邻居获得的路由不通告给其他IBGP邻居 解决中转路径上路由问题的方法方法1：同步（早期使用的办法），将BGP获得的路由重分布到IGP中，当E收到IBGP路由之后，并通过IGP获得同一网段路由，完成同步，E通告路由给F。同步缺点LBGP路由太多，重分布到IGP之后给IGP带来太多负担，建议禁止同步功能方法2：保证所有中转路径上的路由器都运行BGP BGP的路由通信原则1、路由信息只会通告给邻居，不会洪泛2、从EBGP得到的路由会立刻向所有EBGP邻居和IBGP邻居通告3、从IBGP得到的路由不通告给其他IBGP邻居，在全互联的AS下通告给EBGP邻居 BGP的四种报文OPEN报文用来与相邻的另一个BGP发言人建立关系UPDATE报文用来发送某一路由的信息，以及列出要撤销的多条路由KEEPALIVE报文用来确认打开报文和周期性证实邻站关系NOTIFICATION报文用来发送检测到的差错 BGP属性 防止路由环路的产生 提供丰富的路由策略 常见的BGP属性 Origin AS-Path Next hop MED Local-Preference Atomic-Aggregate Aggregator AS-Path属性记录BGP路由所经过的自治系统号，当某个BGP路由器收到一条包含自己所在自治系统的BGP时会丢弃该路由，从而避免环路 EGP（BGP）和IGP的比较策略AS之间选路策略至关重要，AS内部选路管理和性能更重要规模AS之间网络规模更大，EGP必须能够适应超大规模网络。IGP对此要求不高性能AS之间强调策略开销，不强调实际的网络开销，不强调路由器性能问题，AS内部强调路由花费，必须考虑路由器的性能]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链路状态路由协议与OSPF]]></title>
    <url>%2F2020%2F05%2F26%2F%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E4%B8%8EOSPF%2F</url>
    <content type="text"><![CDATA[链路状态路由算法（LS算法）工作原理 每个路由器将自己的链路状态信息洪泛到网络上的所有路由器。tips:（每个路由器都洪泛会给网络带来负担） 每个路由器最终会知道整个网络的拓扑结构（LSDB）。 每个路由器使用Dijkstra最短路径算法计算本路由器到其他路由器的最短路径，更新路由表。 路由器的链路状态发生变化时会继续洪泛自身的链路状态信息到其他路由器。 链路与链路状态链路的本质上是路由器上的一个接口链路状态是有关各条链路的状态信息链路状态数据包洪泛路由器一旦接收到来自相邻路由器的LSP，立即将该LSP从除接收该LSP的接口以外的所有接口发出 Dijkstra算法（直接见图） Dijkstra算法分析算法复杂度：n个节点 每次迭代需要检查不在N的节点 最差的复杂度：n*（n - 1）/2次比较：O(n^2) 平均的复杂度：O(nlogn)路由振荡 假设，link cost = amount of carried traffic（链路代价与流量和有关），且链路代价的具有方向性，LS算法可能会让分组一会逆时针转发，一会顺时针转发，形成振荡。 本质：同时执行最短路径算法导致路由振荡，可以采用随机数解决同时问题 OSPF协议概述 Open Shortest Path First，开放式最短路径优先路由协议 链路状态路由算法，无路由自环 用于AS内部，属于IGP 使用区域划分，适用于大规模网络 支持VLSM和CIDR 使用组播方式发送协议报文 支持验证 OSPF是基于IP的，协议号为89 OSPF是典型的停止等待协议，自身实现了可靠传输 路由器标识（Router ID） 用于唯一确定OSPF路由器 一个32位的无符号整数，整个自治系统内唯一 若不手动配置，一般取该路由器的所有接口的IP地址的最大值（loopback地址优先） OSPF的链路代价一条OSPF链路的代价定义为：10^8/BandWidth一条OSPF路由的代价为其经过的所有链路代价的总和 OSPF规定的网络类型|网络类型|举例 ||–|–|| 广播 | 以太网 || 非广播多路访问NBMA|帧中继、X.25 || 点到点|PPP，HDLC ||点到多点| 多个点到点链路的集合| 全连通网络的处理选取DR和BDRDR：指定路由器 （村长）BDR：备份指定路由器 （副村长）DR负责通告路由BDR备份 选取规则选取优先级最大的选取router id 最大的 选取方式投票制和终身制OSPF的数据包格式|ODPF包类型| 描述 ||–|–|| Hello （不需要确认）| 用户邻居路由器之间建立和维护邻接关系 ||数据库描述包DBD|描述每台OSPF路由器的链路状态数据库的内容||链路状态请求包LSR|请求链路状态数据库的部分内容||链路状态更新包LSU|传送链路状态数据通告LSA给邻居路由器||链路状态确认包LSAck（不需要确认）|确认邻居发过来的LSA已经收到| OSPF划分区域目的：减少洪泛的范围工作方式： 同一个区域内部路由器之间使用链路状态算法，洪泛的范围限于一个区域内部。 不同区域之间的路由通过ABR（区域边界路由器）负责通告（距离矢量算法） 必须要有骨干区域（area 0)，且所有区域应当和骨干区域物理上直连，保证不会出现路由环路问题。 区域划分可以和IP地址结合在ABR上通告汇总的路由。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解云计算三种服务模式——IaaS、PaaS和SaaS]]></title>
    <url>%2F2020%2F04%2F26%2F%E7%90%86%E8%A7%A3%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%89%E7%A7%8D%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94IaaS%E3%80%81PaaS%E5%92%8CSaaS%2F</url>
    <content type="text"><![CDATA[云计算的服务模式仍在不断进化，但业界普遍接受将云计算按照服务的提供方式划分为三个大类：SaaS（Software as a Service–软件即服务） PaaS（Platform as a Service–平台即服务） IaaS（Infrastructure as a Service–基础架构即服务）。 PaaS基于IaaS实现，SaaS的服务层次又在PaaS之上，三者分别面对不同的需求。1.IaaS: Infrastructure-as-a-Service（基础设施即服务） 第一层叫做IaaS，有时候也叫做Hardware-as-a-Service，以前如果你想在办公室或者公司的网站上运行一些企业应用，你需要去买服务器，或者别的高昂的硬件来控制本地应用，让你的业务运行起来。 但是现在有IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。 一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。2.PaaS: Platform-as-a-Service（平台即服务） 第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。 PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。 一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog, Mendix 和 Standing Cloud3.SaaS: Software-as-a-Service（软件即服务） 第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。 你消费的服务完全是从网页如Netflix, MOG, Google Apps, Box.net, Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分 一些用作商务的SaaS应用包括Citrix的GoToMeeting，Cisco的WebEx，Salesforce的CRM，ADP，Workday和SuccessFactors。区别： 如果你是一个网站站长，想要建立一个网站。不采用云服务，你所需要的投入大概是：买服务器，安装服务器软件，编写网站程序。 现在你追随潮流，采用流行的云计算， 如果你采用IaaS服务，那么意味着你就不用自己买服务器了，随便在哪家购买虚拟机，但是还是需要自己装服务器软件 而如果你采用PaaS的服务，那么意味着你既不需要买服务器，也不需要自己装服务器软件，只需要自己开发网站程序 如果你再进一步，购买某些在线论坛或者在线网店的服务,这意味着你也不用自己开发网站程序，只需要使用它们开发好的程序，而且他们会负责程序的升级、维护、增加服务器等，而你只需要专心运营即可，此即为SaaS。下面是从网上download的一幅图，希望对大家学习有所帮助：]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java socket 实现增删改查 + 在线答题小案例]]></title>
    <url>%2F2020%2F04%2F17%2Fjava%20socket%20%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%20%2B%20%E5%9C%A8%E7%BA%BF%E7%AD%94%E9%A2%98%E5%B0%8F%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[实现效果 （1） 在client端可以实现对数据库的操作（Select，Insert，Update，Delete） （2）数据库中创建一个考试表和学生表，考试表中问题是四项选择题（10道以上），client端做题，成绩存入学生表 （3）实现多个Client程序对server端的访问 Hint：Java程序中会使用多个class，server端使用thread监听多个client 。 一、创建数据库demo，数据表student、question。其中student表存储了学生的姓名以及成绩记录、question表中存储了单项选择题的有关内容。 二、创建Student、Question 两个实体类 包含属性，Getter,Setter方法Student.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.jxnu.demo;/** * @author xiao */public class Student &#123; //主键ID private Integer id; //用户名 private String username; //分数 private String grade; //生日 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getGrade() &#123; return grade; &#125; public void setGrade(String grade) &#123; this.grade = grade; &#125; @Override public String toString() &#123; return "Student&#123;" + "id=" + id + ", username='" + username + '\'' + ", grade=" + grade + '&#125;'; &#125;&#125; Question.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.jxnu.demo;/** * @author xiao */public class Question &#123; private Integer id; private String Content; private String OptionA; private String OptionB; private String OptionC; private String OptionD; private String answer; private String grade; public String getGrade() &#123; return grade; &#125; public void setGrade(String grade) &#123; this.grade = grade; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getContent() &#123; return Content; &#125; public void setContent(String content) &#123; Content = content; &#125; public String getOptionA() &#123; return OptionA; &#125; public void setOptionA(String optionA) &#123; OptionA = optionA; &#125; public String getOptionB() &#123; return OptionB; &#125; public void setOptionB(String optionB) &#123; OptionB = optionB; &#125; public String getOptionC() &#123; return OptionC; &#125; public void setOptionC(String optionC) &#123; OptionC = optionC; &#125; public String getOptionD() &#123; return OptionD; &#125; public void setOptionD(String optionD) &#123; OptionD = optionD; &#125; public String getAnswer() &#123; return answer; &#125; public void setAnswer(String answer) &#123; this.answer = answer; &#125; @Override public String toString() &#123; return "Question&#123;" + "id=" + id + ", Content='" + Content + '\'' + ", OptionA='" + OptionA + '\'' + ", OptionB='" + OptionB + '\'' + ", OptionC='" + OptionC + '\'' + ", OptionD='" + OptionD + '\'' + ", answer='" + answer + '\'' + ", grade='" + grade + '\'' + '&#125;'; &#125;&#125; 三、导入jar包，编写三个与数据库相关的Java Class，DbManage、 StudentDao和QuestionDao。 其中DbManage有三个方法，initDB()负责打开驱动，两个close()方法分别关闭有结果集与无结果集。 DBManage.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.jxnu.demo;import java.sql.*;/** * @author xiao */public class DbManage &#123; //打开驱动 public Connection initDB() &#123; Connection conn = null; final String DRIVER_NAME = "com.mysql.jdbc.Driver"; //数据库连接地址 final String URL = "jdbc:mysql://localhost:3306/socket?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=FALSE&amp;serverTimezone=UTC"; //用户名 final String USER_NAME = "root"; //密码 final String PASSWORD = ""; try &#123; Class.forName(DRIVER_NAME); conn = DriverManager.getConnection(URL,USER_NAME,PASSWORD); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return conn; &#125; //关闭无结果集 public void closeDB(PreparedStatement pstmt, Connection con) &#123; try &#123; if(pstmt!=null) &#123; pstmt.close(); &#125; if(con!=null) &#123; con.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; //关闭有结果集 public void closeDB(ResultSet rs, PreparedStatement pstmt, Connection con) &#123; try &#123; if(pstmt!=null) &#123; pstmt.close(); &#125; if(con!=null) &#123; con.close(); &#125; if(rs!=null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; StudentDao.javaStudentDao负责有关学生信息的增删查改(insert、update、delete、findAll） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186package com.jxnu.demo;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;/** * @author xiao */public class StudentDao &#123; /** * 添加 * @param student * @return */ public boolean insert(Student student) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; String sql = "insert into student(username,grade) VALUES(?,?)"; boolean res = false; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setString(1,student.getUsername()); pstmt.setString(2,student.getGrade()); res = (pstmt.executeUpdate() == 1); &#125;catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(pstmt, con); &#125; return res; &#125; /** * 删除 * @param id * @return */ public boolean delete(Integer id) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; String sql = "delete from student where id = ?"; boolean flag = false; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setInt(1, id); int result = pstmt.executeUpdate(); if (result &gt; 0) &#123; flag = true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(pstmt, con); &#125; return flag; &#125; /** * 修改信息 * @param student * @return */ public boolean update(Student student) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; String sql = "update student set username=? where id= ?"; boolean res = false; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setString(1,student.getUsername()); pstmt.setInt(2,student.getId()); res = (pstmt.executeUpdate()==1); &#125;catch (SQLException e) &#123; e.printStackTrace(); return false; &#125;finally &#123; dbmanage.closeDB(pstmt, con); &#125; return res; &#125; public boolean updateG(Student student) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; String sql = "update student set grade=? where id= ?"; boolean res = false; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setString(1,student.getGrade()); pstmt.setInt(2,student.getId()); res = (pstmt.executeUpdate()==1); &#125;catch (SQLException e) &#123; e.printStackTrace(); return false; &#125;finally &#123; dbmanage.closeDB(pstmt, con); &#125; return res; &#125; /** * 查找所有数据 * @return */ public List&lt;Student&gt; findAll() &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; ResultSet rs = null; List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); String sql = "select * from student"; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); while (rs.next()) &#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setUsername(rs.getString("username")); student.setGrade(rs.getString("grade")); list.add(student); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(rs,pstmt, con); &#125; return list; &#125; /** * 根据ID查询 * @param id * @return */ public List&lt;Student&gt; findById(Integer id) &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; ResultSet rs = null; //MessageEntity messageEntity = new MessageEntity(); List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); String sql = "select * from student where id=?"; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); pstmt.setInt(1, id); rs = pstmt.executeQuery(); while(rs.next())&#123; Student student = new Student(); student.setId(rs.getInt("id")); student.setUsername(rs.getString("username")); student.setGrade(rs.getString("grade")); list.add(student); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(rs,pstmt, con); &#125; return list; &#125;&#125; QuestionDao.javaQuestionDao负责有关题目的增删改查 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.jxnu.demo;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;/** * @author xiao */public class QuestionDao &#123; public List&lt;Question&gt; findAll() &#123; DbManage dbmanage = new DbManage(); Connection con = null; PreparedStatement pstmt =null; ResultSet rs = null; List&lt;Question&gt; list = new ArrayList&lt;Question&gt;(); String sql = "select * from question"; try &#123; con = dbmanage.initDB(); pstmt = con.prepareStatement(sql); rs = pstmt.executeQuery(); while (rs.next()) &#123; Question question = new Question(); question.setId(rs.getInt("id")); question.setAnswer(rs.getString("answer")); question.setContent(rs.getString("content")); question.setOptionA(rs.getString("optionA")); question.setOptionB(rs.getString("optionB")); question.setOptionC(rs.getString("optionC")); question.setOptionD(rs.getString("optionD")); list.add(question); &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; dbmanage.closeDB(rs,pstmt, con); &#125; return list; &#125;&#125; 三、编写StudentService类，用于处理增删改查以及答题的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.jxnu.demo;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.net.Socket;import java.util.List;/** * @author xiao */public class StudentService&#123; public void show(Socket socket) throws IOException &#123; DataOutputStream out = new DataOutputStream(socket.getOutputStream()); StudentDao dao = new StudentDao(); List&lt;Student&gt; list = dao.findAll(); out.writeUTF(String.valueOf(list)); &#125; public void insert(Socket socket) throws IOException &#123; DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream out = new DataOutputStream(socket.getOutputStream()); out.writeUTF("请输入新增用户名"); String username = input.readUTF(); out.writeUTF("请输入用户成绩"); String grade = input.readUTF(); StudentDao dao = new StudentDao(); Student student = new Student(); student.setUsername(username); student.setGrade(grade); if(dao.insert(student)) out.writeUTF("添加成功"); else out.writeUTF("添加失败"); &#125; public void delete(Socket socket) throws IOException &#123; DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream out = new DataOutputStream(socket.getOutputStream()); out.writeUTF("请输入要删除的ID号"); String id = input.readUTF(); StudentDao dao = new StudentDao(); if(dao.delete(Integer.valueOf(id))) out.writeUTF("删除成功"); else out.writeUTF("删除失败，请确认ID是否存在"); &#125; public void update(Socket socket) throws IOException &#123; DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream out = new DataOutputStream(socket.getOutputStream()); out.writeUTF("请输入要修改的用户ID号"); String id = input.readUTF(); out.writeUTF("请输入修改后的用户名"); String username = input.readUTF(); StudentDao dao = new StudentDao(); Student student = new Student(); student.setId(Integer.valueOf(id)); student.setUsername(username); if(dao.update(student)) out.writeUTF("更新成功"); else out.writeUTF("更新失败"); &#125; public void answer(Socket socket) throws IOException &#123; DataInputStream input = new DataInputStream(socket.getInputStream()); DataOutputStream out = new DataOutputStream(socket.getOutputStream()); QuestionDao questionDao = new QuestionDao(); List&lt;Question&gt; questionList = questionDao.findAll(); Question question = new Question(); out.writeUTF(String.valueOf(questionList.size())); int n = questionList.size(); //out.writeUTF("请输入题号"); int sum = 0; String[] answers = new String[20]; for(int i=0;i&lt;n;i++) &#123; out.writeUTF("第"+(i+1)+"题"+": "+questionList.get(i).getContent()); out.writeUTF("A. " + questionList.get(i).getOptionA() + "\t" + "B. " + questionList.get(i).getOptionB() + "\t" + "C. " + questionList.get(i).getOptionC() + "\t" + "D. " + questionList.get(i).getOptionD()); answers[i]=input.readUTF(); System.out.println(answers[i]); if(answers[i].equals(questionList.get(i).getAnswer())) &#123; out.writeUTF("回答正确,+10 分\n"); sum += 10; &#125; else out.writeUTF("回答错误\n"); &#125; String id = input.readUTF(); out.writeUTF("总成绩为"+sum); StudentDao dao = new StudentDao(); Student student = new Student(); student.setId(Integer.valueOf(id)); student.setGrade(String.valueOf(sum)); if (dao.updateG(student)) out.writeUTF("成绩保存成功"); else out.writeUTF("成绩保存失败"); &#125;&#125; 四、编写Server类。其中server端使用thread监听多个client，根据Client端的指令调用不同的方法并执行。收到指令“1”，执行StudentService中的show()方法，查询出学生表中所有的记录并返回给Client；收到指令“2”，执行StudentService中的insert()方法，获取客户端传来的姓名与成绩并插入student表中。收到指令“3”，执行update()方法，可以实现根据client端传来的ID号和新姓名实现修改姓名的功能;收到指令“4”，执行delete()方法，可以根据Client端传来的ID号实现删除学生记录的功能；收到指令“5”，实现答题功能，用户每回答一个题目，Server端判断正误并将结果返回给Client端，最后计算出总成绩存入student表；收到指令“0”，Client端将断开连接。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.jxnu.demo;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.util.List;/** * @author xiao */public class Server &#123; public static final int PORT = 12345;//监听的端口号 public static void main(String[] args) &#123; System.out.println("服务器启动...\n"); Server server = new Server(); server.init(); &#125; public void init() &#123; try &#123; ServerSocket serverSocket = new ServerSocket(PORT); while (true) &#123; // 一旦有堵塞, 则表示服务器与客户端获得了连接 Socket client = serverSocket.accept(); // 处理这次连接 new HandlerThread(client); &#125; &#125; catch (Exception e) &#123; System.out.println("服务器异常: " + e.getMessage()); &#125; &#125; public static class HandlerThread implements Runnable &#123; private Socket socket; public HandlerThread(Socket client) &#123; socket = client; new Thread(this).start(); &#125; public void run() &#123; try &#123; // 读取客户端数据 DataInputStream input = new DataInputStream(socket.getInputStream()); String clientInputStr = input.readUTF();//这里要注意和客户端输出流的写方法对应,否则会抛 EOFException // 处理客户端数据 System.out.println("客户端:" + clientInputStr); // 向客户端回复信息 DataOutputStream out = new DataOutputStream(socket.getOutputStream()); action(clientInputStr,socket); out.close(); input.close(); &#125; catch (Exception e) &#123; System.out.println("服务器 run 异常: " + e.getMessage()); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (Exception e) &#123; socket = null; System.out.println("服务端 finally 异常:" + e.getMessage()); &#125; &#125; &#125; &#125; public void action(String clientInputStr,Socket socket) throws IOException &#123; DataOutputStream out = new DataOutputStream(socket.getOutputStream()); StudentService studentService = new StudentService(); switch (clientInputStr) &#123; case "1": studentService.show(socket); break; case "2": studentService.insert(socket); break; case "3": studentService.delete(socket); break; case "4": studentService.update(socket); break; case "5": studentService.answer(socket); break; case "0": out.writeUTF("OK"); break; default: out.writeUTF("输入指令有误，请重新输入"); &#125; &#125; &#125;&#125; 六、编写Client类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.jxnu.demo;import java.io.BufferedReader;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.io.InputStreamReader;import java.net.Socket;/** * @author xiao */public class Client &#123; public static final String IP_ADDR = "192.168.19.133";//服务器地址 public static final int PORT = 12345;//服务器端口号 public static void main(String[] args) &#123; System.out.println("客户端启动..."); System.out.print("【提示】 1 表示查看所有学生信息, 2 表示添加学生信息, 3 表示删除学生信息, 4表示修改学生信息, 5表示做题, 0表示结束\n "); while (true) &#123; Socket socket = null; try &#123; //创建一个流套接字并将其连接到指定主机上的指定端口号 socket = new Socket(IP_ADDR, PORT); //读取服务器端数据 DataInputStream input = new DataInputStream(socket.getInputStream()); //向服务器端发送数据 DataOutputStream out = new DataOutputStream(socket.getOutputStream()); System.out.println("请输入指令: \t"); String str = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(str); String ret = input.readUTF(); System.out.println("服务器端: " + ret); if("请输入要删除的ID号".equals(ret)) &#123; String id = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(id); String result = input.readUTF(); System.out.println(result); &#125; if("请输入要修改的用户ID号".equals(ret)) &#123; String id = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(id); System.out.println("服务器端: "+input.readUTF()); String username = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(username); String result = input.readUTF(); System.out.println(result); &#125; if("请输入新增用户名".equals(ret)) &#123; String username = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(username); System.out.println("服务端: " + input.readUTF()); String grade = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(grade); String result = input.readUTF(); System.out.println(result); &#125; // 如接收到 "OK" 则断开连接 if ("OK".equals(ret)) &#123; System.out.println("客户端将关闭连接"); Thread.sleep(500); break; &#125; if (ret.length() &lt;=3 ) &#123; Integer n = Integer.valueOf(ret); System.out.println("总共" + n + "道题,每题10分，总分100分"); for(int i=0;i&lt;n;i++) &#123; System.out.println(input.readUTF()); System.out.println(input.readUTF()); System.out.println("请输入答案: "); String answer = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(answer); System.out.println(input.readUTF()); &#125; System.out.println("请输入你的用户ID号"); String id = new BufferedReader(new InputStreamReader(System.in)).readLine(); out.writeUTF(id); String sum = input.readUTF(); System.out.println(sum); String result = input.readUTF(); System.out.println(result); &#125; out.close(); input.close(); &#125; catch (Exception e) &#123; System.out.println("客户端异常:" + e.getMessage()); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); System.out.println("socket is closed"); &#125; catch (IOException e) &#123; socket = null; System.out.println("客户端 finally 异常:" + e.getMessage()); &#125; &#125; &#125; &#125; &#125;&#125; 效果图这里我还弄了点花里胡哨的颜色，有点好看嘿嘿。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机 NAT模式与桥接模式的区别]]></title>
    <url>%2F2020%2F04%2F17%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%20NAT%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[NAT模式：相当于宿主机再构建一个局域网，虚拟机无法和本局域网中的其他真实主机进行通讯。只需要宿主机器能访问互联网，那么虚拟机就能上网，不需要再去配置IP地址，子网掩码，网关。虚拟机和主机能够互相ping通。桥接模式：VMWare虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。但是需要我们手动去配置IP地址和网关，IP地址要与主机的无线网的IP段对应，子网掩码，网关，DNS都需要与宿主机保持一致。下面是我将虚拟机从NAT模式换成桥接模式对配置文件做的一些改动，重启网络后，虚拟机可以访问自身静态IP，访问公网，宿主机和虚拟机也可以相互ping通。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 搭建 web服务器 socket实现]]></title>
    <url>%2F2020%2F04%2F17%2Fjava%20%E6%90%AD%E5%BB%BA%20web%E6%9C%8D%E5%8A%A1%E5%99%A8%20socket%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[【写在前面】云计算的第n个java作业，开始一直不懂为什么老师一直让我们写java web的小demo，不应该是hadoop啥的直接上框架嘛。后来慢慢了解到，其实java web 的一些内容确实是云计算的基础。这个demo是用java socket 来搭建一个web服务器，以前确实没有接触过，所以这里记录一下。 基本原理（1）设置WebServer端口号（2）使用 ServerSocket.accept()方法,轮询监听用户请求；（3）用户使用浏览器输入地址，向WebServer发出请求；（4）服务器监听到用户请求，为该请求新建一个HttpServer来处理该请求；（5）HttpServer解析用户请求并作出响应；（6）用户浏览器显示响应结果。 一、编写WebServer.java WebServer.java 是整个项目的主线程，用于设置服务器端口号，监听用户的请求，为每一个监听到的请求新建一个HttpServer线程，来处理用户请求。public void startServer(int port) 轮询serverSocket.accept()，监听用户请求。为每一个监听到的请求，新建一个httpserver线程响应 public static void main(String[] args) ，设置服务器端口号，之后，启动Webserver服务器。 123456789101112131415161718192021222324252627282930package com.jxnu.socket;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * @author xiao */public class WebServer extends Thread&#123; public void startServer(int port)&#123; try &#123; ServerSocket serverSocket = new ServerSocket(port); while(true)&#123; Socket socket = serverSocket.accept(); HttpServer httpServer = new HttpServer(socket); httpServer.start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; new WebServer().startServer(8000); &#125;&#125; 二、编写HttpServer.javaHttpServer.java 继承Thread，用于读取用户访问路径，根据路径响应请求。public HttpServer(Socket socket) 初始化socket对象,获取对应 输入，输出流 public void run() 重载Run（）函数，调用Read（）、response（）函数 private void response(String filePath) 根据读取的路径，进行响应。以流的形式读取文件，再以流的形式输出文件 private String read() 解析请求路径。其中，为了项目的可移植性，文件的解析路径是相对路径，整个文件都放在文件夹resource下。项目目录如下：index.html这里注意加上 1&lt;link rel="shortcut icon" href="#" type="image/x-icon"&gt; 效果图]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用子网掩码划分子网]]></title>
    <url>%2F2020%2F04%2F14%2F%E5%88%A9%E7%94%A8%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%2F</url>
    <content type="text"><![CDATA[分类IP地址的弊端 一个物理网络不能过大，否则网络性能很差，某个B类或A类IP网络无法全部用于单个物理网络 分类IP地址分配不合理，利用率低 分类IP地址设计的弊端 —— 不灵活，IP地址利用率不高 划分子网的思路网络管理员将本应属于一个物理网段的单个分类IP网络划分成多个子网，不同的子网对应不同的物理网段，不同子网之间的通信必须要经过路由器。 remember10000000 (128)11000000 (192)11100000 (224)11110000 (240)11111000 (248)11111100 (252)11111110 (254)11111111 (255) 小案例1、 网络号为192.168.1，子网掩码为255.255.255.224，可以划多少子网，每个子网多少主机？ 255.255.255.224（224==》11100000），这是C类网络所以子网数 = 2^3^子网数 = 2^5^ -2 2、 C类IP地址192.168.5.0， 如何划分使得有20个子网，每个子网5台主机 2^4^ = 16 &lt; 20 2^5^ = 32 &gt; 20所以应该有五位，从上面的remember可以看出5个1对应的是248这是看看主机号是不是也够，2^3^-2=6 &gt; 5 ，所以最终的子网掩码就是255.255.255.248 子网掩码为什么如此设计？IP address AND subnet mask = Network address 193.154.34.129 255.255.255.192的网络地址是？思路：子网掩码前面24位都是1，所以193.154.34.129不变。129==》10000001192==》11000000，与操作（0与任何数与都得0,1与任何数与都不变）之后得到10000000，所以网络地址就是192.154.34.128 划分子网后的分组转发这里有3个子网现在主机H1要发送分组给H2路由器R1逐项查找路由表，决定下一跳。路由器使用每行的子网掩码与目标进行“与”操作，判断结果和目的网络地址是否相同。在这个例子中，会匹配R1路由表中的第二条路。因为H2的IP地址（目标IP地址）为128.30.33.138，128.30.33.138与路由表中的子网掩码（255.255.255.128）做与操作，得到的是128.30.33.128，匹配第二项，选择接口1转发。 路由转发的进一步讨论 使用子网掩码后，路由表是否可能出现多条同时匹配的路由？ 目的网络地址 子网掩码 下一跳 128.30.33.0 255.255.255.0 接口0 128.30.33.128 255.255.255.128 接口1 128.30.36.0 255.255.255.0 R2 在这张路由表中，IP为128.30.33.138的地址既匹配第一条路又匹配第二条路，出现了多条同时匹配的路由。前缀表示法128.30.33.0/24 =&gt; (24是因为子网掩码有24个1)128.30.33.128/25 =&gt; (25是因为子网掩码有25个1)所以可以看出，下面这个网络是上面这个网络的细分子网结论： 可能，如果出现，采用掩码最长前缀（掩码中1的个数）匹配原则选择路径。若掩码前缀相同，则采用网络负载均衡的方式转发 IP地址的前缀表示法：128.30.33.128/25表示的IP地址的掩码为255.255.255.128在这个例子中，IP地址128.30.33.138同时匹配第一条和第二条路由，由于第二条路由的掩码前缀为25，长于第一条路由，因此选择第二条路由。 路由表原理3条法则 每台路由器根据其自身路由表中的信息独立作出决策 一台路由器的路由表中包含某些信息并不表示其他路由器也包含相同的信息 有关两个网络之间的路径的路由信息并不能提供反向路径（即返回路径）的路由信息 关于路由的说明目标网络路由 最常见的路由项，能匹配一个网络的IP地址 特定主机路由 只能匹配某个特定的主机IP的路由，优先级最高 默认路由（缺省路由） 可以匹配所有IP地址的路由，优先级最低 目的网络地址 子网掩码 下一跳 128.30.33.128 255.255.255.128 接口0 128.30.33.111 255.255.255.255 接口1 0.0.0.0 0.0.0.0 接口2 子网掩码的作用 划分子网，便于管理，提高IP地址利用率]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类的IP地址]]></title>
    <url>%2F2020%2F04%2F13%2F%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[现有物理地址再有IP地址 IP地址的表示方法为点分十进制法 IP地址的设计思想：网络部分 + 主机部分 分类的IP地址特征：根据不同特征的IP地址，事先约定好网络号所占的位数和主机号所占的位数。A类地址全球一共有2^7^-2 个A类网络，每个A类网络共有2^24^-2个主机地址，地址范围是1.0.0.0 — 126.255.255, 网络号全0是没有地址，而127开头的地址保留为本机回环地址（浪费很大，IPV6进行了改进，只用了一个地址表示本机回环地址）。 有两个主机号被保留，主机号全0，如126.0.0.0，表示这个网络地址；主机号全1，如126.255.255.255 ，是广播地址。B类地址全球共有 2^14^ 个B类网络，每个B类网络共有2^16^-2个主机地址，地址范围是：128.0.0.0 — 191.255.255.255C类地址全球共有2^21^个C类网络，每个C类网络共有2^8^-2个主机地址，地址范围是：192.0.0.0 — 223.255.255.255此外还有D类地址和E类地址 特殊的IP地址网络地址主机号全0的地址，例如192.168.1.0特定网络的广播地址主机号全为1的地址，表示特定网络的广播，例如192.168.1.255本地链路广播地址255.255.255.255，表示本机所在的网络广播本机环回地址127开头的地址，表示主机自身，例如127.0.0.1内网地址（私有地址）保留给任何一个公司单位内部网络使用的IP地址，不能出现在公网上，范围是：10.0.0.0 — 10.255.255.255172.16.0.0 — 172.31.255.255192.168.0.0 — 192.168.255.255链路本地地址无IP地址时由操作系统临时分配的IP地址169.254.0.0 — 169.254.255.255 判断IP地址是否可以有效用于公网的接口上1.1.1.1 是10.1.1.0 不是，这是内网地址127.10.2.1 不是，这是本地环回地址169.254.1.2 不是，这是操作地址给的地址，没有地址200.200.200.255 不是，这是C类地址，主机号全1131.107.0.0 不是，这是B类地址，主机号全0229.0.0.1 不是，这是D类地址判断准则：非D，E类地址，非广播地址。非网络地址，非私有地址，非本地环回地址]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop 重新格式化 NameNode]]></title>
    <url>%2F2020%2F04%2F08%2Fhadoop%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%20NameNode%2F</url>
    <content type="text"><![CDATA[【问题描述】 在安装配置hadoop的过程中，很可能发生错误导致datanode或者namenode 启动失败，这时我们可以选择重新格式化 namenode。一、删除data数据和log日志二 、使用命令 bin/dfs namenode -format 重新格式化【注意事项】为什么不能一直格式化NameNode，格式化NameNode需要注意什么？ 原因： 格式化NameNode，会产生新的集群id，导致NameNode 和 DataNode的集群id 不一致，集群找不到以往数据。]]></content>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令整理 —— vi 和 vim 编辑器]]></title>
    <url>%2F2020%2F04%2F03%2FLinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%20%E2%80%94%E2%80%94%20vi%20%E5%92%8C%20vim%20%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、目录结构二 、vim 和 vim 编辑器2.1【基本介绍】所有的 Linux 系统都会内建 vi 文本编辑器。vim 具有程序编辑的能力，可以看做是 vi 的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。2.2 三种常见模式 1、正常模式 以 vim 打开一个档案就直接进入一般模式了(默认)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。 2、插入模式/编辑模式在模式下，程序员可以输入内容。按下 i, I, o, O, a, A, r, R 等任何一个字母之后才会进入编辑模式, 一般来说按 i 即可 3、命令行模式在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的！ 2.3 快捷键 1) 拷贝当前行 yy , 拷贝当前行向下的 5 行 5yy，并粘贴（p）。2) 删除当前行 dd , 删除当前行向下的 5 行 5dd3) 在文件中查找某个单词 [命令行下 /关键字 ， 回车 查找 , 输入 n 就是查找下一个 ]4) 设置文件的行号，取消文件的行号.[命令行下 : set nu 和 :set nonu]5) 编辑 /etc/profile 文件，使用快捷键到底文档的最末行[G]和最首行[gg],注意这些都是在正常模式下执行的。6) 在一个文件中输入 “hello” ,然后又撤销这个动作，再正常模式下输入 u7) 编辑 /etc/profile 文件，并将光标移动到 第 20 行 shift+g第一步：显示行号 :set nu 第二步：输入 20 这个数第三步: 输入 shift+g]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令整理 —— 目录结构]]></title>
    <url>%2F2020%2F03%2F26%2FLinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%20%E2%80%94%E2%80%94%20%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[二 、vi 和 vim 编辑器【写在前面】云计算与分布式这门课程的实验都是在Linux下完成的，虽然之前也一直也学习过Linux，但是一直没有系统的过一遍。这周花了两天的时间看完了尚硅谷的Linux教程，在这里记录一下学习过程，也方便自己以后的学习。一、目录结构在 Linux 世界里，一切皆文件linux 的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录。具体目录结构➢/bin（/usr/bin、/usr/local/bin） 是Binary的缩写，这个目录存放着最经常使用的命令 ➢/sbin (/usr/sbin、/usr/local/sbin) s就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序 ➢/home 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 ➢/root 该目录为系统管理员，也称作超级权限者的用户主目录 ➢/boot 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 ➢/proc 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息 ➢/srv service 缩写，该目录存放一些服务启动后需要提取的数据 ➢/sys 这是Linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 ➢/tmp 这个目录是用来存放一些临时文件的 ➢/dev 类似于winldows的设备管理器，把所有的硬件用文件的形式存储。 ➢/media linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。 ➢/mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。 ➢/opt 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。 ➢/usr/local 这是另一个给主机额外安装软件所安装的目录。-般是通过编译源码方式安装的程序。 ➢/var 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。 ➢/selinux [security-enhanced linux] 360 SELinux是一种安全子系统，它能控制程序只能访问特定文件。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据技术生态体系]]></title>
    <url>%2F2020%2F03%2F25%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%94%9F%E6%80%81%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop的组成]]></title>
    <url>%2F2020%2F03%2F25%2FHadoop%E7%9A%84%E7%BB%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[一、Hadoop 1.x 和 2.x 的区别二、HDFS架构1）NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。（笔者把它简单理解为书的目录）2）DataNode（dn）：在本地文件系统存储文件块数据，以及块数据的校验和。（笔者把它简单理解为书中真正的内容） 3）Secondary NameNode（2nn）：用来监控HDFS状态的辅助后台程序，每隔一段时间获取HDFS元数据的快照。 三、YARN架构1）ResourceManager（RM） 处理客户端请求 监控NodeManager 启动或监控ApplicationMaster 资源的分配与调度 2）NodeManager（NM） 管理单个节点上的资源 处理来自ResourceManager的命令 处理来自ApplicationMaster的命令 3）ApplicationMaster（AM） 负责数据的切分 为应用程序申请资源并分配给内部的任务 任务的监控与容错 4）Containeryarn中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPU、磁盘等]]></content>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输层协议]]></title>
    <url>%2F2020%2F03%2F20%2F%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[一、传输层的基本概念及功能基本概念 传输层负责端（主机）到端（主机）之间的数据传输控制 传输层依赖于网络层的服务，对应用层提供传输服务 传输层的功能跟踪会话 跟踪源主机和目的主机上应用程序间的每次通信； 数据分段 将数据分段，并管理每个片段； 数据重组 将数据重组，并管理每个片段； 标识应用程序 标识不同的应用程序 应用层标识-分用和复用 分用：接收方传输层根据端口号分用到不同的应用层进程 复用：发送方不同的应用层进程根据不同端口号复用到同一传输层中 二、因特网传输层提供的服务 无连接不可靠的服务（UDP） 面向连接可靠的传输服务（TCP） 因特网传输层不能提供的服务 实时性保证 带宽承诺 可靠的广播通信三、UDP协议概述 特性： ”最简单的“ Internet传输协议 提供不可靠的数据传输，又称“尽力而为的 try best effort” 的服务，其本质是宁缺毋滥，尽力传输 UDP协议允许： 数据丢失 应用数据乱序到达 在UDP收发双方之间，无需握手建立连接 每个UDP数据段的操作都互相独立 四、可靠传输协议概念可靠传输协议保证接收方接收到的数据一定是正确、按序的。注意：可靠传输协议不能保证数据一定到达 停止等待协议的设计 定义： SW（stop and wait）停止等待协议 发送方每发送一个报文，必须收到接收方的回复确认后才能发送下一个报文。 这种情况下乱序不存在 停止等待协议1.0查错的方法 校验和、CRS冗余检验等从错误中恢复的方法 使用确认（ACKs)和否认（NAKs)机制 若收到NAK，重传分组（缓存机制） 停止等待协议2.0 停止等待协议3.0 前提：数据可能出错和丢失 数据丢失的处理方法：发送方对发送的分组定义一个超时时间（定时器），数据超时则重传数据 数据超时并非一定丢失了，也可能确认丢失，也可能分组或确认延迟了。 超时未丢失将导致重复分组问题，使用序号解决重复分组问题 超时时间应当根据RTT（往返时间）动态变化。超时时间应当大于历史分组的RRT]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[传输层协议详解]]></title>
    <url>%2F2020%2F03%2F20%2F%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、传输层的概念和服务1、传输层的基本概念 传输层负责端到端之间的数据传输控制 传输层依赖于网络层的服务，对应用层提供传输服务2、传输层的功能跟踪会话 跟踪源主机和目的主机上应用程序间的每次通信 数据分段 将数据分段，并管理每个分段 数据重组 将数据重组，并管理每个片段 标识应用程序 标识不同的应用程序 3、因特网传输层提供的服务 无连接不可靠的服务（UDP） 面向连接可靠的传输服务（TCP） 因特网传输层不能提供的服务 实时性保证 带宽承诺 可靠的广播通信 二、UDP协议1、UDP协议概述特性： “最简单的”Internet传输协议 提供不可靠的数据传输，又称“尽力而为”的服务，其本质是宁缺毋滥，尽力传输 UDP协议允许： 数据丢失 应用数据乱序到达 在UDP收发双方之间，无需握手建立连接 每个UDP数据段的操作都互相独立 2、UDP协议的首部 三、可靠传输协议1、可靠传输协议概述概念： 可靠传输协议保证接收方接收到的数据一定是正确、按序的 注意： 可靠传输协议不能保证数据一定到达 应用层次： 可靠传输协议的机制可以用于数据链路层、网络层、传输层和应用层 2、停止等待协议的设计定义： SW（stop and wait）停止等待协议 发送方每发送一个报文，必须收到接收方的回复确认后才能发送下一个报文 停止等待协议1.0的讨论 差错的方法 校验和、CRS冗杂检验等 从错误中恢复的方法 使用确认（ACKs）和否认（NAKs）机制 若收到NAK，重传分组（缓存机制） 停等协议的设计缺陷？ACK/NAK出错重复分组…… 所以引入了序号机制 停等协议2.0 停等协议3.0前提：数据可能出错和丢失 数据丢失的处理方法： 发送方对发送的分组定义一个超时时间（定时器），若在超时时间里没有收到ACK，则认为数据丢失。 数据超时则直接重传数据 停等协议3.0超时讨论 问题： 数据超时是否一定丢失？ 结论： 数据超时并非一定丢失了，可能确认丢失，也可能分组或确认延迟了 超时未丢失将导致重复分组问题，使用序号解决重复分组问题 进一步思考： 超时时间如何确定，固定的还是变化的？ 结论： 超时时间应当根据RTT（往返时间）动态变化 超时时间应当大于历史分组的RTT 更特殊的情况]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP协议、电子邮件系统、Telnet远程控制]]></title>
    <url>%2F2020%2F03%2F20%2FFTP%E5%8D%8F%E8%AE%AE%E3%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81Telnet%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、FTP协议FTP定义 文件传输协议（File Transfer Protocol） 用于因特网文件传输（RFC 959） FTP特性 使用客户端/服务器模式 使用TCP提供可靠的传输 FTP属于维护状态的协议 FTP使用两条TCP连接完成数据传输 FTP的两条连接数据连接问题 当有具体文件或目录内容传输时，临时建立数据连接 主动模式下由服务器方发起，服务器端口号20 被动模式下由客户端发起，服务器端口号不确定 二、电子邮件系统电子邮件系统的组成用户代理 电子邮件客户端软件，如浏览器,Outlook,Outlook Express,Foxmail等 邮件服务器 提供邮件服务的主机如 sina邮件服务器sina.com, google的邮件服务器gmail.com 邮件发送和接收协议 HTTP，SMTP，POP，IMAP等 SMTP协议 定义： Simple Mail Tranfer Protocol：简单邮件传输协议 用于使用邮件代理发邮件给邮件服务器或邮件服务器之间转发邮件 SMTP特性： 使用TCP可靠的传送邮件报文，服务器监听端口为25 使用命令/响应代码完成邮件传输的控制交互 SMTP只能传送7bit的ASCII码的邮件报文 SMTP采用持续性的方式发邮件 Quote Printable编码方式 把一个8bit的非ASCII字符用两个16进制数值表示，然后在前面加“=” QP编码方式适用于当所传送的数据中只有少量的非ASCII，例如汉字 邮件接收协议简介用户收取邮件常用的协议 POP（Post Office Protocol邮局协议）：服务器端口默认110 IMAP（Internet Mail Access 因特网邮件访问协议）：服务器默认端口143 HTTP 三、Telnet远程控制 Telnet用于终端使用命令行方式对服务器进行远程控制。端口号为TCP的23 Telnet服务配置Telnet 的客户端称为VTY（虚拟终端），Telnet不安全，明文传输，可以使用更安全的SSH协议替代。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx启动后无法访问页面]]></title>
    <url>%2F2020%2F03%2F19%2FNginx%E5%90%AF%E5%8A%A8%E5%90%8E%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[【问题描述】Nginx启动后浏览器输入IP地址无法访问页面 一、检查Nginx是否成功启动./sbin/nginx -t 二、检查80端口是否开放 三、打开防火墙80端口，重启防火墙firewall-cmd --zone=public --add-port=8082/tcp --permanent systemctl restart firewalld.service]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 安装并启动 Nginx]]></title>
    <url>%2F2020%2F03%2F19%2FCentOS%207%20%E5%AE%89%E8%A3%85%E5%B9%B6%E5%90%AF%E5%8A%A8Nginx%2F</url>
    <content type="text"><![CDATA[一、安装必要的库1、安装gcc gcc-c ++1yum install -y gcc gcc-c ++2、gzip模块需要 zlib 库123456cd /usr/localwget http://zlib.net/zlib-1.2.11.tar.gztar -zxvf zlib-1.2.11.tar.gzcd zlib-1.2.11./configmake &amp;&amp; make install 3、重写模块需要pcre库 123456cd /usr/localwget http://jaist.dl.sourceforge.net/project/pcre/pcre/8.33/pcre-8.33.tar.gztar -zxvf pcre-8.33.tar.gzcd pcre-8.33./configuremake &amp;&amp; make install 4、ssl功能需要openssl库 123456cd /usr/localwget http://www.openssl.org/source/openssl-1.0.1j.tar.gztar -zxvf openssl-1.0.1j.tar.gzcd openssl-1.0.1j./configuremake &amp;&amp; make install 二、安装nginx123456cd /usr/localwget http://nginx.org/download/nginx-1.14.0.tar.gztar -zxvf nginx-1.14.0.tar.gzcd nginx-1.14.0./configure --user=nobody --group=nobody --prefix=/usr/localinx --with-http_stub_status_module --with-http_gzip_static_module --with-http_realip_module --with-http_sub_module --with-http_ssl_module --with-pcre=/usr/local/pcre-8.33 --with-zlib=/usr/local/zlib-1.2.11 --with-openssl=/usr/local/openssl-1.0.1jmake &amp;&amp; make install 三、启动12cd /usr/local/nginx./sbin/nginx 四、浏览器访问IP地址，出现Welcome to nginx!]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成MyBatis的分页插件PageHelper]]></title>
    <url>%2F2020%2F03%2F14%2FSpringBoot%E9%9B%86%E6%88%90MyBatis%E7%9A%84%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper%2F</url>
    <content type="text"><![CDATA[【写在前面】项目的后台管理系统需要展示所有资源信息，select * 虽然方便但数据量过于庞大会严重降低查找效率，页面加载慢，用户体验差。分页自然是必要选择，但原生的方法过于繁杂。MyBatis的分页插件PageHelper和SpringBoot的集成是更好的选择，它的使用非常简单，开发更为高效。代码如下 一、pom文件导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; 二、配置application.yml 123456##pagehelper分页插件pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 三、编写PageRequest、PageResult 实体类 12345678910111213141516171819202122232425262728package com.jxnu.os.model;/** * @author xiao */public class PageRequest &#123; /** * 当前页码 */ private int pageNum; /** * 每页数量 */ private int pageSize; public int getPageNum() &#123; return pageNum; &#125; public void setPageNum(int pageNum) &#123; this.pageNum = pageNum; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.jxnu.os.model;import java.util.List;/** * @author xiao */public class PageResult&#123; /** * 当前页码 */ private int pageNum; /** * 每页数量 */ private int pageSize; /** * 记录总数 */ private long totalSize; /** * 页码总数 */ private int totalPages; /** * 数据模型 */ private List&lt;?&gt; content; public int getPageNum() &#123; return pageNum; &#125; public void setPageNum(int pageNum) &#123; this.pageNum = pageNum; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public long getTotalSize() &#123; return totalSize; &#125; public void setTotalSize(long totalSize) &#123; this.totalSize = totalSize; &#125; public int getTotalPages() &#123; return totalPages; &#125; public void setTotalPages(int totalPages) &#123; this.totalPages = totalPages; &#125; public List&lt;?&gt; getContent() &#123; return content; &#125; public void setContent(List&lt;?&gt; content) &#123; this.content = content; &#125;&#125; 四、service层 编写findPage、PageInfo方法 12345678910111213141516public PageResult findPage(PageRequest pageRequest,Integer p_id) &#123; return PageUtils.getPageResult(pageRequest, getPageInfo(pageRequest,p_id)); &#125; /** * 调用分页插件完成分页 * @param pageRequest * @return */ private PageInfo&lt;Resource&gt; getPageInfo(PageRequest pageRequest,Integer p_id) &#123; int pageNum = pageRequest.getPageNum(); int pageSize = pageRequest.getPageSize(); PageHelper.startPage(pageNum, pageSize); List&lt;Resource&gt; resources = resourceMapper.selectPage(p_id); return new PageInfo&lt;Resource&gt;(resources); &#125; 五、controller层编写findPage方法 123456@PostMapping(value="/findPage") public Object findPage(@RequestBody(required = false) PageRequest pageQuery,Integer p_id) &#123; //System.out.println(pageQuery.getPageNum()); //System.out.println(p_id); return resourceService.findPage(pageQuery,p_id); &#125; ok ,大功告成！]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot前后端分离项目MultipartFile获取前端传的file为null问题]]></title>
    <url>%2F2020%2F03%2F14%2Fspringboot%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AEMultipartFile%E8%8E%B7%E5%8F%96%E5%89%8D%E7%AB%AF%E4%BC%A0%E7%9A%84file%E4%B8%BAnull%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[【问题描述】springboot+vue 前后端分离项目，在对接上传文件功能时，一直显示文件为空。【分析】查找了很多博客，解决方法五花八门，但原因应该还是 springboot自带的org.springframework.web.multipart.MultipartFile和Multipart冲突。所以使用 @EnableAutoConfiguration 注解的exclude属性 进行排除。 【解决方法】亲测有效！！！代码如下： 12345678910111213@EnableAutoConfiguration(exclude = &#123;MultipartAutoConfiguration.class&#125;)public class UploadConfig &#123; @Bean(name = "multipartResolver") public MultipartResolver multipartResolver() &#123; CommonsMultipartResolver resolver = new CommonsMultipartResolver(); resolver.setDefaultEncoding("UTF-8"); resolver.setResolveLazily(true); resolver.setMaxInMemorySize(40960); //上传文件大小 resolver.setMaxUploadSize(5 * 1024 * 1024); return resolver; &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式——ACID原则 CAP理论]]></title>
    <url>%2F2020%2F03%2F11%2F%E5%88%86%E5%B8%83%E5%BC%8F%E2%80%94%E2%80%94ACID%E5%8E%9F%E5%88%99%20%20CAP%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[分布式计算的原理分布式计算就是将计算任务分摊到大量的计算节点上，一 起完成海量的计算任务。而分布式计算的原理和并行计算 类似，就是将一个复杂庞大的计算任务适当划分为一个个 小任务，任务并行执行，只不过分布式计算会将这些任务 分配到不同的计算节点上，每个计算节点只需要完成自己 的计算任务即可，可以有效分担海量的计算任务。而每个 计算节点也可以并行处理自身的任务，更加充分利用机器 的CPU资源。最后再将每个节点的计算结果汇总，得到最 后的计算结果。 分布式计算的理论基础ACID原则ACID是数据库事务正常执行的四个原则，分别指原子性、一致性、独立性及持久性。 A（Atomicity）—— 原子性 原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失 败，整个事务就失败，需要回滚。 例如银行转账，从A账户转100元至B账户，分为两个步骤：①从A账户取 100元；②存入100元至B账户。 这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失 败，钱会莫名其妙少了100元。 C（Consistency）—— 一致性 一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。 例如现有完整性约束a + b = 10，如果一个事务改变了a，那么必须得改变 b，使得事务结束后依然满足a + b = 10，否则事务失败。 I（Isolation）—— 独立性 所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问 的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问 的数据就不受未提交事务的影响。 例如交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如 果此时B查询自己的账户，是看不到新增加的100元的。 D（Durability）—— 持久性 持久性是指一旦事务提交后，它所做的修改将会永久保存在数据库上， 即使出现宕机也不会丢失。 这些原则解决了数据的一致性、系统的可靠性等关键问题，为关系数据 库技术的成熟以及在不同领域的大规模应用创造了必要的条件。 CAP理论 一个分布式系统最多只 能同时满足一致性（Consistency）、可用 性（Availability）和分区容错性（Partition tolerance）这三项中的两项。 一致性指“All nodes see the same data at the same time”，即更新操作成功并返 回客户端完成后，所有节点在同一时间的数据完全一致。对于一致性，可以分 为从客户端和服务端两个不同的视角来看。 从客户端来看，一致性主要指多并发访问时更新过的数据如何获取的问题。 从服务端来看，则是如何将更新复制分布到整个系统，以保证数据的最终一 致性问题。 可用性 指“Reads and writes always succeed”，即服务一直可用，而且是 在正常的响应时间内。对于一个可用性的分布式系统，每一个非故障的节点 必须对每一个请求作出响应。也就是该系统使用的任何算法必须最终终止 当同时要求分区容错性时，这是一个很强的定义：即使是严重的网络错误， 每个请求也必须终止。好的可用性主要是指系统能够很好地为用户服务，不 出现用户操作失败或者访问超时等用户体验不好的情况。通常情况下可用性 和分布式数据冗余、负载均衡等有着很大的关联。 分区容错性 指“The system continues to operate despite arbitrary message loss or failure of part of the system”，也就是指分布式系统在遇到某节点或网络 分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。 分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原 因导致系统无法正常运转。好的分区容错性要求应用虽然是一个分布式系统， 但看上去却好像是一个可以运转正常的整体。例如现在的分布式系统中有某 一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求， 或者是机器之间有网络异常，将分布式系统分隔为独立的几个部分，各个部 分还能维持分布式系统的运作，这样就具有好的分区容错性。 CAP权衡无法同时满足一致性、可用性和分区容错性这三个特性，那应该如何取舍呢？ （1）CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用 性）是可以保证的。但其实分区始终会存在，因此CA的系统更多的是允许分区 后各子系统依然保持CA。 （2）CP without A：如果不要求A（可用），相当于每个请求都需要在Server之 间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很 多传统的数据库分布式事务都属于这种模式。 （3）AP without C：要高可用并允许分区，则需放弃一致性。一旦分区发生， 节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务， 而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承与多态]]></title>
    <url>%2F2020%2F03%2F05%2FJava%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[☆ 继承 ☆ 继承是面向对象思想的三大特性之一，使类与类之间产生特殊 - 一般的关系，即is-a关系。 继承是从已有类中派生出新的类，新的类能吸收已有类的属性和方法，并且能拓展新的属性和行为。 在Java中使用extends关键字表示继承，语法表示为: class 子类 extends 父类{}。 子类被称为派生类，父类又被称为超类。 子类继承父类，表明子类是一种特殊的父类，子类拥有父类的属性和方法，并且子类可以拓展具有父类所没有的一些属性和方法。 子类即使不扩展父类，也能维持拥有父类的操作。 优缺点优点提高了代码的复用性提高了代码的维护性让类与类之间产生了关系，是多态的前提缺点增加了耦合性OOP思想开发原则：高内聚，低耦合耦合：类与类之间的关系内聚：自身完成事情的能力 继承特点Java只支持单继承，不支持多重继承操作（extends A,B,C..） 123class A &#123;&#125;class B &#123;&#125;class C extends A,B &#123;&#125; // 错误的，一个子类继承了两个父类，Java中不允许 为什么只支持单继承？ 多继承会存在安全隐患，因为当继承的多个类都存在相同的属性或方法名相同方法体不同的方法，子类进行调用时，就会产生不知道该调用哪一个类中的方法的情况。 Java支持多层继承（继承体系） 123class A &#123;&#125;class B extends A &#123;&#125;class C extends B &#123;&#125; 超类Animal派生出子类Dog 123456789101112131415public class Ch_4_13&#123; public static void main (String[] args) &#123; Dog d=new Dog(); d.name="Snoppy"; d.age=3; d.bark(); //引用完全合法 &#125;&#125;class Animal &#123; public String name; public int age; public void eat()&#123; System.out.println(name +" are eating！");&#125;&#125;class Dog extends Animal &#123; public void bark()&#123; System.out.println("Dog barks！");&#125;&#125; ☁ is - A 与 has - A 关系has - A: 意为“有什么”，刻画的是类与成员之间的关系，决定了对象能实施的动作。is - A: 意为“是什么”，刻画的是对象与类之间的关系，可用于判别对象间的赋值兼容。 1234567891011121314class Animal &#123; public String name; public int age; public void eat()&#123; System.out.println(name +" are eating！");&#125;&#125;class Dog extends Animal &#123; public void bark()&#123; System.out.println("Dog barks！");&#125;&#125;Animal a = new Dog();//合法，因为Dog和Animal满足is-A关系，即Dog对象是Animal对象a.age = 2;//合法，a是Animal类型，Animal与age满足has-A关系a.bark();//非法，a是Animal类型，Animal与bark()不满足has-A关系Dog d = new Animal();//非法，Animal对象不一定是Dog ☆ 多态 ☆多态概述 多态是继封装、继承之后，面向对象的第三大特性。 多态现实意义理解： a. 现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。b. Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。 前提条件：必须有子父类关系。 多态体现为父类引用变量可以指向子类对象。 在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。 重写(Override) 从字面上看，重写就是重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。 发生在父类与子类之间 方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同 final 方法不能被子类重写 静态方法不能被子类重写 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private) 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常 123456789101112class A&#123; public void f(int x)&#123;;&#125; &#125;public class Ch_4_20 extends A&#123; public void f(int x)&#123;;&#125; //对超类A中的f()正确的重写 //void f(double x)&#123;;&#125; //是重载，而不是重写 //public int f(int x)&#123;return 0;&#125; //编译错，不能根据返回类型来区分重写 //void f(int x)&#123;;&#125; //编译错，重写时缩小了访问权限&#125; 重载(Overload)在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。 重载Overload是一个类中多态性的一种表现 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java抽象类、接口、类的特殊成员]]></title>
    <url>%2F2020%2F03%2F05%2FJava%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[抽象类在面向对象的概念中，所有的对象都是通过类来描绘的，但是并不是所有的类都是用来描绘对象的.如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类往往用来表征我们在对问题领域进行分析、设计中得出的抽象概念，是对一系列看上去不同，但是本质上相同的具体概念的抽象。比如：如果我们进行一个图形编辑软件的开发，就会发现问题领域存在着圆、三角形 这样一些具体概念，它们是不同的，但是它们又都属于形状这样一个概念，形状这个概念在问题领域是不存在的，它就是一个抽象概念。正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。 抽象方法：一种特殊的方法，它只有声明，而没有具体的实现（无方法体）。抽象方法的声明格式为： 1abstract void f(); 抽象方法必须用abstract关键字进行修饰。abstract 只能修饰类或类中的成员方法，不能修饰属性。被修饰的类或方法分别称作抽象类或抽象方法。其中抽象方法不能有方法体，而抽象类不能实例化，如果一个类含有抽象方法，则这个类一定为抽象类，抽象类必须在类前用abstract关键字修饰。当然，抽象类也可以没有抽象方法。 12345abstract class Test1&#123; abstract void f();//正确， 抽象方法不能有方法体 abstract void g()&#123;;&#125;//编译错， 抽象方法不能有方法体 void h();//编译错， 非抽象类必须有方法体&#125; 【注意】：abstract 不能修饰最终方法、静态方法或构造函数，因为这三类方法都不能被子类重写。 12345abstract class Test2&#123; abstract Test2();//编译错， 构造函数不能被abstract修饰 abstract final void f();编译错， final方法不能被abstract修饰 abstract static void g();编译错， 静态方法不能被abstract修饰&#125; 抽象类是契约的重量级应用方式 接口是契约的轻量级应用方式 接口Java接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。接口可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。接口是解决Java无法使用多继承的一种手段，但是接口在实际中更多的作用是制定标准的。或者我们可以直接把接口理解为100%的抽象类，既接口中的方法必须全部是抽象方法。特点： 就像一个类一样，一个接口也能够拥有方法和属性，但是在接口中声明的方法默认是抽象的。（即只有方法标识符，而没有方法体）。 接口指明了一个类必须要做什么和不能做什么，相当于类的蓝图。 一个接口就是描述一种能力，比如“运动员”也可以作为一个接口，并且任何实现“运动员”接口的类都必须有能力实现奔跑这个动作（或者implement move()方法），所以接口的作用就是告诉类，你要实现我这种接口代表的功能，你就必须实现某些方法，我才能承认你确实拥有该接口代表的某种能力。 如果一个类实现了一个接口中要求的所有的方法，然而没有提供方法体而仅仅只有方法标识，那么这个类一定是一个抽象类。（必须记住：抽象方法只能存在于抽象类或者接口中，但抽象类中却能存在非抽象方法，即有方法体的方法。接口是百分之百的抽象类）。 为什么要用接口： 接口被用来描述一种抽象。 因为Java不像C++一样支持多继承，所以Java可以通过实现接口来弥补这个局限。 接口也被用来实现解耦。 接口被用来实现抽象，而抽象类也被用来实现抽象，为什么一定要用接口呢？- 接口和抽象类之间又有什么区别呢？原因是抽象类内部可能包含非final的变量，但是在接口中存在的变量一定是final，public， static的。 接口的实现： 1234[修饰符] interface 接口名 [extends 父接口列表]&#123; [public][static][final]类型 成员常量 = 常量值 [public][abstract] 返回类型 成员方法名（[参数列表]）&#125; 具体的例子：我们知道，如果某个设备需要向电脑中读取或者写入某些东西，这些设备一般都是采用USB方式与电脑连接的，我们发现，只要带有USB功能的设备就可以插入电脑中使用了，那么我们可以认为USB就是一种功能，这种功能能够做出很多的事情（实现很多的方法），其实USB就可以看做是一种标准，一种接口，只要实现了USB标准的设备我就认为你已经拥有了USB这种功能。（因为你实现了我USB标准中规定的方法）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//先声明USB接口：其中规定了要实现USB接口就必须实现接口规定实现的read( )和write( )这两个方法。interface USB &#123; void read(); void write();&#125;//然后在写一个U盘类和一个键盘类，这两个类都去实现USB接口。（实现其中的方法）class YouPan implements USB &#123; @Override public void read() &#123; System.out.println("U盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("U盘正在通过USB功能写入数据"); &#125;&#125;class JianPan implements USB &#123; @Override public void read() &#123; System.out.println("键盘正在通过USB功能读取数据"); &#125; @Override public void write() &#123; System.out.println("键盘正在通过USB功能写入数据"); &#125;&#125;//那么，现在U盘和键盘都实现了USB功能，也就是说U盘和键盘都能够调用USB接口中规定的方法，并且他们实现的方式都不一样。public class Main &#123; public static void main(String[] args) &#123; //生成一个实现可USB接口（标准）的U盘对象 YouPan youPan = new YouPan(); //调用U盘的read( )方法读取数据 youPan.read(); //调用U盘的write( )方法写入数据 youPan.write(); //生成一个实现可USB接口（标准）的键盘对象 JianPan jianPan = new JianPan(); //调用键盘的read( )方法读取数据 jianPan.read(); //调用键盘的write( )方法写入数据 jianPan.write(); &#125;&#125; 运行结果 1234U盘正在通过USB功能读取数据U盘正在通过USB功能写入数据键盘正在通过USB功能读取数据键盘正在通过USB功能写入数据 【注意】：1）接口不是类，接口中的方法都是抽象的，是没有方法体的没有构造函数，也不能实例化出对象。2）一个类可以实现不止一个接口。3）一个接口可以继承于另一个接口，或者另一些接口，接口也可以继承，并且可以多继承。4）一个类如果要实现某个接口的话，那么它必须要实现这个接口中的所有方法。5）接口中所有的方法都是抽象的和public的，所有的属性都是public,static,final的。6）接口用来弥补类无法实现多继承的局限。7）接口也可以用来实现解耦。 123456789interface A&#123; int x = 1;&#125;interface B&#123; int y = 2;&#125;interface C extends A,B&#123; int z = 3;&#125;//也称C为复合接口，它有A，B两个父接口 类中的特殊成员——内嵌类型、初始化块、本地方法 内嵌类型 内嵌类型就是在类或接口内部定义的自定义类型，你包括内部类和内部接口。包围内部类或内部接口的类称为囿类型，或包围类型、外部类型等。 12345678910111213141516171819class A&#123; //A是包围类 class B&#123; //内部类 int x; &#125; interface C&#123; //内部接口 int y = 0; &#125;&#125;编译后将产生三个文件：A.class、A$B.class、A$C.classinterface X&#123; //X是包围接口 class Y&#123; //内部类 int x; &#125; interface Z&#123; //内部接口 int y = 0; &#125;&#125;编译后将产生三个文件：X.class、X$Y.class、X$Z.class 内部类存取规则：1、作为囿类的成员，内部类可以存取囿类的其他所有成员，包括私有成员。2、存取内部类及其成员必须要借助囿类或囿类的对象。显然，若囿类对象不能访问，那么内部类也不能访问。 12345678910111213141516171819202122232425262728public class Ch_4_27 &#123; public static void main (String[] args) &#123; Z a=new Z(); Z.B ab=a.g(); //★★★借助囿类提供的方法获得内部类对象 ab.h2(); //★★★正确，可调用内部类的public方法 //ab.y=6; //编译错，不能访问私有成员 //A.B ab1=new A.B(); //编译错，不能以这种方式创建内部类对象 //A.B ab1=new a.B(); //编译错，不能以这种方式创建内部类对象 Z.B ab1=new Z().new B(); //★★★可用这种方式直接创建内部类对象 Z.B ab2=a.new B(); //★★★可用这种方式直接创建内部类对象 &#125;&#125;class Z&#123; public class B&#123; //内部类定义 private int y; private void h1()&#123;x=10;&#125; //内部类的成员方法可直接访问囿类的私有成员 public void h2()&#123; //用于测试对外部内部类成员的调用 System.out.println("Hi, Executed innerClass Method!"); Z.this.x=5; //★★★此句显示：在内部类中如何引用囿类对象自身 &#125; &#125; private int x; private void f()&#123; //y=5; //编译错，囿类成员方法不能直接访问内部类成员 B b=new B(); b.y=5; //★★★只能借助内部类对象访问内部类的成员 &#125; public B g()&#123; return new B(); &#125;//返回内部类的实例对象&#125; 1、内部类和囿类可以任意访问，没有权限上的限制。但囿类成员方法访问内部类成员，必须要借助内部类的对象，反之则无此限制。 2、在囿类外部，只要权限允许，也可以通过囿类对象访问内部类的成员，如ab.h2()；。但是，ab.y=6则编译错误，因为权限不允许。 3、两种在外部获取内部类对象的方式： 1）通过囿类的public方法返回，如a.g();。 2）直接调用内部类的构造函数，但方式特殊，如new A().new B();或者a.new B();。 静态内部类Java规定：若内部类中有静态成员，则该内部类必须是静态内部类。 123456789101112class A&#123; static class A1&#123; int x; static int y;//正确 &#125; class A2&#123; int a ; static int b; //编译错，非静态内部类中不能有静态成员 &#125;&#125;A.A1.y = 10;//合法 测试静态类和非静态类 成员内部类(可以使用private、default、 protected、 public任意进行修饰。类文件:外部类$内部类.class) a)非静态内部类(外部类里使用非静态内部类和平时使用其他类没什么不同) i. 非静态内部类必须寄存在一个外部类对象里。因此,如果有一个非静态内部类对象那么一定存在对应的外部类对象。非静态内部类对象单独属于外部类的某个对象。 ii. 非静态内部类可以直接访问外部类的成员,但是外部类不能直接访问非静态内部类成员。 iii. 非静态内部类不能有静态方法、静态属性和静态初始化块。 iv. 外部类的静态方法、静态代码块不能访问非静态内部类,包括不能使用非静态内部类定义变量、创建实例。 v. 成员变量访问要点: 1.内部类里方法的局部变量:变量名。 2.内部类属性: this.变量名。 3.外部类属性:外部类名.this.变量名。 123456789101112131415161718192021222324252627public class TestInnerClass &#123; public static void main(String[] args) &#123; //创建内部类对象 Outer.Inner inner = new Outer().new Inner(); inner.show(); &#125;&#125;class Outer&#123; private int age = 10; public void testOuter() &#123; System.out.println("Outer.testOuter()"); &#125; class Inner&#123; int age = 20; public void show() &#123; int age = 30; System.out.println("外部类的成员变量age:"+Outer.this.age); System.out.println("内部类的成员变量age:"+this.age); System.out.println("局部变量age:"+age); &#125; &#125;&#125; 局部内部类和匿名内部类成员方法中只有局部变量、常量、内部类相应地称作局部内部类。局部变量不能用权限属性、static、abstract等属性的修饰，局部内部类也是如此。局部内部类的作用范围，仅限于其所在的方法。 123456789101112class A&#123; public void f()&#123; int x; class B&#123; int a; public void g()&#123; a = x; //编译错误 局部内部类不能引用所在方法中定义的变量。因为局部变量x存于f()的栈空间，f运行结束x将自动销毁。但对象存在于堆空间，若允许存取x，将可能导致错误。 &#125; &#125;//局部内部类 B b = new B(); &#125; 没有名字的内部类成为匿名类 12345678910111213public class Ch_4_28&#123; public static void main (String[] args) &#123; A a=new A() &#123; //定义A的匿名子类（匿名的局部内部类） public void f()&#123;System.out.println("匿名类.f()");&#125; public void g()&#123;;&#125; //可通过编译但无法使用 &#125;; //作为语句结束符的分号不能少，匿名类定义结束 a.f(); // a.g(); //编译错，因为a是A类型，A中无g()方法 &#125;&#125;class A&#123; public void f()&#123; System.out.println("A.f()"); &#125;&#125; 初始化块初始化块就是在类中独立于成员方法之外的代码段，它没有名字，不带参数，无返回值。被static修饰就是静态初始化块，否则就是实力初始化块。初始化块的执行遵循以下规则：1）初始块的执行顺序遵循其出现的次序。2）实例初始化块先于构造函数。3）静态初始化块在类中的初次加载时执行，仅执行一次，且先于实例初始化块。 1234567891011121314151617181920212223242526272829public class Ch_4_29&#123; public static void main(String[] args) &#123; System.out.print("ppppp== "); new TestBlock(); new TestBlock(99); &#125;&#125;class TestBlock &#123; TestBlock (int x)&#123; System.out.print("1== "); &#125; TestBlock ()&#123; System.out.print("2== "); &#125; static &#123; System.out.print("Static 3 == "); &#125; //静态初始化块 &#123; System.out.print("4== "); &#125; //实例初始化块 &#123; System.out.print("5== "); &#125; //实例初始化块 static &#123; System.out.print("Static 6== "); &#125; //静态初始化块&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[成员变量、局部变量、实例变量、静态变量、类变量、常量]]></title>
    <url>%2F2020%2F03%2F05%2F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E3%80%81%E7%B1%BB%E5%8F%98%E9%87%8F%E3%80%81%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[成员变量：直接在类中声明的变量叫成员变量(又称全局变量)▲ 初始化：如果未对成员变量设置初始值，则系统会根据成员变量的类型自动分配初始值：int分配初始值0、boolean分配初始值false，而自定义类型则分配初始值null▲作用范围：成员变量定义后，其作用域是其所在的整个类。且成员变量的定义没有先后顺序，但是最好将成员变量的定义集中在类的顶部。 123456789101112131415public class Field&#123; static int v;//定义int类型数据 static double w;//定义double类型数据 static char x;//定义char类型数据 static boolean y;//定义boolean类型数据 static String z;//定义String类型数据 public static void main(String[] args) &#123; System.out.println(v);//输出0 System.out.println(w);//输出0.0 System.out.println(x);//输出空，实质上此时x的值为0 System.out.println(y);//输出false System.out.println(z);//输出null &#125;&#125; 局部变量：方法中的参数、方法中定义的变量和代码块中定义的变量统称为局部变量。▲ 初始化：♢ 局部变量在使用以前必须显式初始化或赋值，局部变量没有默认值。♢ 声明局部变量时，数据类型前除final外不允许有其他关键字，即其定义格式为： [final] 数据类型 变量名 = 初始值；▲作用范围：局部变量的作用域范围从定义的位置开始到其所在语句块结束。【注意】1）如果局部变量的名字与全局变量的名字相同，则在局部变量的作用范围内全局变量被隐藏，即这个全局变量在同名局部变量所在方法内暂时失效。2）所以如果在局部变量的作用域范围内访问该成员变量，则必须使用关键字this来引用成员变量。 123456789101112public class LocalVariable&#123; int x = 1;//定义一个int类型的全局变量 void show() &#123; int x = 2;//方法中的局部变量 System.out.println("x="+x);//输出2 System.out.println("x="+this.x);//输出1 &#125; public static void main(String[] args) &#123; new LocalVariable().show(); &#125;&#125; 实例变量：不用 static 修饰的 成员变量 。随对象的创建而创建，每个对象都有自己的独有的实例变量，属于对象私有。调用要实例化对象，用 对象名.实例变量名 才可以调用，如：Student student= new Student (); int YouAge = student.age; (当然，一般都会将成员变量设为 private ，通过属性方法调用)。 静态变量：静态变量就是用 static 修饰的成员变量。又叫 类变量 。一个类里只有一份，属于对象共有，调用是一般用 类名.静态变量名 就可以调用，或者用 对象名.静态变量名 也可以调用，调用的都是同一个变量，如： Student.height 。常量：用 final 修饰的成员变量叫常量。在类中也是只有一份，同时不可以修改它的值。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象语言基础]]></title>
    <url>%2F2020%2F03%2F05%2FJava%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[面向过程 就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。面向对象 是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。1、 区分类、对象和对象的引用对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。 类：类是一个模板，它描述一类对象的行为和状态。 创建对象对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步： 声明：声明一个对象，包括对象名称和对象类型。 实例化：使用关键字new来创建一个对象。 初始化：使用new创建对象时，会调用构造方法初始化对象。 12345678910111213141516public class Ch_4_1&#123; public static void main(String[] args) &#123; Pet a=new Pet(); //根据Pet类创建出一个对象 System.out.println("A Pet object is created."); a.name="Snoppy"; //修改对象的状态，即对属性成员赋值 a.showMe(); //操控对象的行为（或调用对象对外提供的服务） &#125;&#125; class Pet&#123; String name; //定义成员变量 void showMe()&#123; //定义成员方法 System.out.println("Hi, I'm "+name +" !"); &#125;&#125; 运行结果 12A Pet object is created.Hi, I'm Snoppy ! 【说明】 类中的内容统称为成员 —-&gt; 成员变量、成员方法。 只能通过引用名来操控对象，不能通过属性值。如本例中的a.name、a.showMe()，均为正确写法。 一个Java文件可包含多个类，但是只能存在一个public修饰的类，因为文件名必须与public类同名。若无public类，则文件取名只要满足标识符命名规则即可。文件中每个类（或接口），编译后都会产生一个单独的.class文件与之对应。 类成员可以缺省，俗称空类 1class Species&#123;&#125; 对象和对象引用的内存管理 1、内存空间的自动管理机制：基于栈的内存管理模式 特色：栈空间的数据被系统自动管理，即在函数调用时自动创建数据空间，在函数运行结束时自动释放数据空间。栈空间中的数据与特定函数直接相关。程序员在函数中定义的所有变量，无论是基本类型还是引用类型，均存储在栈空间。2、内存空间的手动管理机制：基于堆的内存管理模式 特色：在程序中给出申请或释放内存单元的指令，可实现内存单元的按需分配或释放。其中堆是一种无结构的内存区域，用于执行期间内存单元的动态分配和释放。所有对象均存储于堆空间。 2、 构造函数关于java类中的构造方法： 构造方法又被称为构造函数/构造器/Constructor 构造方法语法结构： [修饰符列表] 构造方法名（形式参数列表）{ 构造方法体； } 普通方法的语法结构： [修饰符列表] 返回值类型 方法名 （形式参数列表）{ 方法体 } 对于构造方法来说，“返回值类型不需要指定，并且也不能写void, 只要写上void,那么这个方法变成普通方法 构造方法的方法名必须和类名保持一致 构造方法的作用？ -构造方法存在的意义是，通过构造方法的调用，可以创建对象 -初始化实例变量的内存空间 构造方法应该怎么调用？ -普通方法：方法修饰符中有static的时候：类名.方法名（实参列表）、方法修饰符列表中没有static的时候：引用.方法名（实参列表） -new 构造方法名（实参列表） 构造方法调用之后，有返回值吗? 每一个构造方法实际上执行结束后都有返回值，但是这个&quot;return值;&quot;这样的语句不需要写。构造方法结束的时候java程序自动返回值 并且返回值类型是构造方法所在类的类型，由于构造方法的返回值类型就是类本身，所以返回值类型不需要编写 当一个类中没有定义任何构造方法的话，系统默认给该类提供一个无参数的构造方法，这个构造方法被称为缺省构造器 当一个类显示的将构造方法定义出来了，那么系统不再默认为这个类提供缺省构造器。建议手动提供 构造方法支持重载机制。在一个类当中编写多个构造方法，这多个构造方法显然已经构成方法重载机制 1234567891011121314151617181920212223public class ConstructorTest01 &#123; public static void main(String[] args) &#123; User u1 = new User(); User u2 = new User(10); User u3 = new User("zhangsan"); User u4 = new User(10,"zhangsan"); //有static的方法调用,同一个类中类名可要可不要 ConstructorTest01.dosome(); dosome(); //无static的方法调用，需要先创建对象 ConstructorTest01 t = new ConstructorTest01(); t.doOther(); &#125; public static void dosome() &#123; System.out.println("do some!"); &#125; public void doOther() &#123; System.out.println("do other!"); &#125;&#125; 运行结果带有int类型参数的构造器带有String类型的构造器带有int,String类型的构造器do some!do some!do other! 1234567891011121314151617181920public class User &#123; //无参数的构造方法 public User()&#123; System.out.println(); &#125; //有参数的构造方法 public User(int i) &#123; System.out.println("带有int类型参数的构造器"); &#125; public User(String name) &#123; System.out.println("带有String类型的构造器"); &#125; public User(int i,String name) &#123; System.out.println("带有int,String类型的构造器"); &#125; &#125; 运行结果构造函数 P() 被执行!构造函数 B() 被执行!构造函数 C() 被执行! 显然，若要构造出C的对象，必须先构造出其源自超类B的对象部分。同理，要构造出B的对象，则应先构造出A的对象部分。这说明在构造子类时，会自动调用超类的构造函数，调用次序与派生次序相同。 ☁ 空指针引用所谓空指针引用，就是当引用变量未关联任何对象时，却引用其成员。 1234567891011121314151617181920public class Ch_4_7&#123; public static void main(String[] args)&#123; C c=new C(); //c.b=new B();c.b.a=new A(); //System.out.println(c.b.a.x); //此句运行时报错 C c1=new C(); &#125;&#125;class A &#123; public int x; &#125; class B &#123; public A a; &#125;class C &#123; public B b; &#125; ☁ 相等判断对象相等有两层含义：1）两对象实为同一对象，即对象的起始地址相同；2）两对象不是同一对象，但对象的特定属性值对应相等。 1234567891011121314151617/*本例表明：A的equals()与String的equals()功能不同； *前者作用等同于"=="； *后者是判断“字符串字面量的值”是否相同； **/public class Ch_4_8&#123; public static void main (String[] args) &#123; A a=new A(); A b=new A(); System.out.println(a==b); //输出false。因为a、b指向不同的对象 System.out.println(a.equals(b)); //输出false。因为a、b指向不同的对象 String s1=new String("abc"); String s2=new String("abc"); System.out.println(s1==s2); //输出false。因为s1、s2指向不同的对象 System.out.println(s1.equals(s2)); //输出true。因为s1和s2存储的字符串值相同 &#125; &#125;class A&#123;int x=5;&#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot笔记整理（四）]]></title>
    <url>%2F2020%2F03%2F03%2FSpringBoot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot笔记整理（一）SpringBoot笔记整理（二）SpringBoot笔记整理（三）SpringBoot笔记整理（四）1、SpringMVC自动配置以下是SpringBoot对SpringMVC nclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.自动配置了ViewResolver Support for serving static resources, including support for WebJars . registration of Converter, GenericConverter, and Formatter beans. Support for HttpMessageConverters . Automatic registration of MessageCodesResolver . Static index.html support. Custom Favicon support . Automatic use of a ConfigurableWebindingInitializer bean . If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own class of type WebMvcConfigurerAdapter but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping,RequestMappingHandlerAdapter, or ExceptionHandExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components.If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 2、扩展SpringMVC1234567&lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/hello&quot;/&gt; &lt;bean&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 编写一个配置类（@Configuration），是WebMvcConfigurationAdapter类型；不能标注@EnableWebMvc 既保留了所有的自动配置，也能用我们扩展的配置 12345678910//使用WebMvcConfigurer可以来扩展SpringMVC的功能@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; //浏览器发送/athomyit请求来到 success registry.addViewController("/athomyit").setViewName("success"); &#125;&#125; 原理：1）WebMvcAutoConfiguration是SpringMVC的自动配置类。2）在做其他自动配置时会导入：@Import（EnableWebMvcConfiguration.class） 12345678910111213141516@Configuration( proxyBeanMethods = false)public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware &#123; //从容器中获取所有的WebMVCConfigurer @Autowired( required = false)public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123; if (!CollectionUtils.isEmpty(configurers)) &#123; this.configurers.addWebMvcConfigurers(configurers); &#125;&#125; 3）容器中所有的WebMvcConfigurer都会一起起作用 4）我们的配置类也会被调用效果：SpringMVC的自动配置和我们的拓展配置都会起作用 3、全面接管SpringMVCSpringBoot对SpringMVC的自动配置不需要了，所有的都是我们自己配置，所有的SpringMVC的自动配置都失效了 我们需要在配置类中添加@EnableWebMvc即可 123456789101112//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能@EnableWebMvc@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // super.addViewControllers(registry); //浏览器发送 /atguigu 请求来到 success registry.addViewController("/atguigu").setViewName("success"); &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot笔记整理（三）]]></title>
    <url>%2F2020%2F03%2F03%2FSpringBoot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot笔记整理（一）SpringBoot笔记整理（二）SpringBoot笔记整理（三）SpringBoot笔记整理（四）Web开发1、使用SpringBoot：1）创建SpringBoot应用，选中需要的模块2）SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来3）自己编写业务代码 自动配置原理 12xxxAutoConfiguration：帮我们给容器中自动配置组件xxxProperties：配置类来封装配置文件的内容 2、SpringBoot对静态资源的映射规则123456@ConfigurationProperties( prefix = "spring.resources", ignoreUnknownFields = false)public class ResourceProperties &#123; //可以设置和静态资源有关的参数，缓存时间等 12345678910111213141516171819202122232425public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug("Default resource handling disabled"); &#125; else &#123; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern("/webjars/**")) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;"/webjars/**"&#125;).addResourceLocations(new String[]&#123;"classpath:/META-INF/resources/webjars/"&#125;).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125;&#125;//配置欢迎页映射@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext), applicationContext, this.getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(this.getInterceptors(mvcConversionService, mvcResourceUrlProvider)); return welcomePageHandlerMapping;&#125; 1）所有/webjars/**，都去classpath:/META-INF/resources//webjars/找资源webjars：以jar包的方式引入静态资源；https://www.webjars.org/ 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 2）“/**”访问当前项目的任何资源（静态资源的文件夹） 12345&quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;,&quot;classpath:/static/&quot;,&quot;classpath:/public/&quot;&quot;/&quot;:当前项目的根路径 3）欢迎页：静态资源文件夹下的所有index.html页面，被”/“映射4）所有的/favicon.ico 都是在静态资源文件下找 3、模板引擎SpringBoot推荐的Thymeleaf：语法更简单，功能更强大3.1 引入Thymeleaf 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 3.2 Thymeleaf使用&amp;语法 12345678910111213@ConfigurationProperties( prefix = "spring.thymeleaf")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = "classpath:/templates/"; public static final String DEFAULT_SUFFIX = ".html"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = "classpath:/templates/"; private String suffix = ".html"; private String mode = "HTML"; //只要把html页面放在classpath:/templates/，thymeleaf就能自动渲染 使用：3.2.1 导入thymeleaf的名称空间 1&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www/thymeleaf.org&quot;&gt; 3.2.2 使用thymeleaf语法 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www/thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;success&lt;/h1&gt; &lt;!--th:text 将div里面的文本内容设置为--&gt; &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;这里显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1）th:text：改变当前元素里面的文本内容 th：任意html属性，来替换原生属性的值2）表达式语法 1234567891011121314151617181920212223242526272829Simple expressions: Variable Expressions: $&#123;...&#125; Selection Variable Expressions: *&#123;...&#125; Message Expressions: #&#123;...&#125; Link URL Expressions: @&#123;...&#125; Fragment Expressions: ~&#123;...&#125;Literals Text literals: 'one text', 'Another one!',... Number literals: 0, 34, 3.0, 12.3,... Boolean literals: true, false Null literal: null Literal tokens: one, sometext, main,...Text operations: String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations: Binary operators: +, -, *, /, % Minus sign (unary operator): -Boolean operations: Binary operators: and, or Boolean negation (unary operator): !, notComparisons and equality: Comparators: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) Equality operators: ==, != (eq, ne) Conditional operators:If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot笔记整理（二）]]></title>
    <url>%2F2020%2F03%2F03%2FSpringBoot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot笔记整理（一）SpringBoot笔记整理（二）SpringBoot笔记整理（三）SpringBoot笔记整理（四）Spring Boot与日志（日志框架、日志配置）1、市面上的日志框架JUL、JCL、Jboss-logging、logback、log4、log4j2、slf4j……| | ||–|–||日志门面 |日志实现||JCL（Jakarta Commons Logging）、SLF4j（Simple Logging Facade for Java）、Jboss-logging| Log4j JUL（java.util.logging）、Log4j2、Logback左边选一个门面（抽象层）、右边选一个实现日志门面：SLF4J；日志实现：LogBack； SpringBoot：底层是Spring框架，Spring框架默认是用JCL；SpringBoot选用 SLF4j和LogBack 2、SLF4j使用2.1 如何在系统中使用SLF4j开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法应该给系统里面导入slf4j的jar 和 LogBack的实现jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info("Hello World"); &#125;&#125; 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架的配置文件 2.2 遗留问题a (slf4j + logback)：Spring （commons-logging）、Hibernate（jboss-logging）、MyBatis……统一日志记录，即使是和别的框架统一使用slf4j进行输出 如何让系统中所有的日志都统一到slf4j：1、将系统中其他日志框架先排除出去；2、用中间包来替换原有的日志框架；3、导入slf4j其他的实现 3、SpringBoot日志关系 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; SpringBoot使用它来做日志功能 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.2.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 总结：1）SpringBoot底层也是使用slf4j+logback的方式进行日志记录2）SpringBoot也把其他的日志都替换成了slf4j3）中间替换包4）如果我们要引入其他框架，一定要把这个框架的默认日志依赖移除掉Spring框架用的是commons-logging；SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架的日志框架排除掉 4、日志使用4.1 默认配置SpringBoot默认帮我们配置好了日志 1234567891011121314151617 //记录器 Logger logger = LoggerFactory.getLogger(getClass()); @Test void contextLoads() &#123;// System.out.println(); //日志的级别：由低到高 trace&lt;debug&lt;info&lt;warn&lt;error //可以调整输出的日志级别：日志就只会在这个级别及以后的高级别生效 logger.trace("这是trace日志"); logger.debug("这是debug日志"); //SpringBoot默认使用的是info级别的,没有指定级别的就用SpringBoot默认规定的级别 root级别 logger.info("这是info日志"); logger.warn("这是warn日志"); logger.error("这是error日志"); &#125; 123456789日志输出格式“ %d：表示日期时间 %thread：表示线程名 %-5level：级别从左显示5个字符宽度 %logger&#123;50&#125;：表示logger名字最长50个字符，否则按照句号分割 %msg：日志消息 %n：换行符 %d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置 123456789101112131415logging.level.com.homyit = trace#不指定路径在当前项目下生成springboot.log日志#可以指定完整的路径#logging.file = D:/springboot.log#logging.file = springboot.log#在当前磁盘的根路径下创建spring文件夹和里面的log文件夹：使用spring.log作为默认文件#logging.path = /spring/log#在控制台输出的日志格式logging.pattern.console = %d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#指定问价中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; ===[%thread]=== %-5level=== %logger&#123;50&#125; -==== %msg%n 4.2 指定配置给类路径下放上每个日志框架自己的配置文件即可，SpringBoot就不使用默认配置了logback.xml：直接就被日志框架识别了；logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能 123456789101112&lt;springProfile name=&quot;staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt; 可以指定某段配置只在某个环境下生效&lt;/springProfile&gt;&lt;springProfile name=&quot;dev | staging&quot;&gt; &lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;&lt;/springProfile&gt;&lt;springProfile name=&quot;!production&quot;&gt; &lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;&lt;/springProfile&gt; 否则会报错 4.3 切换日志]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot笔记整理（一）]]></title>
    <url>%2F2020%2F03%2F03%2FSpringBoot%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SpringBoot笔记整理（一）SpringBoot笔记整理（二）SpringBoot笔记整理（三）SpringBoot笔记整理（四）1、使用Spring Initializer快速创建Springboot项目默认生成的Spring Boot项目； 主程序已经生成了，我们只需要我们自己的逻辑 resources文件夹中目录结构static：保存所有的静态资源；js css images;templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；application.properties：Spring Boot应用的配置文件； 2、配置文件SpringBoot使用一个全局的配置文件，配置文件名是固定的； application.properties application.yml 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language)YAML A Markup Language：是一个标记语言YAML isn’t Markup Language：不是一个标记语言标记语言：以前的配置文件；大多数都使用的是xxxx.xml文件；YAML：以数据为中心，比json、xml等更适合做配置文件YAML：配置例子 12server: port:8080 XML： 123&lt;server&gt; &lt;port&gt;8080&lt;/port&gt;&lt;/server&gt; 3、YAML语法 基本语法 K:(空格)V：表示一对键值对（空格必须有）；以空格的缩进来控制层级关系；只要是左对齐的一列数据都是同一个层级的 123server: port:8080 path:/hello 属性和值也是大小写敏感 值的写法 字面量：普通的值（数字、字符串、布尔）k:v：字面直接来写 字符串默认不用加上单引号或者双引号；&quot;&quot;：双引号：不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思name：”zhangsan \n lisi”：输出=》zhangsan 换行 lisi&#39;&#39;：单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串数据name：’zhangsan \n lisi’：输出=》zhangsan \n lisi对象、Map（属性和值）（键值对）：k:v：在下一行来写对象的属性和值的关系，注意缩进对象还是k:v的方式 123friends: lastName：zhangsan age：20 行内写法： 1friends:&#123;lastName:zhangsan, age:18&#125; 数组（List、Set）： 用-值表示数组中的一个元素 1234pets： - cat - dog - pig 行内写法 1pets:[cat,dog,pig] 4、配置文件值注入配置文件 123456789101112person: lastName: zhangsan age: 18 boss: false birth: 2019/11/25 maps: &#123;k1: v1,k2: v2&#125; lists: - list - zhaoliu dog: name: 小狗 age: 12 javaBean: 123456789101112@Component@ConfigurationProperties(prefix = "person")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 4.1 @ConfigurationProperties获取值和@Value比较 什么是SpEL？Spring 表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。 语法类似于 EL表达式：SpEL 使用 #{…}作为定界符，所有在大框号中的字符都将被认为是 SpEL。SpEL 为 bean 的属性进行动态赋值提供了便利 通过 SpEL 可以实现：通过 bean 的 id 对 bean 进行引用 调用方法以及引用对象中的属性计算表达式的值正则表达式的匹配 什么是JSR303?JSR-303 是 JAVA EE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是Hibernate Validator。此实现与 Hibernate ORM 没有任何关系。 JSR 303 用于对 Java Bean 中的字段的值进行验证。Spring MVC 3.x 之中也大力支持 JSR-303，可以在控制器中对表单提交的数据方便地验证。注:可以使用注解的方式进行验证| | | ||–|–|–| ||@ConfigurationProperties |@Value||功能 |批量注入配置文件中的属性| 一个个指定||松散绑定（松散语法）| 支持 |不支持||SpEL |不支|持 支持||JSR303数据校验| 支持| 不支持||复杂类型封装 |支持 |不支持|无论是配置文件yml还是properties他们都能获取到值如果说，我们只是在某个业务逻辑中需要获取一下配置文件的某项值，使用@Value如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties 4.2 配置文件注入值数据校验 12345678910111213141516@Component@ConfigurationProperties(prefix = "person")@Validatedpublic class Person &#123;// @Value("$&#123;person.last-name&#125;") @Email private String lastName;// @Value("#&#123;11*2&#125;") private Integer age;// @Value("true") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 4.3 @PropertySource&amp;@ImportResource@PropertySource:加载指定的配置文件 12345678910111213141516171819@PropertySource(value = &#123;"classpath:person.properties"&#125;)@Component@ConfigurationProperties(prefix = "person")//@Validatedpublic class Person &#123; /** * &lt;bean class = "Person"&gt; * &lt;property name = "lastName" value = "字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt; * &lt;/bean&gt; */// @Value("$&#123;person.last-name&#125;")// @Email private String lastName;// @Value("#&#123;11*2&#125;") private Integer age;// @Value("true") private Boolean boss; @ImportResource:导入Spring的配置文件，让配置文件里面的内容生效spring boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别想让spring的配置文件生效，加载进来，@ImportResource标注在一个配置类上 12@ImportResource(locations = &#123;"classpath:beans.xml"&#125;)导入Spring的配置文件让其生效 不来编写Spring的配置文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloService&quot; class=&quot;com.homyit.springboot.service.HelloService&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot推荐给容器中添加组件的方式：推荐使用全注解的方式1、配置类========Spring配置文件2、使用@Bean给容器添加组件 1234567891011@Configurationpublic class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService()&#123; System.out.println("配置类@Bean给容器中添加组件了。。。。"); return new HelloService(); &#125;&#125; 4.4 配置文件占位符1、随机数 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536])&#125; 2、占位符获取之前配置的值，如果没有可以使用：指定默认值 1234567891011person.last-name=张三$&#123;random.uuid&#125;#person.age=18person.age=$&#123;random.int&#125;person.birth=2019/11/25person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,c#person.dog.name=dogperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 4.5 Profile1、多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml默认使用application.properties的配置 2、yml支持多文档块方式 123456789101112131415161718server: port: 8080spring: profiles: active: dev---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod 3、激活指定profile3.1 在配置文件中指定 1spring.profiles.active = dev 3.2 命令行 1--spring.profile.active = dev 可以直接在测试的时候，配置传入命令行参数3.3 虚拟机参数 1-Dspring.profile.active = dev 4.6、配置文件加载位置 spring boot 启动会扫描以下位置的application.properties或者application.ym文件作为Spring Boot 的默认配置文件 file: ./config/ file: ./ classpath: /以上是按照优先级从高到低的顺序，所有位置的文件都会被加载，高优先级配置内容会覆盖低优先级配置内容。互补配置 我们也可以通过配置spring.config.location来改变默认的配置文件位置。 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置。]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows系统、Linux系统 和 Mac OS操作系统 历史由来 与 区别？]]></title>
    <url>%2F2020%2F03%2F02%2F(%E8%BD%AC)Windows%E7%B3%BB%E7%BB%9F%E3%80%81Linux%E7%B3%BB%E7%BB%9F%20%E5%92%8C%20Mac%20OS%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20%E5%8E%86%E5%8F%B2%E7%94%B1%E6%9D%A5%20%E4%B8%8E%20%E5%8C%BA%E5%88%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[目录 1 UNIX 由来 2 Linux 由来 3 Windows与Linux的主要区别 4 关于Linux的一些疑惑 参考资料 目前常见的三大操作系统：Windows系统、Linux系统 和 Mac OS操作系统。 首先，不管是Windows操作系统、Linux系统还是苹果的Mac OS操作系统，甚至包括操作系统的鼻祖UNIX操作系统，最早都是用C语言编写的。 UNIX 诞生于 20 世纪 60 年代末，Windows 诞生于 20 世纪 80 年代中期，Linux 诞生于 20 世纪 90 年代初，Mac OS诞生的时间和Linux时间差不多。可以说 UNIX 是操作系统中的"老大哥"，后来的 Windows , Linux 和Mac OS都参考了 UNIX。 &nbsp; 1 UNIX 由来 实际上UNIX操作系统和C语言都是由贝尔实验室的汤普森(Ken Thompson)和丹尼斯·里奇(Dennis M. Ritchie)于1971年先后改造发明的，如果说真正的操作系统，世界上只有一个，那就是UNIX操作系统。 下图是肯•汤普森 与 丹尼斯•里奇的合影，膜拜一下。(这么多胡子，天才都是不修边幅的，大神就是这么随意) UNIX的部分技术来源可追溯到从 1965 年开始的 Multics 工程计划，该计划由贝尔实验室、美国麻省理工学院和通用电气公司联合发起，目标是开发一种交互式的、具有多道程序处理能力的分时操作系统，以取代当时广泛使用的批处理操作系统。 可惜，由于 Multics 工程计划所追求的目标太庞大、太复杂，以至于它的开发人员都不知道要做成什么样子，最终以失败收场。 以肯•汤普森为首的贝尔实验室研究人员吸取了 Multics 工程计划失败的经验教训，于 1969 年实现了一种分时操作系统的雏形，1970 年该系统正式取名为 UNIX。 想一下英文中的前缀 Multi 和 Uni，就明白了 UNIX 的隐意。Multi 是大的意思，大而且繁；而 Uni 是小的意思，小而且巧。这是 UNIX 开发者的设计初衷，这个理念一直影响至今。 有意思的是，肯•汤普森当年开发 UNIX 的初衷是运行他编写的一款计算机游戏 Space Travel，这款游戏模拟太阳系天体运动，由玩家驾驶飞船，观赏景色并尝试在各种行星和月亮上登陆。他先后在多个系统上试验，但运行效果不甚理想，于是决定自己开发操作系统，就这样，UNIX 诞生了。自 1970 年后，UNIX 系统在贝尔实验室内部的程序员之间逐渐流行起来。1971-1972 年，肯•汤普森的同事丹尼斯•里奇发明了传说中的C语言，这是一种适合编写系统软件的高级语言，它的诞生是 UNIX 系统发展过程中的一个重要里程碑，它宣告了在操作系统的开发中，汇编语言不再是主宰。到了 1973 年，UNIX 系统的绝大部分源代码都用C语言进行了重写，这为提高 UNIX 系统的可移植性打下了基础（之前操作系统多采用汇编语言，对硬件依赖性强），也为提高系统软件的开发效率创造了条件。可以说，UNIX 系统与C语言是一对孪生兄弟，具有密不可分的关系。 20 世纪 70 年代初，计算机界还有一项伟大的发明——TCP/IP 协议，这是当年美国国防部接手 ARPAnet 后所开发的网络协议。美国国防部把 TCP/IP 协议与 UNIX 系统、C语言捆绑在一起，由 AT&amp;T 发行给美国各个大学非商业的许可证，这为 UNIX 系统、C语言、TCP/IP 协议的发展拉开了序幕，它们分别在操作系统、编程语言、网络协议这三个领域影响至今。肯•汤普森和丹尼斯•里奇因在计算机领域做出的杰出贡献，于 1983 年获得了计算机科学的最高奖——图灵奖 (实至名归)。 &nbsp; 下图是从UNIX衍生出来，目前常见的三大操作系统：Windows系统、Linux系统和Mac OS操作系统。 &nbsp; 首先这三个系统设计上有本质的区别。最大的区别在于Windows是一个成熟的商业操作系统，拿过来就能用，而Linux不同，它是指一个内核，苹果操作系统是UNIX的一个衍生品。 &nbsp; &nbsp; 操作系统 &nbsp; &nbsp; &nbsp; 形态 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;说明 &nbsp; Windows &nbsp; &nbsp;商业产品 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 微软公司1983年开始推出的一套商业操作系统。 &nbsp; &nbsp; &nbsp;Linux &nbsp; &nbsp;一个内核 &nbsp; &nbsp;芬兰的李纳斯·托沃兹( Linus Torvalds) 1991 年上大学时发布的, 他对当时流行的教学系统Minix (Unix的一个版本)的很多特点很不满意, 于是决定自己写一个合乎自己要求的操作系统, 并把这个内核放到了Internet 上, 供大家修改。后来经过众多世界顶尖的软件工程师的不断修改和完善。 &nbsp; Mac OS &nbsp; &nbsp; 专属系统 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 苹果公司基于FreeBSD操作系统的改造。 通过上表可以看出，其实Windows和Linux在哲学设计上是有本质区别的。Windows操作系统倾向于将更多的功能集成到操作系统内部，并将程序与内核相结合；而Linux不同于Windows，它的内核空间与用户空间有明显的界限。根据设计架构的不同，两者都可以使操作系统更加安全。而苹果操作系统只不过是UNIX的一个细小分支而已。 Linux 只是指操作系统的核心, 并没有各种应用程序, 如网络工具、多媒体软件等。因此现在市场上有很多种Linux Kernel 为核心再集成搭配各式各样的系统程序或应用工具程序组成的一套完整的操作系统。 Linux是可以任意包装自由配置的东西。任何一个人，一家公司 都可以按照自己的想法，比如加一点功能，加中文支持，作一个Linux出来。这些 Linux虽然核心部分都一样，但是他们所带的各种软件，缺省的配置都不一样。 &nbsp; Linux 分为 内核版本 和 发行版本。 Linux 内核版本就是Linux的核心版本 由官网 www.kernel.org 发布，如下图所示： &nbsp; Linux 发行版本就是各个公司的在Linux核心版本上就行包装，添加想要的内容，这就衍生出非常多的发行版本，如下图所示。譬如的redhat, CentOS, 红旗、Ubuntu等，这些都是的Linux衍生操作系统。 话说回来关于个人办公要使用什么操作系统、个人做图要用什么样的操作系统、建设网站的服务器要用什么系统，其实在行业中都有大体的规则。譬如个人PC娱乐还是Windows系统比较合适、专业做图像让是MAC系统了，建设网站大家服务器建议你还是Linux了！下面简单介绍Linux 由来，毕竟是开源的。 &nbsp; 2 Linux 由来 Linux 内核最初是由 李纳斯•托瓦兹 (Linus Torvalds) 在赫尔辛基大学读书时出于个人爱好而编写的，当时他觉得教学用的迷你版 UNIX 操作系统 Minix 太难用了，于是决定自己开发一个操作系统。第 1 版本于 1991 年 9 月发布，当时仅有 10 000 行代码。下图是李纳斯•托瓦兹（Linus Torvalds）图片，膜拜一下大神。 李纳斯•托瓦兹 (Linus Torvalds) 没有保留 Linux 源代码的版权，公开了代码，并邀请他人一起完善 Linux。与 Windows 及其他有专利权的操作系统不同，Linux 开放源代码，任何人都可以免费使用它。 据估计，现在只有 2% 的 Linux 核心代码是由李纳斯•托瓦兹自己编写的，虽然他仍然拥有 Linux 内核（操作系统的核心部分），并且保留了选择新代码和需要合并的新方法的最终裁定权。现在大家所使用的 Linux，我更倾向于说是由李纳斯•托瓦兹 (Linus Torvalds)和后来陆续加入的众多 Linux 好者共同开发完成的。 李纳斯•托瓦兹 (Linus Torvalds)无疑是这个世界上最伟大的程序员之一，何况，他还搞出了全世界最大的程序员交友社区 GitHub (开源代码库及版本控制系统）。 关于 Linux Logo 的由来是一个很有意思的话题，它是一只企鹅，如下图所示，为什么选择企鹅，而不是选择狮子、老虎或者小白兔？ 当然有很多种说法，其中有一种说法：企鹅是南极洲的标志性动物，根据国际公约，南极洲为全人类共同所有，不属于世界上的任何国家，可国家都无权将南极洲纳入其版图。Linux 选择企鹅图案作为 Logo，其含义是：开放源代码的 Linux 为全人类共同所有，可公司无权将其私有。当然我比较信服这个说法，有种造福人类的使命感。 &nbsp; 3 Windows与Linux的主要区别 1、免费与收费 Linux都是免费的，Windows是付费的，只有购买Windows系统的电脑，就已经向微软付费了。 &nbsp; 2、软件与支持 Windows下可以运行绝大部分软件、玩99.999％的游戏、硬件厂商近乎100%的支持。Linux下可直接运行的软件数量和Win下比起来就是1和99的区别，而且目前选择Linux的人基本不会考虑玩游戏（虽然有能在Linux下运行的游戏，但实在太少。），同时Linux正期待更多硬件厂商的支持。 &nbsp; 3、安全性 很多人说Linux安全性高，仁者见仁智者见智了。其实我觉得这个根本没必要讨论，当Linux普及程度达到现在Windows的程度，那么Linux的漏洞、病毒、木马、后门什么的绝对会如雨后春笋般纷纷冒出，虽不敢说比Windows严重，但绝对不会比win少，说白了就是因为现在Linux的用户量太少，受关注也太少，做病毒者当然希望自己的作品流传越广越好（现在的病毒更倾向于获取非法利益，比如账号密码什么的），所以，病毒目前不会考虑少数派的Linuxer。 世上没有攻不破的系统、没有穿不透的防火墙，一件事你做不到，只能说明你水平不够，这里适用一句话：道高一尺，魔高一丈。 但就目前来说，如果你对Windows下层出不穷的病毒、木马、垃圾感到极度厌恶，那的确可以尝试一下Linux。 &nbsp; 4、开源 开源就是指对外部开放软件源代码。 如果一个小程序员写了个软件，里面有他独创的新技术，他想靠这个赚钱，甚至还为此申请了专利，这时某些团体以安全为由，要求他公开源代码（这样就可以仿制了嘛。），并且最好免费给大家使用，身边一群眼红程序员赚钱的人也在跟着起哄。一个独立商业团体的合法知识产权、资产权益遭受政治强权的公开侵占、迫害，这就是微软在欧洲所面临的开源问题（至于微软是否是奸商，这是另一码事，并不能成为打砸抢、吃大户的理由） 开源与否，软件厂商有选择的权力；是否购买使用这个产品，这才是用户的权利。 其实想深一点，如果Linux不开源，它还能有现在这个市场吗？因为很多人就是冲着开源才使用Linux的。 &nbsp; 5、使用习惯 一样的地方：桌面、图标、鼠标点击，有区别吗？不一样的是，Windows放弃了dos的字符模式，主攻图形界面，让桌面系统更易用。Linux字符模式运行的更好，图形界面还只是附带品，可有可无。根据他们的上市时间来看，只能说Linux把Windows扔掉的东西又捡回来并且发扬光大。 &nbsp; 6、技术支持 如果你不熟悉或从来没接触过电脑： 学Windows －－那身边随便一个上过网的人都可以指点你两下。学Linux－－难，需要买书或上网查阅资料。 如果你熟悉电脑和上网，那Windows和Linux其实没什么区别，网上都有海量的资料给你查。但是找修Windows电脑的人远比找一个修Linux电脑的人容易得多. Windows平台:数量和质量的优势，不过大部分为收费软件；由微软官方提供重要支持和服务 Linux平台：大都为开源自由软件，用户可以修改定制和再发布，由于基本免费没有资金支持，部分软件质量和体验欠缺；有全球所有的Linux开发者和自由软件社区提供支持 &nbsp; 4 关于Linux的一些疑惑 作为初学者，就是很难理解Linux有什么好，上手比较难，需要慢慢适应，下面就是之前看到的一些疑惑，记录一下。 1 Windows有完善的图形界面，而Linux为什么要学命令行。 首先，命令行绝对要比图形界面先进的多。命令行是程序员的第一界面，而图形界面是普通用户的第一界面。也许很多人会有不同意见，其实我们再向前想一步，就很清楚了。 命令行的下一步演化是什么? 很简单就是语音控制，就是把人类自然语言转化为命令 图形界面的下一步演化是什么? 是姿势控制。从目前的Windows系统来说一共只有3种姿势， 单击，双击，拖放。而更先进的IPad有拨动，画圈等。 姿势控制很简单，便于用户上手，语音控制很复杂，但是控制精度很高。作为程序员我们要求电脑完成的工作要比普通用户复杂的多，所以使用命令行会非常高效。退一步讲，图形界面本质也是命令行，只不过将姿势翻译成命令执行而已。程序员编程的代码也都是“命令行”，一条一条的指令而已。 总之，只要能打破对Linux命令行的恐惧感，接下来的事就会非常容易了。这个命令行绝对不是你简单想像中的命令行，它是非常智能化的。 &nbsp; 2 Linux有那么多目录，那么多命令，怎么记得住呢? 首先，Linux目录是Linux系统最灵魂的东西，所有的硬件都可以被抽象为文件，从而实现网络化。(Internet只不过是Unix/Linux的进一步的演化而已)。所以只要掌握了Linux目录的规律，在理解的基础上记忆就可以容易的多。另外Linux的命令行有智能化功能，可以让你少打95%以上的字符来完成命令。 绝非你所想象的傻乎乎的敲一大堆命令，那些用Linux大牛都是绝顶聪明的人，怎么可能让自己辛苦呢? &nbsp; 3 Windows有注册表，为什么Linux没有注册表？ 注册表是Windows核心组件，对整个系统进行配置。Linux是以整个文件系统作为"注册表“，Windows注册表的树形结构，可以粗略的对应Linux文件系统的树形结构。 Linux的配置文件就相当于注册表的键，或者说Linux采用是的分布式的注册表。 那么Linux为什么要这样设计呢?因为Linux是所谓的网络操作系统，所以单台电脑不是Linux的界限，如果是多台电脑组成的系统，那么分布式的管理就有着巨大的优势。例如：一个包含配置文件的磁盘的损害不会让整个系统瘫痪，而可能只是让部分功能失效。 &nbsp; &nbsp; 关于 Linux初学资料，可下载： 鸟哥的Linux私房菜 和&nbsp;&nbsp;Unix-Linux编程实践教程&nbsp;pdf文件(带书签)。 &nbsp; &nbsp; 参考资料 [1] https://www.gonet.com.cn/index.php?webduirshow-166 [2] https://www.Linuxprobe.com/Windows-Linux-distinction.html [3] https://www.cnblogs.com/supermeimei/p/5133610.html [4] http://cn.linux.vbird.org/linux_basic/0110whatislinux.php [5] http://c.biancheng.net/view/707.html &nbsp;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下生成指定大小文件（命令+Java程序）]]></title>
    <url>%2F2020%2F03%2F01%2FLinux%E4%B8%8B%E7%94%9F%E6%88%90%E6%8C%87%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%96%87%E4%BB%B6%EF%BC%88%E5%91%BD%E4%BB%A4%2BJava%E7%A8%8B%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1、dd命令of：fileName为文件名称，例如test.txt ；bs：设置一次复制的大小，例如1M；count：设置复制次数，例如100；1dd if=/dev/zero of=&lt;fileName&gt; bs=&lt;一次复制的大小&gt; count=&lt;复制的次数&gt;例如：1dd if=/dev/zero of=1.txt bs=1M count=100 2、Java快速生成两种方式都可以生成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.jxnu.test;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;/** * @program: CreateFile * @author: xiaojing * @create: 2020-03-01-09-46 */public class Test &#123; public static void main(String[] args) throws IOException &#123; File file = new File("test.txt"); long length = 1024*1024*15; //createFixLengthFile(file, length); createFile(file, length); &#125; /** * 第一种方法 * @param file * @param length * @throws IOException */ public static void createFixLengthFile(File file, long length) throws IOException &#123; FileOutputStream fos = null; FileChannel output = null; try &#123; fos = new FileOutputStream(file); output = fos.getChannel(); output.write(ByteBuffer.allocate(1), length - 1); &#125; finally &#123; try &#123; if (output != null) &#123; output.close(); &#125; if (fos != null) &#123; fos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * * 第二种方法 * @param file * @param length * @throws IOException */ private static void createFile(File file, long length) throws IOException &#123; RandomAccessFile r = null; try &#123; r = new RandomAccessFile(file, "rw"); r.setLength(length); &#125; finally &#123; if (r != null) &#123; r.close(); &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket实现客户端服务端之间的通信]]></title>
    <url>%2F2020%2F02%2F28%2FJava%20Socket%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[Java Socket Java Socket编程用于在不同JRE上运行的应用程序之间的通信。 Java Socket编程可以是面向连接的或无连接的。 Socket和ServerSocket类用于面向连接的套接字编程，DatagramSocket和DatagramPacket类用于无连接套接字编程。 此Demo将进行单向客户端和服务器通信。客户端将消息发送到服务器，服务器读取消息并打印。在这里，使用了两个类：Socket和ServerSocket。Socket类用于通信客户端和服务器。通过此类，我们可以读写消息。ServerSocket类在服务器端使用。ServerSocket类的accept（）方法将阻止控制台，直到客户端连接为止。客户端成功连接后，它将在服务器端返回Socket的实例。 Socket class套接字只是机器之间通信的端点。Socket类可用于创建套接字。 重要方法| 方法 |描述 ||–|–|| 1）public InputStream getInputStream() | 返回与此socket连接的InputStream。|| 2）public OutputStream getOutputStream() |返回与此socket连接的OutputStream。||3）public synchronized void close()|关闭这个socket ServerSocket classServerSocket类可用于创建服务器套接字。该对象用于与客户端建立通信。 重要方法|方法|描述 ||–|–|| 1) public Socket accept() | 返回socket，并在服务器和客户端之间建立连接。 ||2) public synchronized void close() |关闭服务器socket| 具体实现 MyServer.java 1234567891011121314import java.io.*; import java.net.*; public class MyServer &#123; public static void main(String[] args)&#123; try&#123; ServerSocket ss=new ServerSocket(6666); Socket s=ss.accept();//建立连接 DataInputStream dis=new DataInputStream(s.getInputStream()); String str=(String)dis.readUTF(); System.out.println("message= "+str); ss.close(); &#125;catch(Exception e)&#123;System.out.println(e);&#125; &#125; &#125; MyClient.java 1234567891011121314import java.io.*; import java.net.*; public class MyClient &#123; public static void main(String[] args) &#123; try&#123; Socket s=new Socket("localhost",6666); DataOutputStream dout=new DataOutputStream(s.getOutputStream()); dout.writeUTF("Hello Server"); dout.flush(); dout.close(); s.close(); &#125;catch(Exception e)&#123;System.out.println(e);&#125; &#125; &#125;]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下Java连接数据库出现 Access denied for user 'root'@'localhost'错误]]></title>
    <url>%2F2020%2F02%2F28%2FLinux%E4%B8%8BJava%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E5%87%BA%E7%8E%B0%20Access%20denied%20for%20user%20'root'%40'localhost'%20(using%20password_%20YES)%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[一、问题描述centos 7 终端键入 mysql -u root -p 输入密码后可成功访问数据库，但使用IDEA编写Java代码实现数据库连接时却出现Access denied for user ‘root’@’localhost’ (using password: YES) 错误。二、解决方法 在刚安装mysql时，系统会默认提供4种host下得root用户，如下图所示：user中有多条root记录时，mysql会优先判断是否使用了绑定的ip，所以将localhost设置成对应的Ip 就可以。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware下主机与虚拟机剪切板独立，无法直接复制粘贴]]></title>
    <url>%2F2020%2F02%2F27%2FVMware%E4%B8%8B%E4%B8%BB%E6%9C%BA%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%89%AA%E5%88%87%E6%9D%BF%E7%8B%AC%E7%AB%8B%EF%BC%8C%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%2F</url>
    <content type="text"><![CDATA[看了很多博客都说需要重新安装vmware tools，但我使用的是这种方法，亲测有效！！！ 关闭虚拟机 点击编辑虚拟机设置-&gt;选项 选择客户机隔离，勾选上启动复制粘贴即可（如果之前就已经勾选上但失效的情况再重新勾选一次即可）]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.7安装MySQL5.6并配置环境变量（详细版）]]></title>
    <url>%2F2020%2F02%2F27%2FCentOS7.7%E5%AE%89%E8%A3%85MySQL5.6%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[i. tar包下载 官网下载 https://dev.mysql.com/downloads/mysql/ 网盘获取链接：https://pan.baidu.com/s/1DpULc0qQ4hqx6HWUwRilpw提取码：tgdv ii. 安装所需环境1yum -y install make gcc-c++ cmake bison-devel ncurses-devel iii. 解压tar包，进入mysql-5.6.47文件夹后编译安装 123456tar xvf mysql-5.6.47.tar.gz #解压tar包cd mysql-5.6.47 #进入解压后的mysql-5.6.47文件夹#编译cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci make &amp;&amp; make install iv. 设置权限，执行初始化脚本。 12345678910#检查系统是否已经有mysql用户，如果没有则创建cat /etc/passwd | grep mysql cat /etc/group | grep mysqlchown -R mysql:mysql /usr/local/mysql # 修改/usr/local/mysql权限cd /usr/local/mysql # 切换目录chown -R mysql:mysql . # 将权限赋予给mysqlscripts/mysql_install_db --user=mysql # 执行初始化脚本chown -R root:mysql . #将权限设置给root用户chown -R mysql:mysql ./data #数据库存放目录设置成mysql用户mysql组chmod -R ug+rwx . #赋予读写执行权限，仅给mysql用户权限 v. 修改my.cnf配置 123456789101112131415#将mysql的配置文件拷贝到/etccp support-files/my-default.cnf /etc/my.cnf #修改my.cnf配置，添加以下内容 [mysql]default-character-set=utf8 # 设置mysql客户端默认字符集[mysqld]skip-name-resolveport = 3306 #设置3306端口basedir=/usr/local/mysql # 设置mysql的安装目录datadir=/usr/local/mysql/data # 设置mysql数据库的数据的存放目录max_connections=200 # 允许最大连接数character-set-server=utf8 # 设置默认字符集default-storage-engine=INNODB # 创建新表时将使用的默认存储引擎lower_case_table_names=1max_allowed_packet=16M vi. 启停mysql 12345# 将mysql的启动服务添加到系统服务中cp support-files/mysql.server /etc/init.d/mysql service mysql start #启动服务service mysql stop #停止服务service mysql restart #重启服务 vii. 修改root用户密码 12chkconfig --add mysql./bin/mysqladmin -u root password viii. 设置mysql环境变量 1234vim /etv/profile #修改文件# 添加以下内容，重启操作系统即可export MYSQL_HOME=/usr/local/mysqlexport PATH=$MYSQL_HOME/bin:$PATH 现在通过mysql -u root -p可以操作数据库啦！]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 /etc/profile 添加环境变量重开终端后不生效]]></title>
    <url>%2F2020%2F02%2F26%2FCentOS7%20_etc_profile%20%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%87%8D%E5%BC%80%E7%BB%88%E7%AB%AF%E5%90%8E%E4%B8%8D%E7%94%9F%E6%95%88%2F</url>
    <content type="text"><![CDATA[排查步骤如下： 查看/etc/profile里面的环境变量是否填写正确。 需要重启操作系统（很重要！！！） 将环境变量写入/etc/bashrc文件]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算与分布式系统课程学习笔记（二）——Linux基本命令的使用与熟悉]]></title>
    <url>%2F2020%2F02%2F22%2F%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E7%86%9F%E6%82%89%2F</url>
    <content type="text"><![CDATA[（1） jps 【显示当前系统的java进程情况，及其id号】| | ||–|–||-q | 只显示pid，不显示class名称,jar文件名和传递给main方法的参数||-m | 输出传递给main方法的参数||-l | 输出主类的完整包名或者jar文件完整路径名||-v | 输出传递给JVM的参数| 编写一个JSPDemo.java程序进行测试：（2） awk 【把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理】【使用方法】awk &#39;BEGIN{ commands } pattern{ commands } END{ commands }&#39;内置变量| | ||–|–||$0 | 整条记录|| $1~ $n|当前记录的第n个字段||FS | 输入域分隔符 默认是空格或Tab||NF |浏览记录中的域个数，就是有多少列||NR| 已经读出的记录数，就是行号||FNR |浏览文件的记录数||RS |输入记录分隔符， 默认为换行符||OFS |输出域分隔符， 默认为空格||ORS |输出记录分隔符，默认为换行符||FILENAME| 当前输入文件的名字|（3） cat【一次显示整个文件；从键盘创建一个文件；将几个文件合并为一个文件】 【使用方法】 $ cat filename；$ cat &gt; filename; $cat file1 file2 &gt; file -n 或 –number 由 1 开始对所有输出的行数编号 -b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云计算与分布式系统课程学习笔记（一）——云计算简介]]></title>
    <url>%2F2020%2F02%2F20%2F%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E4%BA%91%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[大数据对于系统架构的需求显式的需求 海量计算和存储 快速计算 隐式的需求 数据的快速传输 灵活性 低成本 如何实现这些需求？ 并行化（并行化的理念存在于计算机方方面面） 并行请求（分配给多个计算机） 并行线程（分配给多个处理器核心） 并行指令（同一时刻有多于一条指令） 并行数据（同一时刻有多于1个数据项 ） 硬件描述（同一时刻使用所有门电路） 规模经济（极端规模的并行化：仓库规模的计算机 WSC） 主要部件 —— 供电、制冷、建筑、网络、安全、存储、计算 优势 —— 规模经济、提高使用率 挑战 —— 能耗PUE、运维 WSC是用网络连接起来的计算和存储设备WSC的特点：1、使用相对同质的硬件和系统软件平台2、共享相同的系统管理3、大多数应用程序、中间件、系统软件都是自主开发，而传统数据中心则由第三方软件主导4、WSC运行相对小数目的超大型程序（或服务）5、通用的资源管理架构增强了部署的灵活性 虚拟化（抽象） 云计算的商业模式概述 —— 云计算的定义云计算 Cloud computing 既指作为服务通过互联网提供的应用程序（SaaS模式），又指提供这些服务的，位于数据中心的硬件和系统软件（公用计算）云：数据中心硬件与软件公有云：用即付即用的模式，开放给大众使用的云私有云：一个企业或组织内部的数据中心公用计算：给人以无限资源的错觉 —— 云计算商业模式的三大特点 按需服务 资源池 可测量的服务 —— 云计算发展的市场条件 大规模互联网应用（社交网络、多媒体）1、规模经济2、需求增长促进数据中心建设增长3、无法预测的应用增长速度Zynga，Netflix 大数据应用1、日志分析2、机器学习应用 云计算的价值云计算的分类 指令集虚拟机（Amazon EC2， 3Tera） 运行时系统虚拟机（Microsoft Azure） 框架型虚拟机（Goole AppEngine，Force.com） 折衷：灵活性/可移植性 为什么要虚拟化 资源池 聚合：将多个资源结合起来 合一：例如存储 动态：快速分配（虚拟机） 隔离：保护消费者隔离其他租客 ，例如虚拟专用网（VPN）便于管理：测试、机动性 云计算的核心思想 性能：并行化 经济性：规模化、公有云 可管理：虚拟化 从云计算到大数据 虚拟化提供了硬件资源的抽象 用户看到的接口（虚拟）计算节点（虚拟）网络（虚拟）存储 仍然是许多独立的设备：需要分布式系统编程 如何提供一个易于编程的“单一系统”感觉 分布式存储、计算框架]]></content>
      <tags>
        <tag>云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware安装CentOS7超详细版]]></title>
    <url>%2F2020%2F02%2F11%2FVMware%E5%AE%89%E8%A3%85CentOS7%E8%B6%85%E8%AF%A6%E7%BB%86%E7%89%88%2F</url>
    <content type="text"><![CDATA[写在前面云计算与分布式这门课程的老师让我们使用vmware安装好centos7.6并配置好Java编译环境，刚好复习一波，下面是详细的安装过程。准备工作 VMware，我用的是VMware Workstation Pro 15，下载与安装方法就不提了毕竟重点在后头。 CentOS7镜像文件，由于7.6版本已经停更，这里我用的是7.7版本。下载地址 http://isoredirect.centos.org/centos/7/isos/x86_64习惯性选择阿里的镜像，点击下载即可。安装过程 打开vmware，点击创建新的虚拟机选择自定义配置，点击下一步这里直接默认下一步选择稍后安装操作系统，点击下一步客户机操作系统选择Linux，版本选择CentOS 7 64位，点击下一步虚拟机名称可以自定义，这里建议以见名知意为原则，位置尽量放在C盘外的其他盘符，这里我选择的是D盘。处理器数量和每个处理器的内核数可根据自己电脑配置进行选择。这里默认都选择1。同样的，虚拟机内存也依据自己电脑配置进行选择，由于我的电脑是8GB，所以这里我选2GB。网络连接选择NAT后两项默认推荐，点击下一步。)点击创建新虚拟磁盘最大磁盘大小按需分配，我给了20GB，选择将虚拟磁盘拆分成多个文件。默认点击下一步可以看到CentOS7已经添加进去了右键CentOS7,点击设置进入设置页面，点击CD/DVD,使用ISO映像文件，选择之前下载的文件即可。 开启虚拟机，见到如下页面，选择Install CentOS Linux 7,直接Enter滑动右侧滚动条选择中文=》简体中文，英文好的同学当然可以选择英文这里配置一些基本信息1、点击安装源，进入之后直接选择done，警告符号随即消失。2、软件选择：GNOME桌面，一个友好的图形化界面3、根据需要禁用Kdump4、自动分区，一般化为4个分区，如图所示 ))完成后点击开始安装安装过程中会弹出用户设置界面，填好并记住密码。)安装完成后点击重启，看到如下界面点击接受许可设置一下网络 点击完成配置现在可以使用之前创建的用户进行登录了登录成功后可看到图形化界面上网 开启windows下的VMnet8cmd窗口ping出主机ip地址打开有线设置网络=》开启，点击设置图标选择自动连接)打开终端，使用ifconfig命令获取ip地址在终端ping下windows 中VMnet8的IP地址，若出现下图所示信息，则表示linux的ip地址设置成功。此时，若windows能上网，则linux也能上网打开火狐浏览器，上网成功！]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络之Web应用]]></title>
    <url>%2F2020%2F02%2F06%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8BWeb%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1、web与HTTPworld Wide Web：网页网页互相链接网页包含多个对象：对象： HTML文件、JPEG图片、视频文件、动态脚本等基本HTML文件： 包含对其他对象引用的链接对象的寻址：URL（Uniform Resource Locator）：统一资源定位器Scheme：//host:port/path 2、HTTP协议概述万维网应用遵循超文本协议（HyperText Transfer Protocol）C/S结构客户——Browser：请求、接收、展示Web对象服务器——Web Server：响应客户的请求，发送对象HTTP版本1.0：RFC 19451.1：RFC 2068使用TCP传输服务：服务器在80端口等待客户的请求浏览器发起服务器的TCP连接（创建套接字Socket）服务器接受来自浏览器的TCP连接浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息关闭TCP连接 无状态：服务器不维护任何有关客户端过去所发请求的信息有协议的协议更复杂：需维护状态（历史信息）如果客户或服务器失效，会产生状态的不一致，解决这种不一致代价高 HTTP连接的两种类型1、 非持久性连接每个TCP连接最多允许传输一个对象HTTP1.0版本使用非持久性连接问题：1）每个对象需要2个RTT2）操作系统需要为每个TCP连接开销资源 2、 持久性连接每个TCP连接允许传输多个对象HTTP1.1版本默认使用持久性连接发送响应后，服务器保持TCP连接的打开后续的HTTP消息可以通过这个连接发送 HTTP请求消息请求消息：ASCII 人直接可读响应消息 Cookie技术某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密） Cookie的组件HTTP响应消息的cookie头部行HTTP请求消息的cookie头部行保存在客户端主机上的cookie文件，由浏览器管理Web服务器端的后台数据库原理作用：身份认证、购物车、推荐等 Web缓存/代理服务功能：在不访问服务器的前提下满足客户端的HTTP请求Web缓存/代理服务器：1、用户设定浏览器通过缓存进行Web访问浏览器向缓存/代理服务器发送所有的HTTP请求如果所请求对象在缓存中，缓存返回对象否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后反水给客户端并保存该对象2、缓存既充当客户端，也充当服务器3、一般由ISP（Internet服务提供商）架设条件性Get方法目标：如果缓存有最新的版本，则不需要发送请求对象缓存：在HTTP请求消息中声明所持有版本的日期服务器：如果缓存的版本是最新的，则响应消息中不包含对象]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成Spring Security（二）注册 、密码加密、修改密码]]></title>
    <url>%2F2020%2F02%2F06%2FSpringBoot%E9%9B%86%E6%88%90Spring%20Security%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B3%A8%E5%86%8C%20%E3%80%81%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86%E3%80%81%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[SpringBoot集成Spring Security（一）登录注销写在前面上一节创建了项目并且利用Spring Security完成了登录注销功能，这里继续说一下注册、密码加密和找回密码，代码注释较清晰。一、web层控制StudentController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.jxnu.os.controller;import com.jxnu.os.model.RespBean;import com.jxnu.os.model.Student;import com.jxnu.os.service.StudentService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.List;/** * @author xiao */@RestController@RequestMapping("/student")public class StudentController &#123; @Autowired StudentService studentService; /** * 注册 * @param student * @return */ @PostMapping("/register") public RespBean register(Student student) &#123; if(studentService.register(student))&#123; return RespBean.ok("注册成功",student); &#125;else&#123; return RespBean.error("注册失败，用户名已存在"); &#125; &#125; /** * 修改密码 * @param sno * @param password * @param rePassword * @return */ @PutMapping("/modifyPass") public RespBean modifyPass(String sno,String password,String rePassword) &#123; if(studentService.modifyPass(sno,password,rePassword))&#123; return RespBean.ok("修改成功"); &#125;else&#123; return RespBean.error("修改失败,原密码错误"); &#125; &#125;&#125; 二、service层注册时对密码进行加密，修改密码时则需先解密后验证StudentService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.jxnu.os.service;import com.jxnu.os.mapper.StudentMapper;import com.jxnu.os.model.Student;import com.jxnu.os.utils.StudentUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Service;import java.util.List;/** * @author xiao */@Servicepublic class StudentService implements UserDetailsService &#123; @Autowired StudentMapper studentMapper; /** * 注册 * @param student * @return */ public boolean register(Student student) &#123; Student existUser = studentMapper.loadUserBySno(student.getUsername()); if (existUser != null) &#123; //如果用户名已存在 return false; &#125; else &#123; BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); String encode = encoder.encode(student.getPassword()); student.setPassword(encode); studentMapper.insert(student); return true; &#125; &#125; /** * 修改密码 * @param sno * @param password * @param rePassword * @return */ public boolean modifyPass(String sno,String password,String rePassword) &#123; Student student = studentMapper.loadUserBySno(sno); BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); if(encoder.matches(password,student.getPassword())) &#123; String encode = encoder.encode(rePassword); rePassword = encode; studentMapper.modifyPass(sno,rePassword); return true; &#125;else &#123; return false; &#125; &#125;&#125; 三、mapper层StudentMapper.java 12345678910111213141516package com.jxnu.os.mapper;import com.jxnu.os.model.Student;import org.apache.ibatis.annotations.Param;import java.util.List;/** * @author xiao */public interface StudentMapper &#123; int insert(Student student); int modifyPass(String sno,String rePassword);&#125; StudentMapper.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.jxnu.os.mapper.StudentMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.jxnu.os.model.Student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result column=&quot;sno&quot; property=&quot;sno&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result column=&quot;s_sex&quot; property=&quot;s_sex&quot; jdbcType=&quot;CHAR&quot;/&gt; &lt;result column=&quot;t_id&quot; property=&quot;t_id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; &lt;update id=&quot;modifyPass&quot; parameterType=&quot;com.jxnu.os.model.Student&quot;&gt; update student set password = #&#123;rePassword&#125; where sno=#&#123;sno&#125; &lt;/update&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;com.jxnu.os.model.Student&quot;&gt; insert into student (username,password) values (#&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;) &lt;/insert&gt;&lt;/mapper&gt;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题记录（二）]]></title>
    <url>%2F2020%2F02%2F06%2Fleetcode%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[leetcode14：最长公共前缀问题描述：编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。示例1：输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例2：输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明:所有输入只包含小写字母 a-z 。思路： 首先找出数组中长度最短的字符串，该字符串一定包含或等于最长公共前缀。定义一个空字符串s，从第一个字符串开始与最短字符串比较，若对应字符相符，s加上该字符。否则直接返回s。代码如下： 1234567891011121314151617181920212223class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string s = ""; if(strs.empty()) return "; //输入为空，输出空字符串 string min = strs[0]; for(int i = 1; i &lt; strs.size(); i++) //找到最短字符串 &#123; if(strs[i].size() &lt; min.size()) min = strs[i]; &#125; for(int j = 0; j &lt; min.size(); j++) //从第一个字符开始对比，若都一样，s加上该字符 &#123; for(int m = 0; m &lt; strs.size(); m++) &#123; if(min[j] != strs[m][j]) return s; &#125; s = s + min[j]; &#125; return s; &#125;&#125;; leetcode20：有效的括号问题描述：给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。示例1：输入: &quot;()[]{}&quot;输出: true 示例2:输入: &quot;([)]&quot;输出: false 思路： 核心思想遍历字符串，左括号入栈，遇到右括号，则看是否与栈顶元素括号匹配，如果不匹配，则输出false 12345678910111213141516171819202122232425262728class Solution &#123;public: bool isValid(string s) &#123; //核心思想遍历字符串，左括号入栈，遇到右括号，则看是否与栈顶元素括号匹配，如果不匹配，则输出false 。遍历完需要检查栈是否为空 if (s.empty()) return true; stack&lt;char&gt; stack; for(int i=0;i&lt;s.size();i++) &#123; if (s[i] == '(' || s[i] == '[' || s[i] == '&#123;') &#123; stack.push(s[i]); &#125; else&#123; if(stack.empty()) return false; if ((s[i]==')' &amp;&amp; '('!=stack.top()) || (s[i]==']' &amp;&amp; '['!=stack.top()) || ((s[i]=='&#125;' &amp;&amp; '&#123;'!=stack.top()))) &#123;return false;&#125; stack.pop(); &#125; &#125; if(stack.empty()) return true; else return false; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成Spring Security（一）登录注销]]></title>
    <url>%2F2020%2F02%2F05%2FSpringBoot%E9%9B%86%E6%88%90Spring%20Security%EF%BC%88%E4%B8%80%EF%BC%89%E7%99%BB%E5%BD%95%E6%B3%A8%E9%94%80%2F</url>
    <content type="text"><![CDATA[SpringBoot集成Spring Security（二）注册 、密码加密、修改密码写在前面Spring Security是一种基于 Spring AOP 和 Servlet 过滤器的安全框架。它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理身份确认和授权。由于最近写的项目用到了这方面知识，这里做一些总结。下面直接看代码一、创建项目这里以多模块项目为例。 多模块项目优点： 帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便各个模块的构建，而不用每次都构建整个项目，使得针对某个模块的特殊控制更为方便。二、引入pom依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 三、web层 项目最核心的代码SecurityConfig.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * @author xiao * 使用springsecurity对用户登录、注销以及权限进行控制 */@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private StudentService studentService; @Autowired private ObjectMapper objectMapper; @Bean PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(studentService).passwordEncoder(new BCryptPasswordEncoder()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http// .authenticationProvider(authenticationProvider()) .httpBasic() //未登录时 .authenticationEntryPoint((request,response,authException) -&gt; &#123; response.setContentType("application/json;charset=utf-8"); response.setStatus(HttpServletResponse.SC_FORBIDDEN); PrintWriter out = response.getWriter(); RespBean error = RespBean.error("未登录"); String s = new ObjectMapper().writeValueAsString(error); out.write(s); out.flush(); out.close(); &#125;) .and() .authorizeRequests() .anyRequest().authenticated() //必须授权才能范围 .and() .formLogin() //使用自带的登录 .usernameParameter("username") .passwordParameter("password") .permitAll() //登录失败，返回json .failureHandler(new AuthenticationFailureHandler() &#123; @Override public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception) throws IOException, ServletException &#123; resp.setContentType("application/json;charset=utf-8"); resp.setStatus(HttpServletResponse.SC_UNAUTHORIZED); PrintWriter out = resp.getWriter(); RespBean respBean = RespBean.error("登录失败!"); if (exception instanceof UsernameNotFoundException || exception instanceof BadCredentialsException) &#123; respBean.setMsg("用户名或者密码输入错误，请重新输入!"); &#125; else if (exception instanceof DisabledException) &#123; respBean.setMsg("账户被禁用"); &#125; else &#123; respBean.setMsg("未知错误"); &#125; out.write(objectMapper.writeValueAsString(respBean)); out.flush(); out.close(); &#125; &#125;) //登录成功，返回json .successHandler(new AuthenticationSuccessHandler() &#123; @Override public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException &#123; resp.setContentType("application/json;charset=utf-8"); PrintWriter out = resp.getWriter(); Student student = (Student) authentication.getPrincipal(); student.setPassword(null); RespBean ok = RespBean.ok("登录成功!", student); String s = new ObjectMapper().writeValueAsString(ok); out.write(s); out.flush(); out.close(); &#125; &#125;) .and() .exceptionHandling() //没有权限，返回json .accessDeniedHandler((request,response,ex) -&gt; &#123; response.setContentType("application/json;charset=utf-8"); response.setStatus(HttpServletResponse.SC_FORBIDDEN); PrintWriter out = response.getWriter(); out.write(new ObjectMapper().writeValueAsString(RespBean.error("权限不足"))); out.flush(); out.close(); &#125;) .and() .logout() //退出成功，返回json .logoutSuccessHandler(new LogoutSuccessHandler() &#123; @Override public void onLogoutSuccess(HttpServletRequest req, HttpServletResponse resp, Authentication authentication) throws IOException, ServletException &#123; resp.setContentType("application/json;charset=utf-8"); PrintWriter out = resp.getWriter(); out.write(new ObjectMapper().writeValueAsString(RespBean.ok("注销成功!"))); out.flush(); out.close(); &#125; &#125;) .permitAll(); //开启跨域访问 http.cors().disable(); //开启模拟请求，比如API POST测试工具的测试，不开启时，API POST为报403错误 http.csrf().disable(); &#125; @Override public void configure(WebSecurity web) &#123; //对于在header里面增加token等类似情况，放行所有OPTIONS请求。 web.ignoring() .antMatchers(HttpMethod.OPTIONS, "/**"); &#125;&#125; 四、mapper层 mapper下的StudentMapper.java 1234567/** * @author xiao */public interface StudentMapper &#123; Student loadUserBySno(String sno);&#125; resource下的StudentMapper.xml** 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.jxnu.os.mapper.StudentMapper&quot;&gt; &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.jxnu.os.model.Student&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result column=&quot;sno&quot; property=&quot;sno&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;result column=&quot;s_sex&quot; property=&quot;s_sex&quot; jdbcType=&quot;CHAR&quot;/&gt; &lt;result column=&quot;t_id&quot; property=&quot;t_id&quot; jdbcType=&quot;INTEGER&quot;/&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;loadUserByUsername&quot; resultMap=&quot;BaseResultMap&quot;&gt; select * from student where username=#&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; 五、model层 model下的Student.java注意一定要implements UserDetails 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @author xiao * 学生实体类 */public class Student implements UserDetails &#123;// //学生主键ID private Integer id; //学生姓名 private String username; //登录密码 private String password; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; private Collection&lt;? extends GrantedAuthority&gt; authorities; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public void setAuthorities(Collection&lt;? extends GrantedAuthority&gt; authorities) &#123; this.authorities = authorities; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return this.authorities; &#125; @Override public String getPassword() &#123; return this.password; &#125; @Override public String getUsername() &#123; return this.username; &#125; @Override public boolean isAccountNonExpired() &#123; return true; &#125; @Override public boolean isAccountNonLocked() &#123; return true; &#125; @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125;&#125; 六、service层service下的StudentService.java 12345678910111213141516171819202122232425/** * @author xiao */@Servicepublic class StudentService implements UserDetailsService &#123; @Autowired StudentMapper studentMapper; /** * 登录 * @param username * @return * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; Student student = studentMapper.loadUserBySno(username); if (student == null) &#123; throw new UsernameNotFoundException("用户不存在"); &#125; return student; &#125;&#125;]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[应用层协议与网络应用]]></title>
    <url>%2F2020%2F02%2F05%2F%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[网络应用的体系结构1、客户机/服务器（Client-Server， C/S）服务器： 7*24小时提供服务 永久访问地址/域名 利用大量服务器实现可拓展性 客户机： 与服务器通信，使用服务器提供的服务 间歇性接入网络 可能使用动态IP地址 不会与其他客户机直接通信例如：Web服务 2、点对点结构（Peer-to-peer，P2P） 没有永远在线的服务器 任意端系统/节点之间可以直接通信 节点间歇性接入网络 节点可能改变IP地址 缺点：难于管理 优点：高度可伸缩 3、混合结构（Hybrid） Napster 文件传输使用P2P结构 文件的搜索采用C/S结构——集中式每个节点向中央服务器登记自己的内容每个节点向中央服务器提交查询请求，查找感兴趣的内容 网络应用的进程间通信进程：主机上运行的程序客户机进程：发起通信的进程服务器进程：等待通信请求的进程注意：采用P2P架构的应用同样存在客户机进程/服务器进程之分 同一主机上运行的进程： 进程间通信机制 操作系统提供 不同主机上运行的进程： 消息交换 套接字：Socket 进程间通信利用scoket发送/接收消息实现 类似于寄信 发送方将消息送到门外邮箱 发送方依赖（门外的）传输基础设施将消息传到接收方所在主机，并送到接收方的门外 接收方从门外获取消息 传输基础设施向进程提供API 传输协议的选择 参数的设置 如何寻址进程？ 不同主机上的进程间通信，那么每个进程必须拥有标识符 如何寻址主机？——IP地址 主机有了IP地址之后，并不足以定位进程，因为同一主机上可能同时有多个进程需要通信 端口号 为主机上每个需要通信的进程分配一个端口号 HTTP Server：80 Mail Server：25 进程的标识符IP地址+端口号 应用层协议 网络应用需遵循应用层协议 公开协议 由RFC（Request For Comments）定义 允许互操作 HTTP，SMTP，…… 私有协议多数P2P文件共享应用 应用层协议的内容 消息的类型（type）请求消息响应消息 消息的语法（syntax）格式消息中有哪些字段？每个字段如何描述 字段的语义（semantics）字段中信息的含义 规则（rules)进程何时发送/响应消息 网络应用对传输服务的需求 数据丢失/可靠性某些网络应用能容忍一定的数据丢失：网络电话某些网络应用要求100%可靠的数据传输：文件传输,telnet 时间延迟有些应用在延迟足够低时才“有效”网络电话/网络游戏 带宽（bandwidth）某些应用只有在带宽达到最低要求时才“有效”：网络视频某些应用能够适应任何带宽——弹性应用：email Internet提供的传输服务]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode解题记录(一)]]></title>
    <url>%2F2020%2F02%2F04%2Fleetcode%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[仅为自己的学习做记录1、leetcode1：两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例：给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 我的思路：题目已经给出提示The returned array must be malloced, assume caller calls free().所以需要定义一个存放数组下标的数组，代码如下： 123456789101112131415161718192021/** * Note: The returned array must be malloced, assume caller calls free(). */int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;int *num = malloc(sizeof(int)*2);// 定义一个存放数组下标的数组 for(int i = 0; i &lt; numsSize - 1; i++) &#123; for(int j = i + 1; j &lt; numsSize; j++) &#123; // 两层循环 if(nums[i] + nums[j] == target) &#123; num[0] = i; num[1] = j; *returnSize = 2; return num; &#125; &#125; &#125; return 0;&#125; 2、leetcode7：整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。示例1：输入: 123输出: 321 示例2：输入: -123输出: -321 示例3：输入: 120输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 我的思路：整数反转，与上题思路一致。这里需要注意整数溢出。tips 12C中常量INT_MAX和INT_MIN分别表示最大最小整数，定义在头文件limits.h中。因为int占4字节32位，根据二进制编码的规则，INT_MAX = 2^31-1，INT_MIN= -2^31.C/C++中，所有超过该限值的数，都会出现溢出，出现warning，但是并不会出现error。如果想表示的整数超过了该限值，可以使用长整型long long 占8字节64位。` 代码如下： 1234567891011121314int reverse(int x) &#123; long i = 0; long t = x; while (t) &#123; i = 10 * i + (t % 10); t /= 10; &#125; if (i &lt; INT_MIN || i &gt;INT_MAX) &#123; return 0; &#125; return i; &#125; 3、leetcode9： 回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例1：输入：121输出：true 示例2：输出：-121输出：false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3：输入：10输出：false从右向左读, 为 01 。因此它不是一个回文数。 我的思路：把数字倒置后与原来的数相比较即可，代码如下： 1234567891011121314151617bool isPalindrome(int x)&#123; int r = 0; int m = x; if(x&lt;0) return false; else&#123; while(x) &#123; r=r*10+x%10; x/=10; &#125; if(x==m) return false; else return true; &#125;&#125; 但是提交之后显示解答错误Line 5: Char 25: runtime error: signed integer overflow: 746384741 * 10 cannot be represented in type &#39;int&#39; (solution.c)越界int最大值查询资料后更改代码如下: 12345678910111213141516171819bool isPalindrome(int x)&#123; int temp = 0; //当x为负数，或者x的末尾为0时返回错误 if(x&lt;0 || (x%10==0 &amp;&amp; x!=0))&#123; return false; &#125; while(x&gt;temp)&#123; temp = temp*10 + x%10; x = x/10; &#125; //分奇数偶数 if(temp == x || temp/10 == x)&#123; return true; &#125; else&#123; return false; &#125; &#125; 4、leetcode13：罗马数字转整数罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。示例1：输入: &quot;III&quot;输出: 3 示例2：输入: &quot;IV&quot;输出: 4 示例3：输入: &quot;IX&quot;输出: 9 示例4：输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例5：输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 我的思路：遍历输入字符串，如果当前字符代表数字小于上一个字符，直接相加。否则当前值减去上一位的值*2。代码如下： 1234567891011121314151617181920212223int romanToInt(char * s)&#123; int result=0,roman=0,temp=0; while (*s)&#123; switch (*s)&#123; case 'I':temp =1;break; case 'V':temp =5;break; case 'X':temp =10;break; case 'L':temp =50;break; case 'C':temp =100;break; case 'D':temp =500;break; case 'M':temp =1000; &#125; if(temp&gt;roman)&#123; result = result + (temp - roman*2); &#125;else&#123; result = result + temp; &#125; roman = temp; &#125; return result;&#125; 5、leetcode182：查找重复的电子邮箱编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。示例： 1234567+----+---------+| Id | Email |+----+---------+| 1 | a@b.com || 2 | c@d.com || 3 | a@b.com |+----+---------+ 根据以上输入，你的查询应返回以下结果： 12345+---------+| Email |+---------+| a@b.com |+---------+ 说明：所有电子邮箱都是小写字母。我的思路：这题比较简单哈哈哈哈，代码如下： 12# Write your MySQL query statement belowselect Email from Person group by Email having count(Email)&gt;1;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络体系结构]]></title>
    <url>%2F2020%2F02%2F03%2F%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[计算机网络的体系结构 网络体系结构是从功能上描述计算机网络结构 计算机网络体系结构简称网络体系结构，是分层结构 每层遵循某个/些网络协议完成本层功能 计算机网络体系结构是计算机网络各层及其协议的集合 体系结构是一个计算机网络的功能层次及其关系的定义 体系结构是抽象的 分层网络体系结构基本概念 实体表示任何可发送或接收信息的硬件或软件进程 协议是控制两个对等实体进行通信的规则的集合，协议是“水平的” 任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是“垂直的” 下层协议的实现对上层的服务用户是透明的 同系统的相邻层实体间通过接口进行交互，通过服务访问点SAP（Service Access Point），交换原语，指定请求的特定服务 OSI（开放系统互连）参考模型1、通信过程2、数据封装3、为什么需要数据封装？ 增加控制信息–》构造协议数据单元 控制信息主要包括：地址（Address）：标识发送端/接收端差错检测编码（Error-detecting code）：用户差错检测或纠正协议控制（Protocol control）：实现协议功能的附加信息，如：优先级、服务质量、安全控制等 4、物理层简单来说就是比特数据的传输 接口特性 —》机械特性、电气特征、功能特性、规程特性 比特编码 数据率 比特同步 —》时钟同步 传输模式单工 （单向通信，如传统的电视）半双工 （可以双向通信，但只能交替进行，如对讲机 发和说不能同时进行）全双工（双向传递 ，同时发和收） 5、数据链路层 负责结点-结点数据传输 组帧 物理寻址 在帧头中增加发送端或接收端的物理地址标识数据帧的发送端或接收端 流量控制 避免淹没接收端 差错控制 检测并重传损坏或丢失帧，避免重复帧 访问控制 在任一给定时刻决定哪个设备拥有链路（物理介质）控制使用权 6、网络层功能 负责源主机到目的主机数据分组交付可能穿越多个网络 逻辑寻址全局唯一逻辑地址，确保数据分组被送达目的主机，如IP地址 路由路由器（或网关）互连网络，并路由分组至最终目的主机 路径选择 分组转发 7、传输层负责源-目的（端-端）（进程间）完整报文传输 分段与重组 SAP寻址 确保将完整报文提交给正确进程，如端口号 连接控制 流量控制 差错控制 8、会话层 对话控制建立、维护 同步在数据流中插入“同步点” 最“薄”的一层 9、表示层处理两个系统间交换信息的语法与语义问题 数据表示转化转化为主机独立的编码 加密/解密 压缩/解压缩 10、应用层 支持用户通过用户代理（如浏览器）或网络接口使用网络（服务） 典型应用层服务：文件传输（FTP）电子邮件（SMTP）Web（HTTP）TCP/IP参考模型 5层参考模型综合OSI和TCP/IP的优点 应用层：提供进程之间的通信服务，实现网络各种具体应用；FTP，SMTP，HTTP、DNS、POP 传输层：提供端到端（主机到主机）的传输服务TCP，UDP 网络层：提供不同网络之间的选路服务IP协议、ICMP、路由协议等 数据链路层：提供一段链路相邻结点的传输服务以太网、WiFi、PPP 物理层：比特传输，提供网络通信的物理规范]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cisco Packet Tracer的安装与汉化]]></title>
    <url>%2F2020%2F02%2F02%2FCisco%20Packet%20Tracer%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B1%89%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、下载1、官网下载首先去思科官网下载对应的压缩包。点击图中所示注册下载按钮按照提示步骤完成注册注册之后登陆，点击导航栏中资源-&gt;所有资源，即可看到各版本压缩包。PTUI文件夹下有对应的汉化包，有需要的也可以自行下载。)2、网盘获取为方便大家下载我已经把安装包和汉化包放在了百度网盘中（7.2.1版本）链接：链接：https://pan.baidu.com/s/15_HGAcYW-pfbwyyWCwVdaA提取码：li5u二、安装安装步骤比较简单1、解压缩之后双击.exe文件开始安装软件。2、一路默认next即可（中途可以更换安装目录，自己随意）3、安装完成之后，点击finsh完成安装。三、汉化1、将Simplified Chinese.ptl文件复制进languages文件夹下。2、菜单栏中选择Option-&gt;Preferences,Select Language选择对应文件后重启服务即可（我这里是已经汉化成功的界面）。大功告成！]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述（二）]]></title>
    <url>%2F2020%2F02%2F01%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[网络协议 网络协议规定了通信双方具体的通信规则，包括消息的传递细节。协议的三要素：语法、语义、同步 语义：对构成协议元素的含义的解释，即“讲什么”。 语法：数据与控制信息的结构或格式，即“怎么讲”。 同步：规定了事件的执行顺序。交换的概念和分类概念：网络中间结点按照某种方式动态地分配传输线路的资源，从输入链路选择连通到输出链路的过程称为交换。分类：电路交换技术、分组交换技术、报文交换技术电路交换技术特性：1）提供面向连接的服务（拨号建立连接，通信，挂机释放连接）电路交换最典型的例子就是打电话，当打电话时，别人无法打进同一个电话，资源独占。每次打电话时首先要拨号建立连接，打完电话需要挂机释放连接，属于面向连接的服务。2）资源独占，价格高3）通信可靠性高 分组交换技术核心思想：分组：将需要传输的较大的文件或报文分成多个小的包（分组）。存储转发：分组交换机（路由器）收到分组，存储到缓存中，排队等待处理，最后选择输出链路转发。资源共享：由于存储转发使得多个用户可以共享一段链路。资源共享是宏观的。 为什么要分组？ 数据越大，传输中出错的概率越大，重传分组的代价越高 数据越大，路由器缓存越大，不利于存储转发 分组分多大最合理？ 低出错不影响路由器存储转发的前提下尽可能大 一般链路的分组最大为1500Byte 每个分组加上首部有什么作用？ 首部实现了协议的规则 使接收方能够有效的将分组还原 分组交换网的优点和缺点？ 优点：适合计算机通信，实现宏观上的资源共享，通信效率高。 缺点：存储交换排队导致网络延迟很大甚至出现网络拥塞。 报文交换技术特点：不分组、存储转发、资源共享网络的带宽和时延带宽：网络的最高数据传输率，即每秒最高能传输多少bit的数据。单位：b/s或bps（每秒钟可以发送的比特数）一个网络的带宽是该网络所有链路带宽的最小值。 吞吐量：在单位时间内实际通过某个网络（或信道、接口）的数据量，单位b/s。 吞吐量是网络实际的带宽。传播速度：信号（即电磁波）在传输介质上的传播速率，单位m/s（米/秒）或千米/小时。 分组交换网络的时延传输时延（发送时延）：数据从结点发送到链路上的时间传播时延：信号从链路的一端发送到另一端传播的时间接收时延：一般作为结点处理时延考虑结点处理时延（排队转发时延）：路由器接收数据，排队等待处理，查找转发表决定输出链路所花费的时间 分组交换网络时延的计算传输时延=数据大小/网络带宽由网络带宽、数据大小决定 传播时延=链路长度/传播速度由传播介质、传播速度、链路长度决定 分组交换网的网络拥塞网络拥塞现象：当中间节点（路由器）收到数据的速度大于发出数据的速度时，缓冲将被填满，部分分组将被丢弃，网络出现拥塞。往返时延RTTRTT（Roud-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的确认为止总共经历的时延。RTT反映了分组传输总的时延，使用ping命令可以测量RTT。时延带宽积链路的时延带宽积又称为以比特为单位的链路长度。 时延带宽积 = 传播时延 x 带宽]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络的性能指标与分组交换网络]]></title>
    <url>%2F2020%2F02%2F01%2F%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[同个人网站：http://tsundere-x.top/计算机网络概述（三）计算机网络概述（一）网络协议网络协议规定了通信双方具体的通信规则，包括消息的传递细节。协议的三要素：语法、语义、同步 语义：对构成协议元素的含义的解释，即“讲什么”。 语法：数据与控制信息的结构或格式，即“怎么讲”。 同步：规定了事件的执行顺序。 交换的概念和分类概念：网络中间结点按照某种方式动态地分配传输线路的资源，从输入链路选择连通到输出链路的过程称为交换。分类：电路交换技术、分组交换技术、报文交换技术 电路交换技术 特性1）提供面向连接的服务（拨号建立连接，通信，挂机释放连接）电路交换最典型的例子就是打电话，当打电话时，别人无法打进同一个电话，资源独占。每次打电话时首先要拨号建立连接，打完电话需要挂机释放连接，属于面向连接的服务。2）资源独占，价格高3）通信可靠性高 分组交换技术 核心思想：分组：将需要传输的较大的文件或报文分成多个小的包（分组）。存储转发：分组交换机（路由器）收到分组，存储到缓存中，排队等待处理，最后选择输出链路转发。资源共享：由于存储转发使得多个用户可以共享一段链路。资源共享是宏观的。 为什么要分组？ 数据越大，传输中出错的概率越大，重传分组的代价越高 数据越大，路由器缓存越大，不利于存储转发 分组分多大最合理？ 低出错不影响路由器存储转发的前提下尽可能大 一般链路的分组最大为1500Byte 每个分组加上首部有什么作用？ 首部实现了协议的规则 使接收方能够有效的将分组还原 分组交换网的优点和缺点？ 优点：适合计算机通信，实现宏观上的资源共享，通信效率高。 缺点：存储交换排队导致网络延迟很大甚至出现网络拥塞。 报文交换技术特点：不分组、存储转发、资源共享 三种交换技术比较 网络的性能指标网络的带宽和时延带宽：网络的最高数据传输率，即每秒最高能传输多少bit的数据。单位：b/s或bps（每秒钟可以发送的比特数）一个网络的带宽是该网络所有链路带宽的最小值。 网络带宽的进一步说明 为什么20Mb/s的带宽下载速度约2.4MB/S？ 网络带宽单位：1Mb/s = 10^3^kb/s = 10^6^b/s计算机存储单位：1M = 1024K = 2^20^Byte = 8*2^20^bit 吞吐量：在单位时间内实际通过某个网络（或信道、接口）的数据量，单位b/s。 吞吐量是网络实际的带宽。 带宽是网络最高的吞吐量 传播速度：信号（即电磁波）在传输介质上的传播速率，单位m/s（米/秒）或千米/小时。 分组交换网络的时延 传输时延（发送时延）：数据从结点发送到链路上的时间传播时延：信号从链路的一端发送到另一端传播的时间接收时延：一般作为结点处理时延考虑结点处理时延（排队转发时延）：路由器接收数据，排队等待处理，查找转发表决定输出链路所花费的时间 在移动网访问部署在电信的服务器为什么会很慢？ 分组交换网络时延的计算传输时延=数据大小/网络带宽由网络带宽、数据大小决定 传播时延=链路长度/传播速度由传播介质、传播速度、链路长度决定 分组交换网的网络拥塞网络拥塞现象：当中间节点（路由器）收到数据的速度大于发出数据的速度时，缓冲将被填满，部分分组将被丢弃，网络出现拥塞。往返时延RTTRTT（Roud-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的确认为止总共经历的时延。RTT反映了分组传输总的时延，使用ping命令可以测量RTT。时延带宽积链路的时延带宽积又称为以比特为单位的链路长度。 时延带宽积 = 传播时延 x 带宽]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络概述（一）]]></title>
    <url>%2F2020%2F01%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[计算机网络 = 通信技术 + 计算机技术计算机网络是通信技术海域计算机技术紧密结合的产物计算机网络就是一种通信网络什么是计算机网络？广义的计算机网络定义：在协议控制下，由一台或多台计算机、若干台终端设备、数据传输设备，以及用于终端和计算机之间、或者若干台计算机之间数据流动的通信控制处理机组成的系统的集合。计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备（交换机、路由器等）与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。计算机网络就是互连的、自治的计算机集合（公认的概念） 自治-无主从关系 ： 一台计算机不能控制另一台计算机互连-互联互通 ：通过通信链路—》网络中两个节点之间的物理通道称为通信链路。通信链路的传输介质主要有双绞线、光纤和微波。 计算机网络的发展20世纪60年代：分组交换思想的提出，可能比世界上第一个网络的意义更加重大，它使得网络传输数据成为可能，并一直沿用到今天。 20世纪70~80年代：TCP/IP协议思想的提出，提供了这样一种可能：即不同厂商生产的计算机，不同结构的网络间实现互通。所以它既是一个协议簇，更是一种标准，它使得网络飞速向前发展。 20世纪90年代：Web技术真正把网络引入民用行业，使得网络行业生机勃勃，飞速发展。随着网络的逐步普及，网络用户在这个时期飞速增长，现如今各行各业都已经离不开网络 计算机网络的功能数据通信：数据通信是计算机网络最基本、最重要的功能，包括连接控制，传输控制，差错控制，流量控制，路由选择，多路复用等子功能。资源共享：包括硬件资源、软件资源和数据资源。分布式处理：当计算机网络中的某个计算机负荷过重时，可以将其处理的任务传送给网络中的其他计算机系统进行处理，利用空闲计算机资源提高整个系统的利用率。典型的有Hadoop平台。提高可靠性：计算机网络中的每台计算机可以通过网络互为替代机，一台计算机宕机了可有另一台计算机替代。负载均衡：将工作任务均衡地分配给计算机网络中的各台计算机。 计算机网络的组成物理组成（硬件、软件、协议三大部分） 1、硬件：由主机、通信处理机、通信线路（包括有线线路和无线线路）和交换设备（交换机等连接设备）组成。 2、软件：主要包括实现资源共享的软件和方便用户使用的各种工具软件（如QQ）。 3、协议：就是一种规则，如汽车在道路上行驶必须遵循交通规则一样，数据在线路上传输也必须遵循一定的规则。工作方式组成（边缘部分、核心部分）1、边缘部分：由所有链接在互联网上，供用户直接使用的主机组成，用来进行通信和资源共享—》C/S方式、P2P方式。2、核心部分：由大量的网络和链接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。 功能组成（通信子网、资源子网） 1、通信子网：由各种传输介质、通信设备和相应的网络协议组成，为网络提供数据传输、交换和控制能力，实现联网计算机之间的数据通信。包括网络层、数据链路层、物理层 2、资源子网：由主机、终端以及各种软件资源、信息资源组成，负责全网的数据处理业务，向网络用户提供各种网络资源和服务。包括应用层、表示层、会话层 局域网（Local Area Network, LAN）：一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网络。包括以太网、令牌环网等。当前的局域网主流是以太网。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。 域域网（Metropolitan Area Network，MAN）：一种介于局域网与广域网之间，覆盖一个城市的地理范围，用来将同一区域内的多个局域网互连起来的中等范围的计算机网络。这些网络通常涵盖一个大学校园或一座城市。MAN的一个重要用途是用作骨干网，通过它将位于同一城市内不同地点的主机、数据库，以及LAN等互相联接起来。 广域网（Wide Area Network，WAN）：一种用来实现不同地区的局域网或域域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网络。所覆盖的范围从几十公里到几千里。它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github托管代码以及github一些最常用的命令]]></title>
    <url>%2F2020%2F01%2F21%2F%E4%BD%BF%E7%94%A8github%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81%E4%BB%A5%E5%8F%8Agithub%E4%B8%80%E4%BA%9B%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[生成SSH密钥首先打开命令行工具，右键鼠标任意位置打开git bash here,然后输入以下命令cd ~/.ssh使用ssh-keygen生成密钥ssh-keygen -t rsa -C &quot;我的邮箱地址&quot;使用默认的文件名，输入密码，密钥生成成功直接复制命令行看到的密钥会失败，正确复制密钥的方法：ls一下查看是否有id_rsa.pub文件，如果有，则打开文件，复制文件里面的内容.新建仓库后点击Settings-&gt;Deploy keys将复制所得密钥粘贴至对应位置即可。 github一些最常用的命令git init 仓库初始化git status 查看工作区代码相对于暂存区的差别git add . 将当前目录下修改的所有代码从工作区添加至暂存区git commit -m ‘注释’ 将缓存区内容添加到本地仓库git push origin master 将本地版本推送到远程服务器，origin是远程主机，master表示是远程服务器上的master分支，分支名是可以修改的。]]></content>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中注解大全]]></title>
    <url>%2F2019%2F11%2F30%2FSpring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8%20%2F</url>
    <content type="text"><![CDATA[@Controller标识一个该类是Spring MVC controller 处理器，用来创建处理http请求的对象1234567@Controllerpublic class TestController&#123; @RequestMapping("test") public String test(Map&lt;String,Object&gt; map)&#123; return "hello"; &#125;&#125; @RestControllerSpring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@RestController，默认返回json格式。 1234567@RestControllerpublic class TestController&#123; @RequestMapping("/test") public String test(Map&lt;String,Object&gt; map)&#123; return "hello"; &#125;&#125; @Service用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中 @Autowired用来装配bean，都可以写在字段上，或者方法上。 默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired（required=false） @RequestMapping类定义处：提供初步的请求映射信息，相对于WEB应用的根目录。 方法处：提供进一步的细分映射信息，相对于类定义处的URL。 @RequestParam用于将请求参数区数据映射到功能处理方法的参数上 123public Resp test(@RequestParam Integer id)&#123; return Resp.success(customerInfoService.fetch(id));&#125; 这个id就是要接收从接口传递过来的参数id的值的，如果传递过来的参数名和接收的不一致，也可以如下 123public Resp test(@RequestParam(value="course_id") Integer id)&#123; return Resp.success(customerInfoService.fetch(id));&#125; 其中course_id就是接口传递的参数，id即使映射course_id的参数名 @ModelAttribute1、标记在方法上 标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。 A、在有返回的方法上： 当ModelAttribute设置了value，方法返回的值会以这个value为key，以参数接受到的值作为value，存入到Model中，如下面的方法执行之后，最终相当于model.addAttribute（“user_name”，name）;假如 @model.addAtrribute没有自定义value，则相当于model.addAttribute（“name”，name）； 12345@ModelAttribute(value="user_name")public String before2(@RequestParam(required = false) String name,Model model)&#123; System.out.println("进入了2，" + name); return name;&#125; B、在没返回的方法上： 需要手动model.add方法 12345@ModelAttributepublic void before(@RequestParam(required = false) Integer age, Model model)&#123; model.addAttribute("age",age); System.out.println("进入了1：" + age);&#125; 我们在当前类下建一个请求方法： 1234567891011@RequestMapping(value = "/mod")public Resp mod( @RequestParam(required = false) String name; @RequestParam(required = false) Integer age; Model model)&#123; System.out.println("进入mod"); System.out.println("参数接受的数值&#123;name="+name+";age="+age+"&#125;"); System.out.println("model传过来的值：" + model); return Resp.success("1"); &#125;) 在浏览器中输入访问地址并且加上参数： http://localhost:8080/api/test/mod?name = 我是哈哈 &amp; age = 12 最终输出 12345进入了1：:40进入了2：我是哈哈进入mod参数接受的数值(name = 我是哈哈， age = 18)model传来的值：&#123;age = 40, user_name = 我是哈哈 &#125; 2、标记在方法的参数上 标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。我们在上面的类中加入一个方法如下 1234567891011@RequestMapping(value="/mod2")public Resp mod2(@ModelAttribute("user_name") String user_name, @ModelAttribute("name") String name, @ModelAttribute("age") Integer age, Model model)&#123; System.out.println("进入mod2"); System.out.println("user_name:" + user_name); System.out.println("name:" + name); System.out.println("age:" + age); System.out.println("model:" + model); return Resp.success("1"); &#125; 在浏览器中输入访问地址并且加上参数： http://localhost:8080/api/test/mod2?name = 我是哈哈 &amp; age = 12 最终输出 1234567进入了1：40进入了2：我是哈哈进入了mod2user_name：我是哈哈name：我是哈哈age：40model:&#123;user_name = 我是哈哈，org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: 0 errors, age=40, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: 0 errors&#125;&#125; 从结果可以看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。 @Cacheable用来标记缓存查询。可用用于方法或者类中 当标记在一个方法上时表示该方法是支持缓存的， 当标记在一个类上时则表示该类所有的方法都是支持缓存的。比如@Cacheable(value=”UserCache”) 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。 但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义. 1234567@Cacheable(value="UserCache")// 使用了一个缓存名叫 accountCache public Account getUserAge(int id) &#123; //这里不用写缓存的逻辑，直接按正常业务逻辑走即可， //缓存通过切面自动切入 int age=getUser(id); return age; &#125; @CacheEvict用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。@CacheEvict(value=”UserCache”) @Resource@Resource的作用相当于@Autowired 只不过@Autowired按byType自动注入， 而@Resource默认按 byName自动注入罢了。 @Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序: 如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常 如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； @PostConstruct用来标记是在项目启动的时候执行这个方法。用来修饰一个非静态的void()方法 也就是spring容器启动时就执行，多用于一些全局配置、数据字典之类的加载 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行,init()方法之前执行。PreDestroy（）方法在destroy()方法执行执行之后执行 @PreDestroy被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前 @Repository用于标注数据访问组件，即DAO组件 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注 @Scope用来配置 spring bean 的作用域，它标识 bean 的作用域。 默认值是单例 singleton:单例模式,全局有且仅有一个实例 prototype:原型模式,每次获取Bean的时候会有一个新的实例 request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效 session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效 global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。 @SessionAttributes默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中 参数： names：这是一个字符串数组。里面应写需要存储到session中数据的名称。 types：根据指定参数的类型，将模型中对应类型的参数存储到session中 value：和names是一样的。 12345678910@Controller @SessionAttributes(value=&#123;"names"&#125;,types=&#123;Integer.class&#125;) public class ScopeService &#123; @RequestMapping("/testSession") public String test(Map&lt;String,Object&gt; map)&#123; map.put("names", Arrays.asList("a","b","c")); map.put("age", 12); return "hello"; &#125; &#125; @Required适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。 @Qualifier当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（三）线程的互斥与同步机制]]></title>
    <url>%2F2019%2F10%2F07%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[线程的互斥与同步机制一、互斥为何需要引入互斥机制？ 当多个线程对同一数据并发读写（至少有一个线程执行写操作）时，这种情形被称为竞争。竞争会导致数据读或写的不确定性。而有时这种不确定性是不可容忍的。 如何实现互斥？ 在并发程序设计中，通常使用锁机制来实现互斥 1、由用户标记必须原子执行的代码段，即使用synchronized关键字 2、给资源一把配有自动机制的锁 【注意】： Java将资源限定为引用型对象，并为每一对象自动配备一把锁：锁初始时处于打开状态。synchronized标记的原子代码段在访问资源前，会自动检测资源对象持有的锁是否处于打开状态。若是，则占用并同时将锁置为锁闭态，并在该代码段执行完毕后。将锁的状态值为打开态；若否，则持有该代码的线程因等待资源占用而进入阻塞态。 • 只有对象才有锁，对基本类型的数据，无法实现线程的互斥访问。 • 对于未使用synchronized标记的代码，锁机制不起作用。 • 无论正常结束还是异常退出，都将自动释放锁。 死锁和活锁 死锁：就是多个线程对临界资源的循环等待，使得这些线程均都无法获得执行。 例如：A，B，C三个线程分别占用D1、D2、D3三个临界资源，A只有获得B占用的资源D2,方能继续运行；而B只有获得C占用的资源D3，方能继续运行；C只有获得A占用的资源D1，方能继续运行。这样，A,B,C处在对资源的循环等待状态，均无法前进。 活锁：也称饥饿。就是某线程虽有执行的资格，但由于某种原因总是得不到执行。 例如：A,B,C三个线程循环访问临界资源D，但A，B的优先级相同，但均高于C。由于Java的抢占式策略，C线程可能总得不到执行。 二、同步同步（Sync） 多个线程的运行满足特定的节奏 所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 根据这个定义，Java中所有方法都是同步调用，应为必须要等到结果后才会继续执行。我们在说同步、异步的时候，一般而言是特指那些需要其他端协作或者需要一定时间完成的任务。 简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。 异步（Async） 多个线程的运行相互独立，彼此间无依赖性 异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。 举个例子简单说明下两者的区别： 同步：火车站多个窗口卖火车票，假设A窗口当卖第288张时，在这个短暂的过程中，其他窗口都不能卖这张票，也不能继续往下卖，必须这张票处理完其他窗口才能继续卖票。直白点说就是当你看见程序里出现synchronized这个关键字，将任务锁起来，当某个线程进来时，不能让其他线程继续进来，那就代表是同步了。 异步：当我们用手机下载某个视频时，我们大多数人都不会一直等着这个视频下载完，而是在下载的过程看看手机里的其他东西，比如用qq或者是微信聊聊天，这种的就是异步，你执行你的，我执行我的，互不干扰。比如上面卖火车票，如果多个窗口之间互不影响，我行我素，A窗口卖到第288张了，B窗口不管A窗口，自己也卖第288张票，那显然会出错了。 并发 在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥。 并行 在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事 件之间不一定要同一时刻发生。 *Java的同步机制 = 存取共享资源的互斥机制 + 线程间的通信机制* 用于线程通信的方法存在于Object类中，包括wait()、notify()、notifyAll()。wait()会暂停当前线程的执行，并释放所持有的锁，进入等待状态；notify()操作将唤醒一个等待的线程；notifyAll()将唤醒所有等待的进程。 【注意】 wait()、notify()、notifyAll()都是final方法，不允许被重写；这些方法只能直接或间接地用于临界区中，否则，将会产生非法监控锁状态异常。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（二）线程的构造和运行]]></title>
    <url>%2F2019%2F10%2F07%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[① 用Thread类构造线程对象（继承Thread类来创建并启动多线程） 123456789101112131415161718192021222324252627282930313233343536373839package cn.sxt.thread;/** * 创建线程方式一： * 1、创建：继承Thread+重写run * 2、启动：创建子类对象+start * @author 1979 * */public class StartThread extends Thread&#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println("一边听歌"); &#125; &#125; public static void main(String[] args) &#123; /* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程 * for(int i=0;i&lt;20;i++) &#123; * System.out.println("一边coding"); * &#125; */ //创建子类对象 StartThread st = new StartThread(); //启动 st.start();//不保证立即运行 由cpu调用 //st.run();//普通方法调用，只能听完歌再敲代码 for(int i=0;i&lt;20;i++) &#123; System.out.println("一边coding"); &#125; &#125;&#125; 【运行结果】 12345678一边coding一边coding...一边听歌一边听歌...一边coding一边coding 【缺点】：由于java采用单继承机制，若为实现多线程而继承了Thread，将无法再继承其他类，是非常不明智的做法。 ② 用Runnable辅助构造线程（实现Runnable接口创建线程类） 123456789101112131415161718192021222324252627282930313233343536373839404142package cn.sxt.thread;/*** * 创建线程方式二 * 1、创建：实现Runnable+重写run * 2、启动：创建实现类对象+Thread对象+start * * 推荐：避免单继承的局限性，优先使用接口 * 方便共享资源 * @author 1979 * */public class StartRun implements Runnable&#123; /** * 线程入口点 */ @Override public void run() &#123; for(int i=0;i&lt;20;i++) &#123; System.out.println("一边听歌"); &#125; &#125; public static void main(String[] args) &#123; /* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程 * for(int i=0;i&lt;20;i++) &#123; * System.out.println("一边coding"); * &#125; */ //创建实现类对象 StartRun sr = new StartRun(); //创建代理类对象 Thread t = new Thread(sr); //启动 t.start();//不保证立即运行 由cpu调用 //st.run();//普通方法调用，只能听完歌再敲代码 for(int i=0;i&lt;20;i++) &#123; System.out.println("一边coding"); &#125; &#125;&#125; 【运行结果】 12345678一边coding一边coding...一边听歌一边听歌...一边coding一边coding 12345678910111213141516171819202122232425262728293031323334353637383940package liti_07;/*本例展现这样一种方式：利用Runnable接口直接构造线程并运行 *有如下关键点： *1、希望该类中创建线程对象，就必须有线程成员，即私有变量t; *2、在构造函数中构造t引用的线程对象，注意把自己作为参数传给t; *3、还需要启动线程。由于t长设为私有，故不能直接t.start()， * 需要设置其他方法，如本例另提供一个公共的start()方法。 **/public class Ch_7_3 implements Runnable&#123; public static void main (String[] args) &#123; System.out.print("Main 开始"); Ch_7_3 m1=new Ch_7_3(1,"奇数线程"); //注意，m1依旧不是线程对象 Ch_7_3 m2=new Ch_7_3(2,"偶数线程"); m1.start(); //注意，调用的是类R自己定义的start() m2.start(); System.out.print("当前共有"+ Thread.activeCount()+"个线程"); System.out.print("Main 结束"); &#125; private int d; private Thread t; //-----新增成员 public void start()&#123; t.start(); &#125; //-----关键点2 public Ch_7_3(int x, String s)&#123; d=x; //t=new Thread(this); t.setName(s); //----关键点1 t=new Thread(this,s); &#125; public void run()&#123; for(int i=d; i&lt;50;i=i+2) System.out.print(" "+i); //Thread t=Thread.currentThread(); //---此句不再需要 System.out.print(t.getName()+"结束！"); &#125; &#125; 线程的一些常用方法 1、currentThread() 返回对当前正在执行的线程对象的引用。 2、getId() 返回此线程的标识符 3、getName() 返回此线程的名称 4、getPriority() 返回此线程的优先级 5、isAlive() 测试这个线程是否还处于活动状态。 什么是活动状态呢？ 活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。 6、sleep(long millis) 使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。 7、interrupt() 中断这个线程。 8、interrupted() 和isInterrupted() interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能 isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但不清楚状态标志 9、 setName(String name) 将此线程的名称更改为等于参数 name 。 10、isDaemon() 测试这个线程是否是守护线程。 11、setDaemon(boolean on) 将此线程标记为 daemon线程或用户线程。 12、join() 在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。 join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行 13、yield() yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。 14、setPriority(int newPriority) 更改此线程的优先级]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo如何绑定个人域名]]></title>
    <url>%2F2019%2F10%2F06%2FHexo%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[title: 3分钟教你Hexo如何绑定个人域名date: 2019-10-06 10:47:48tags: Hexo 前两天用Hexo+GitHub搭建好了自己的个人博客http://tsundere-x.top/ ，默认域名github下的二级域名：username.github.io，为了提升访问速度和博客的格调，绑定个人域名是多数人的选择。下面给大家介绍详细过程。 购买域名 国内有很多不错的域名服务商，这里我给大家推荐阿里云的万网。我购买的域名是：tsundere-x.top。 大家可以根据自身的需求购买相应的域名。点击查域名后确认域名没有被使用后即可下单购买，当然在付款之前你还需要进行邮箱验证和实名认证（虽然上面提示实名认证需要3-5天，但正常情况下其实只要一个小时左右）。 实名认证通过后进行域名解析 在此之前需要获取自己 github 的二级域名的 IP地址 。cmd下ping+自己博客的地址即可获得。 实名认证后来到域名控制台，点击解析。 进入新手指导，将得到的 IP 地址填到记录值一栏 即可。 仓库的custom domain绑定域名 进入仓库中， 点击 setting 往下滑 会看到custom domain 将自己购买的域名填写进去 。 最后一步，设置CNAME 进入Hexo根目录下的source文件夹，新建CNAME文件（文件！！！，不需要任何后缀）。 接下来 使用 hexo d -g 重新部署，就可以成功访问咯！]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程知识点（一）]]></title>
    <url>%2F2019%2F10%2F05%2F%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%E3%80%81Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1 程序、进程、线程之间的区别与联系 三者之间的形象化理解： * 程序：代码实现了功能，就是程序，是静态的； * 进程：执行中的程序就是进程，是动态的； * 线程：进程内的一个执行单元,也是进程内的可调度实体，可以并发执行提高了进程的效率。 进程和线程的关系：（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。（3）处理机分给线程，即真正在处理机上运行的是线程。（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。 线程与进程的区别: (1) 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 。 (2) 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 。 (3) 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。 (4) 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。 程序与进程的区别：程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。 程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。 进程更能真实地描述并发，而程序不能；进程是由程序和数据两部分组成的。进程具有创建其他进程的功能，而程序没有。 同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程。也就是说同一程序可以对应多个进程。 2 Java的线程状态和生命周期) ==新建状态:==使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。 ==就绪状态:==当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。 ==运行状态:==如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。 ==阻塞状态:==如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 其他阻塞：通过调用线程的 sleep() 或join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O处理完毕，线程重新转入就绪状态。 ==死亡状态:==一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中this和super的用法总结]]></title>
    <url>%2F2019%2F10%2F04%2FJava%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[this this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this 的用法在 Java 中大体可以分为3种： 1.普通的直接引用 this 相当于是指向当前对象本身。 2.形参与成员名字重名，用 this 来区分：123456789101112131415161718class Person &#123; private int age = 10; public Person()&#123; System.out.println("初始化年龄："+age);&#125; public int GetAge(int age)&#123; this.age = age; return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println("Harry's age is "+Harry.GetAge(12)); &#125;&#125; 运行结果： 1初始化年龄：10 Harry&apos;s age is 12 可以看到，这里 age 是 GetAge 成员方法的形参，this.age 是 Person 类的成员变量。 3.引用构造函数supersuper 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super 也有三种用法： 1.普通的直接引用与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员。 2.子类中的成员变量或方法与父类中的成员变量或方法同名123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = "China"; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = "Shanghai"; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 运行结果： 1Shanghai China 可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法 value()，只调用父类变量 name 的话，则父类 name 值为默认值 null。 3.引用构造函数 super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 123456789101112131415161718192021222324252627282930313233343536class Person &#123; public static void prt(String s) &#123; System.out.println(s); &#125; Person() &#123; prt("父类·无参数构造方法： "+"A Person."); &#125;//构造方法(1) Person(String name) &#123; prt("父类·含一个参数的构造方法： "+"A person's name is " + name); &#125;//构造方法(2) &#125; public class Chinese extends Person &#123; Chinese() &#123; super(); // 调用父类构造方法（1） prt("子类·调用父类"无参数构造方法"： "+"A chinese coder."); &#125; Chinese(String name) &#123; super(name);// 调用父类具有相同形参的构造方法（2） prt("子类·调用父类"含一个参数的构造方法"： "+"his name is " + name); &#125; Chinese(String name, int age) &#123; this(name);// 调用具有相同形参的构造方法（3） prt("子类：调用子类具有相同形参的构造方法：his age is " + age); &#125; public static void main(String[] args) &#123; Chinese cn = new Chinese(); cn = new Chinese("codersai"); cn = new Chinese("codersai", 18); &#125; &#125; 运行结果： 1234567父类·无参数构造方法： A Person.子类·调用父类”无参数构造方法“： A chinese coder.父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai父类·含一个参数的构造方法： A person&apos;s name is codersai子类·调用父类”含一个参数的构造方法“： his name is codersai子类：调用子类具有相同形参的构造方法：his age is 18 从本例可以看到，可以用 super 和 this 分别调用父类的构造方法和本类中其他形式的构造方法。 例子中 Chinese 类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。 ==super 和 this 的异同== super(参数)：调用基类中的某一个构造函数（应该为构造函数中的第一条语句） this(参数)：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句） super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名） 调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。 super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。 super() 和 this() 均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static 方法，static 语句块。 从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>后端</tag>
      </tags>
  </entry>
</search>
