<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tsundere_x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1979F.github.io/"/>
  <updated>2019-10-07T13:31:11.401Z</updated>
  <id>http://1979F.github.io/</id>
  
  <author>
    <name>XIAO_JING</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java线程知识点（二）线程的构造和运行</title>
    <link href="http://1979F.github.io/2019/10/07/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C/"/>
    <id>http://1979F.github.io/2019/10/07/线程知识点（二）—— 线程的构造和运行/</id>
    <published>2019-10-07T13:29:22.000Z</published>
    <updated>2019-10-07T13:31:11.401Z</updated>
    
    <content type="html"><![CDATA[<p><strong>① 用Thread类构造线程对象</strong>（继承Thread类来创建并启动多线程）<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.sxt.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程方式一：</span></span><br><span class="line"><span class="comment"> * 1、创建：继承Thread+重写run</span></span><br><span class="line"><span class="comment"> * 2、启动：创建子类对象+start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 1979</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程入口点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"一边听歌"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程</span></span><br><span class="line"><span class="comment"> * for(int i=0;i&lt;20;i++) &#123;</span></span><br><span class="line"><span class="comment"> *  System.out.println("一边coding");</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类对象</span></span><br><span class="line">StartThread st = <span class="keyword">new</span> StartThread();</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">st.start();<span class="comment">//不保证立即运行   由cpu调用</span></span><br><span class="line"><span class="comment">//st.run();//普通方法调用，只能听完歌再敲代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"一边coding"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【运行结果】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一边coding</span><br><span class="line">一边coding</span><br><span class="line">...</span><br><span class="line">一边听歌</span><br><span class="line">一边听歌</span><br><span class="line">...</span><br><span class="line">一边coding</span><br><span class="line">一边coding</span><br></pre></td></tr></table></figure><p><strong>【缺点】</strong>：<u>由于java采用单继承机制，若为实现多线程而继承了Thread，将无法再继承其他类，是非常不明智的做法。</u></p><p><strong>② 用Runnable辅助构造线程</strong>（实现Runnable接口创建线程类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package cn.sxt.thread;</span><br><span class="line"></span><br><span class="line">/***</span><br><span class="line"> * 创建线程方式二</span><br><span class="line"> * 1、创建：实现Runnable+重写run</span><br><span class="line"> * 2、启动：创建实现类对象+Thread对象+start</span><br><span class="line"> * </span><br><span class="line"> * 推荐：避免单继承的局限性，优先使用接口</span><br><span class="line"> * 方便共享资源</span><br><span class="line"> * @author 1979</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class StartRun implements Runnable&#123;</span><br><span class="line">/**</span><br><span class="line"> * 线程入口点</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int i=0;i&lt;20;i++) &#123;</span><br><span class="line">System.out.println(&quot;一边听歌&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">/* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程</span><br><span class="line"> * for(int i=0;i&lt;20;i++) &#123;</span><br><span class="line"> *  System.out.println(&quot;一边coding&quot;);</span><br><span class="line"> *   &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//创建实现类对象</span><br><span class="line">StartRun sr = new StartRun();</span><br><span class="line">//创建代理类对象</span><br><span class="line">Thread t = new Thread(sr);</span><br><span class="line">//启动</span><br><span class="line">t.start();//不保证立即运行   由cpu调用</span><br><span class="line">//st.run();//普通方法调用，只能听完歌再敲代码</span><br><span class="line">for(int i=0;i&lt;20;i++) &#123;</span><br><span class="line">System.out.println(&quot;一边coding&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【运行结果】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一边coding</span><br><span class="line">一边coding</span><br><span class="line">...</span><br><span class="line">一边听歌</span><br><span class="line">一边听歌</span><br><span class="line">...</span><br><span class="line">一边coding</span><br><span class="line">一边coding</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> liti_07;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本例展现这样一种方式：利用Runnable接口直接构造线程并运行</span></span><br><span class="line"><span class="comment"> *有如下关键点：</span></span><br><span class="line"><span class="comment"> *1、希望该类中创建线程对象，就必须有线程成员，即私有变量t;</span></span><br><span class="line"><span class="comment"> *2、在构造函数中构造t引用的线程对象，注意把自己作为参数传给t;</span></span><br><span class="line"><span class="comment"> *3、还需要启动线程。由于t长设为私有，故不能直接t.start()，</span></span><br><span class="line"><span class="comment"> *      需要设置其他方法，如本例另提供一个公共的start()方法。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ch_7_3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"Main 开始"</span>);</span><br><span class="line">Ch_7_3 m1=<span class="keyword">new</span> Ch_7_3(<span class="number">1</span>,<span class="string">"奇数线程"</span>);  <span class="comment">//注意，m1依旧不是线程对象</span></span><br><span class="line">Ch_7_3 m2=<span class="keyword">new</span> Ch_7_3(<span class="number">2</span>,<span class="string">"偶数线程"</span>);</span><br><span class="line">m1.start();                 <span class="comment">//注意，调用的是类R自己定义的start()</span></span><br><span class="line">m2.start();</span><br><span class="line">System.out.print(<span class="string">"当前共有"</span>+ Thread.activeCount()+<span class="string">"个线程"</span>);</span><br><span class="line">System.out.print(<span class="string">"Main 结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> d;</span><br><span class="line"><span class="keyword">private</span> Thread t;                   <span class="comment">//-----新增成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123; </span><br><span class="line">t.start(); </span><br><span class="line">&#125;        <span class="comment">//-----关键点2 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ch_7_3</span><span class="params">(<span class="keyword">int</span> x, String s)</span></span>&#123;</span><br><span class="line">d=x;</span><br><span class="line"><span class="comment">//t=new Thread(this); t.setName(s);  //----关键点1</span></span><br><span class="line">t=<span class="keyword">new</span> Thread(<span class="keyword">this</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=d; i&lt;<span class="number">50</span>;i=i+<span class="number">2</span>)</span><br><span class="line">System.out.print(<span class="string">" "</span>+i);</span><br><span class="line"><span class="comment">//Thread t=Thread.currentThread();  //---此句不再需要</span></span><br><span class="line">System.out.print(t.getName()+<span class="string">"结束！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>线程的一些常用方法</strong></p><p> 1、<code>currentThread()</code></p><p>返回对当前正在执行的线程对象的引用。</p><p> 2、<code>getId()</code></p><p>返回此线程的标识符</p><p> 3、<code>getName()</code></p><p>返回此线程的名称</p><p> 4、<code>getPriority()</code></p><p>返回此线程的优先级</p><p> 5、<code>isAlive()</code></p><p>测试这个线程是否还处于活动状态。</p><p>什么是活动状态呢？</p><p>活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。</p><p> 6、<code>sleep(long millis)</code></p><p>使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。</p><p> 7、<code>interrupt()</code></p><p>中断这个线程。</p><p> 8、<code>interrupted() 和isInterrupted()</code></p><p>interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能</p><p>isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但不清楚状态标志</p><p> 9、 <code>setName(String name)</code></p><p>将此线程的名称更改为等于参数 name 。</p><p> 10、<code>isDaemon()</code></p><p>测试这个线程是否是守护线程。</p><p> 11、<code>setDaemon(boolean on)</code></p><p>将此线程标记为 daemon线程或用户线程。</p><p> 12、<code>join()</code></p><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><p>join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行</p><p> 13、<code>yield()</code></p><p>yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。</p><p> 14、<code>setPriority(int newPriority)</code></p><p>更改此线程的优先级</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;① 用Thread类构造线程对象&lt;/strong&gt;（继承Thread类来创建并启动多线程）
    
    </summary>
    
    
    
      <category term="Java" scheme="http://1979F.github.io/tags/Java/"/>
    
      <category term="后端" scheme="http://1979F.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>3分钟教你Hexo如何绑定个人域名</title>
    <link href="http://1979F.github.io/2019/10/06/Hexo%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/"/>
    <id>http://1979F.github.io/2019/10/06/Hexo如何绑定个人域名/</id>
    <published>2019-10-06T02:47:48.000Z</published>
    <updated>2019-10-06T08:12:22.992Z</updated>
    
    <content type="html"><![CDATA[<p>前两天用Hexo+GitHub搭建好了自己的个人博客<a href="http://tsundere-x.top/" target="_blank" rel="noopener">http://tsundere-x.top/</a> ，默认域名github下的二级域名：username.github.io，为了提升访问速度和博客的格调，绑定个人域名是多数人的选择。下面给大家介绍详细过程。<a id="more"></a></p><p><strong>购买域名</strong></p><p>国内有很多不错的域名服务商，这里我给大家推荐阿里云的<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>。我购买的域名是：<a href="http://tsundere-x.top/" target="_blank" rel="noopener">tsundere-x.top</a>。</p><p>大家可以根据自身的需求购买相应的域名。点击查域名后确认域名没有被使用后即可下单购买，当然在付款之前你还需要进行邮箱验证和实名认证（虽然上面提示实名认证需要3-5天，但正常情况下其实只要一个小时左右）。<br><img src="https://img-blog.csdnimg.cn/20191006103725534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>实名认证通过后进行域名解析</strong></p><p>在此之前需要获取自己 github 的二级域名的 IP地址 。cmd下ping+自己博客的地址即可获得。<br><img src="https://img-blog.csdnimg.cn/20191006103834723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>实名认证后来到域名控制台，点击解析。<br><img src="https://img-blog.csdnimg.cn/2019100610390655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>进入新手指导，将得到的 IP 地址填到记录值一栏 即可。<br><img src="https://img-blog.csdnimg.cn/20191006103924178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>仓库的custom domain绑定域名</strong></p><p>进入仓库中， 点击  setting 往下滑 会看到<strong>custom domain</strong>  将自己购买的域名填写进去 。<br><img src="https://img-blog.csdnimg.cn/20191006103951330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>最后一步，设置CNAME</strong></p><p>进入Hexo根目录下的<code>source</code>文件夹，新建CNAME文件（文件！！！，不需要任何后缀）。<br><img src="https://img-blog.csdnimg.cn/20191006104030127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>接下来 使用 <code>hexo d -g</code> 重新部署，就可以成功访问咯！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天用Hexo+GitHub搭建好了自己的个人博客&lt;a href=&quot;http://tsundere-x.top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://tsundere-x.top/&lt;/a&gt; ，默认域名github下的二级域名：username.github.io，为了提升访问速度和博客的格调，绑定个人域名是多数人的选择。下面给大家介绍详细过程。
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://1979F.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java线程知识点（一）</title>
    <link href="http://1979F.github.io/2019/10/05/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%E3%80%81Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://1979F.github.io/2019/10/05/线程知识点（一）—— 程序、进程、线程之间的区别与联系、Java的线程状态和生命周期/</id>
    <published>2019-10-04T16:30:22.000Z</published>
    <updated>2019-10-06T08:13:17.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-程序、进程、线程之间的区别与联系"><a href="#1-程序、进程、线程之间的区别与联系" class="headerlink" title="1  程序、进程、线程之间的区别与联系"></a>1  程序、进程、线程之间的区别与联系</h3><p>  三者之间的形象化理解：<br>    * 程序：代码实现了功能，就是程序，是静态的；<br>    * 进程：执行中的程序就是进程，是动态的；<br>     * 线程：进程内的一个执行单元,也是进程内的可调度实体，可以并发执行提高了进程的效率。</p><a id="more"></a><p><strong><em>进程和线程的关系：</em></strong><br>（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。<br>（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。<br>（3）处理机分给线程，即真正在处理机上运行的是线程。<br>（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p><strong><em>线程与进程的区别:</em></strong><br>  (1)  调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 。<br>  (2)  并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 。<br>  (3)  拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。<br>  (4)  系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><p><strong><em>程序与进程的区别：</em></strong><br>程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。 </p><p>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。 </p><p>进程更能真实地描述并发，而程序不能；进程是由程序和数据两部分组成的。进程具有创建其他进程的功能，而程序没有。 </p><p>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程。也就是说同一程序可以对应多个进程。</p><h3 id="2-Java的线程状态和生命周期"><a href="#2-Java的线程状态和生命周期" class="headerlink" title="2  Java的线程状态和生命周期"></a>2  Java的线程状态和生命周期</h3><p><img src="https://img-blog.csdnimg.cn/20191005001816162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODE2NTU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20191005001825156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODE2NTU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>==<strong>新建状态:</strong>==<br>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p><p>==<strong>就绪状态:</strong>==<br>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p><p>==<strong>运行状态:</strong>==<br>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><p>==<strong>阻塞状态:</strong>==<br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ol><li><em>等待阻塞</em>：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li><em>同步阻塞</em>：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 </li><li><em>其他阻塞</em>：通过调用线程的 sleep() 或join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O处理完毕，线程重新转入就绪状态。</li></ol><p>==<strong>死亡状态:</strong>==<br>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-程序、进程、线程之间的区别与联系&quot;&gt;&lt;a href=&quot;#1-程序、进程、线程之间的区别与联系&quot; class=&quot;headerlink&quot; title=&quot;1  程序、进程、线程之间的区别与联系&quot;&gt;&lt;/a&gt;1  程序、进程、线程之间的区别与联系&lt;/h3&gt;&lt;p&gt;  三者之间的形象化理解：&lt;br&gt;    * 程序：代码实现了功能，就是程序，是静态的；&lt;br&gt;    * 进程：执行中的程序就是进程，是动态的；&lt;br&gt;     * 线程：进程内的一个执行单元,也是进程内的可调度实体，可以并发执行提高了进程的效率。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://1979F.github.io/tags/Java/"/>
    
      <category term="后端" scheme="http://1979F.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java中this和super的用法总结</title>
    <link href="http://1979F.github.io/2019/10/04/Java%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://1979F.github.io/2019/10/04/Java中this和super的用法总结/</id>
    <published>2019-10-04T14:50:22.000Z</published>
    <updated>2019-10-06T08:12:50.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li><p>this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p></li><li><p>this 的用法在 Java 中大体可以分为3种：</p></li></ul><h5 id="1-普通的直接引用"><a href="#1-普通的直接引用" class="headerlink" title="1.普通的直接引用"></a>1.普通的直接引用</h5><p>   this 相当于是指向当前对象本身。<a id="more"></a></p><h5 id="2-形参与成员名字重名，用-this-来区分："><a href="#2-形参与成员名字重名，用-this-来区分：" class="headerlink" title="2.形参与成员名字重名，用 this 来区分："></a>2.形参与成员名字重名，用 this 来区分：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"初始化年龄："</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person Harry = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">"Harry's age is "</span>+Harry.GetAge(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>运行结果：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化年龄：10 Harry&apos;s age is 12</span><br></pre></td></tr></table></figure><p>可以看到，这里 age 是 GetAge 成员方法的形参，this.age 是 Person 类的成员变量。</p><h5 id="3-引用构造函数"><a href="#3-引用构造函数" class="headerlink" title="3.引用构造函数"></a>3.引用构造函数</h5><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p>super 也有三种用法：</p><h5 id="1-普通的直接引用-1"><a href="#1-普通的直接引用-1" class="headerlink" title="1.普通的直接引用"></a>1.普通的直接引用</h5><p>与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员。</p><h5 id="2-子类中的成员变量或方法与父类中的成员变量或方法同名"><a href="#2-子类中的成员变量或方法与父类中的成员变量或方法同名" class="headerlink" title="2.子类中的成员变量或方法与父类中的成员变量或方法同名"></a>2.子类中的成员变量或方法与父类中的成员变量或方法同名</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       name = <span class="string">"China"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">extends</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    name = <span class="string">"Shanghai"</span>;</span><br><span class="line">    <span class="keyword">super</span>.value();      <span class="comment">//调用父类的方法</span></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(<span class="keyword">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       City c=<span class="keyword">new</span> City();</span><br><span class="line">       c.value();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>运行结果：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shanghai China</span><br></pre></td></tr></table></figure><p>可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法 value()，只调用父类变量 name 的话，则父类 name 值为默认值 null。</p><h5 id="3-引用构造函数-1"><a href="#3-引用构造函数-1" class="headerlink" title="3.引用构造函数"></a>3.引用构造函数</h5><ul><li><p>super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p></li><li><p>this(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">       System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    Person() &#123; </span><br><span class="line">       prt(<span class="string">"父类·无参数构造方法： "</span>+<span class="string">"A Person."</span>); </span><br><span class="line">    &#125;<span class="comment">//构造方法(1) </span></span><br><span class="line">    </span><br><span class="line">    Person(String name) &#123; </span><br><span class="line">       prt(<span class="string">"父类·含一个参数的构造方法： "</span>+<span class="string">"A person's name is "</span> + name); </span><br><span class="line">    &#125;<span class="comment">//构造方法(2) </span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    Chinese() &#123; </span><br><span class="line">       <span class="keyword">super</span>(); <span class="comment">// 调用父类构造方法（1） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类"</span>无参数构造方法<span class="string">"： "</span>+<span class="string">"A chinese coder."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name) &#123; </span><br><span class="line">       <span class="keyword">super</span>(name);<span class="comment">// 调用父类具有相同形参的构造方法（2） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类"</span>含一个参数的构造方法<span class="string">"： "</span>+<span class="string">"his name is "</span> + name); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name, <span class="keyword">int</span> age) &#123; </span><br><span class="line">       <span class="keyword">this</span>(name);<span class="comment">// 调用具有相同形参的构造方法（3） </span></span><br><span class="line">       prt(<span class="string">"子类：调用子类具有相同形参的构造方法：his age is "</span> + age); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       Chinese cn = <span class="keyword">new</span> Chinese(); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>, <span class="number">18</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>运行结果：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">父类·无参数构造方法： A Person.</span><br><span class="line">子类·调用父类”无参数构造方法“： A chinese coder.</span><br><span class="line">父类·含一个参数的构造方法： A person&apos;s name is codersai</span><br><span class="line">子类·调用父类”含一个参数的构造方法“： his name is codersai</span><br><span class="line">父类·含一个参数的构造方法： A person&apos;s name is codersai</span><br><span class="line">子类·调用父类”含一个参数的构造方法“： his name is codersai</span><br><span class="line">子类：调用子类具有相同形参的构造方法：his age is 18</span><br></pre></td></tr></table></figure><p>从本例可以看到，可以用 super 和 this 分别调用父类的构造方法和本类中其他形式的构造方法。</p><p>例子中 Chinese 类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。</p><p>==<strong>super 和 this 的异同</strong>==</p><ul><li>super(参数)：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）</li><li>this(参数)：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li><li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名）</li><li>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li><li>super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。</li><li>super() 和 this() 均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static 方法，static 语句块。</li><li>从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;this 的用法在 Java 中大体可以分为3种：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;1-普通的直接引用&quot;&gt;&lt;a href=&quot;#1-普通的直接引用&quot; class=&quot;headerlink&quot; title=&quot;1.普通的直接引用&quot;&gt;&lt;/a&gt;1.普通的直接引用&lt;/h5&gt;&lt;p&gt;   this 相当于是指向当前对象本身。
    
    </summary>
    
    
    
      <category term="Java" scheme="http://1979F.github.io/tags/Java/"/>
    
      <category term="后端" scheme="http://1979F.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
</feed>
