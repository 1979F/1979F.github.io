<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Serendipper-x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1979F.github.io/"/>
  <updated>2021-03-10T08:53:46.299Z</updated>
  <id>http://1979F.github.io/</id>
  
  <author>
    <name>XIAO_JING</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【操作系统复习】中断和异常</title>
    <link href="http://1979F.github.io/2021/03/10/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <id>http://1979F.github.io/2021/03/10/【操作系统复习】中断和异常/</id>
    <published>2021-03-10T04:00:38.000Z</published>
    <updated>2021-03-10T08:53:46.299Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、中断机制的诞生"><a href="#一、中断机制的诞生" class="headerlink" title="一、中断机制的诞生"></a>一、中断机制的诞生</h2><p>早期的计算机：各程序只能串行执行，系统资源利用率低</p><p>为了解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。</p><p><strong>本质</strong>：发生中断就意味着需要操作系统介入，开展工作。</p><h2 id="二、中断的概念和作用"><a href="#二、中断的概念和作用" class="headerlink" title="二、中断的概念和作用"></a>二、中断的概念和作用</h2><p>1、当中断发生时，CPU立即进入核心态</p><p>2、当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</p><a id="more"></a><p>3、对于不同的中断信号，会进行不同的处理</p><p>由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。<code>中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权</code>。有了中断，才能实现多道程序并发执行。</p><p>用户态、核心态之间的切换是怎么实现的？</p><ul><li><p>“ 用户态 –&gt; 核心态 ” 是通过中断实现，并且中断是==唯一==途径。</p></li><li><p>“ 核心态 –&gt; 用户态 ” 的切换是通过执行一个特权指令，将程序状态字（PSW）的标志位设置为用户态。</p></li></ul><h2 id="三、中断的分类"><a href="#三、中断的分类" class="headerlink" title="三、中断的分类"></a>三、中断的分类</h2><p><img src="https://img-blog.csdnimg.cn/20210310120021965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、外中断的处理过程"><a href="#四、外中断的处理过程" class="headerlink" title="四、外中断的处理过程"></a>四、外中断的处理过程</h2><p>1、执行完每个指令之后，CPU都要检查当前是否有外部中断信号</p><p>2、如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器）</p><p>3、根据中断信号类型转入相应的中断处理程序</p><p>4、恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</p><p>的CPU环境并退出中断，返回原进程继续往下执行</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、中断机制的诞生&quot;&gt;&lt;a href=&quot;#一、中断机制的诞生&quot; class=&quot;headerlink&quot; title=&quot;一、中断机制的诞生&quot;&gt;&lt;/a&gt;一、中断机制的诞生&lt;/h2&gt;&lt;p&gt;早期的计算机：各程序只能串行执行，系统资源利用率低&lt;/p&gt;&lt;p&gt;为了解决上述问题，人们发明了操作系统（作为计算机的管理者），引入中断机制，实现了多道程序并发执行。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;本质&lt;/strong&gt;：发生中断就意味着需要操作系统介入，开展工作。&lt;/p&gt;&lt;h2 id=&quot;二、中断的概念和作用&quot;&gt;&lt;a href=&quot;#二、中断的概念和作用&quot; class=&quot;headerlink&quot; title=&quot;二、中断的概念和作用&quot;&gt;&lt;/a&gt;二、中断的概念和作用&lt;/h2&gt;&lt;p&gt;1、当中断发生时，CPU立即进入核心态&lt;/p&gt;&lt;p&gt;2、当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://1979F.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>牛客 16499 解方程 （数学、Python）</title>
    <link href="http://1979F.github.io/2021/03/09/%E7%89%9B%E5%AE%A2%2016499%20%E8%A7%A3%E6%96%B9%E7%A8%8B%20%EF%BC%88%E6%95%B0%E5%AD%A6%E3%80%81Python%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/03/09/牛客 16499 解方程 （数学、Python）/</id>
    <published>2021-03-09T13:58:41.000Z</published>
    <updated>2021-03-10T08:26:14.353Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/16499" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/16499</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>已知多项式方程：<br>a0+a1x+a2x^2^+…+anx^n^=0<br>求这个方程在[1, m]内的整数解（n和m均为正整数）。</p><a id="more"></a><p><strong>输入描述:</strong></p><p>第一行包含2个整数n、m，每两个整数之间用一个空格隔开。<br>接下来的n+1行每行包含一个整数，依次为a0,a1,a2,……,an。</p><p><strong>输出描述:</strong></p><p>第一行输出方程在[1, m]内的整数解的个数。<br>接下来每行一个整数，按照从小到大的顺序依次输出方程在[1, m]内的一个整数解。</p><p>枚举1~m中的所有整数，代入多项式，判断值是否为0</p><p>求一元n次多项式可以用到<code>秦九韶算法</code><br><img src="https://img-blog.csdnimg.cn/20210309215601249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但还是会超时，只能得70分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">n, m = list(map(int, input().split()))</span><br><span class="line">a = []</span><br><span class="line">mod = <span class="number">1000000007</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (n+<span class="number">1</span>):</span><br><span class="line">    a.append(int(input())%mod)</span><br><span class="line"></span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">    ans = a[n]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range (n<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        ans = (ans*i + a[j])%mod</span><br><span class="line">    <span class="keyword">if</span> ans == <span class="number">0</span>:</span><br><span class="line">        res.append(i)</span><br><span class="line">print(len(res))</span><br><span class="line">res.sort()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16499&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/16499&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;已知多项式方程：&lt;br&gt;a0+a1x+a2x^2^+…+anx^n^=0&lt;br&gt;求这个方程在[1, m]内的整数解（n和m均为正整数）。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客 13822 Keep In Line（枚举与暴力、Python）</title>
    <link href="http://1979F.github.io/2021/03/09/%E7%89%9B%E5%AE%A2%2013822%20Keep%20In%20Line%EF%BC%88%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%9A%B4%E5%8A%9B%E3%80%81Python%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/03/09/牛客 13822 Keep In Line（枚举与暴力、Python）/</id>
    <published>2021-03-09T12:29:34.000Z</published>
    <updated>2021-03-10T08:30:22.183Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/13822" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/13822</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>又到饭点了，SK同学靠着惯性走到了食堂，但长长的队伍顿时让他失去了食欲。突然，他注意到某个窗口前的队伍里明显存在插队的现象，于是他默默记录下了同学们进队和出队的变化。<br>对于进队，SK同学只知道队伍里多了一个人，并不知道新来的人是老老实实站到了队尾还是插到了队伍里的某个位置；对于出队，SK同学能确定是队伍里站在最前面的人出队了。<br>初始时队伍为空，给出n条队伍进出的信息，保证已经出队的同学不会再入队，并且最终队伍也为空，现在SK同学想知道有多少不插队的好同学。</p><a id="more"></a><p><strong>输入描述:</strong></p><p>第一行是一个正整数T(≤ 5)，表示测试数据的组数， 对于每组测试数据， 第一行是一个整数n(1≤ n ≤ 100000)，表示这个队伍进出的信息数， 接下来n行，每行是两个字符串Opt Name，其中Opt为”in”代表进队，”out”代表出队，Name为进队或出队的人的名字， 所有信息按照时间顺序给出，名字由英文字母和阿拉伯数字组成，长度不超过10，保证每个人的名字各不相同。</p><p><strong>输出描述:</strong></p><p>对于每组测试数据，输出一行，包含一个整数，表示不插队的人数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例1</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">in quailty</span><br><span class="line">in hwq1352249</span><br><span class="line">out hwq1352249</span><br><span class="line">in zhuaiballl</span><br><span class="line">out quailty</span><br><span class="line">out zhuaiballl</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先建一个队列，里面按照入队顺序存放字符串。</span><br><span class="line">然后等读入出队信息的时候，如果出队是正常出队，ans++，就直接删除队首元素，</span><br><span class="line">如果不是正常出队，并利用map标记此字符串为1，遇到队首元素标记为1的直接出队。</span><br><span class="line">最后输出ans。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">T = int(input())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(T):</span><br><span class="line">    n = int(input())</span><br><span class="line">    queue = []</span><br><span class="line">    jumpers = &#123;&#125;</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">        s = input().split(<span class="string">" "</span>)</span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'in'</span>:</span><br><span class="line">            queue.append(s[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> queue[<span class="number">0</span>] <span class="keyword">in</span> jumpers:</span><br><span class="line">                <span class="keyword">del</span> queue[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> queue[<span class="number">0</span>] != s[<span class="number">1</span>]:</span><br><span class="line">                jumpers[s[<span class="number">1</span>]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">del</span> queue[<span class="number">0</span>]</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">    print(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13822&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/13822&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;又到饭点了，SK同学靠着惯性走到了食堂，但长长的队伍顿时让他失去了食欲。突然，他注意到某个窗口前的队伍里明显存在插队的现象，于是他默默记录下了同学们进队和出队的变化。&lt;br&gt;对于进队，SK同学只知道队伍里多了一个人，并不知道新来的人是老老实实站到了队尾还是插到了队伍里的某个位置；对于出队，SK同学能确定是队伍里站在最前面的人出队了。&lt;br&gt;初始时队伍为空，给出n条队伍进出的信息，保证已经出队的同学不会再入队，并且最终队伍也为空，现在SK同学想知道有多少不插队的好同学。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客 21302 被3整除的子序列 （动态规划、Python）</title>
    <link href="http://1979F.github.io/2021/03/09/%E7%89%9B%E5%AE%A2%2021302%20%E8%A2%AB3%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%20%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%81Python%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/03/09/牛客 21302 被3整除的子序列 （动态规划、Python）/</id>
    <published>2021-03-09T09:27:08.000Z</published>
    <updated>2021-03-10T08:32:45.497Z</updated>
    
    <content type="html"><![CDATA[<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 524288K，其他语言1048576K<br>64bit IO Format: %lld<br>链接：<a href="https://ac.nowcoder.com/acm/problem/21302" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/21302</a><br>来源：牛客网</p><p><strong>题目描述</strong> </p><p>给你一个长度为50的数字串,问你有多少个子序列构成的数字可以被3整除<br>答案对1e9+7取模</p><a id="more"></a><p><strong>输入描述:</strong></p><p>输入一个字符串，由数字构成，长度小于等于50</p><p><strong>输出描述:</strong></p><p>输出一个整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入</span><br><span class="line">132</span><br><span class="line">输出</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入</span><br><span class="line">9</span><br><span class="line">输出</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">示例3</span><br><span class="line">输入</span><br><span class="line">333</span><br><span class="line">输出</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">示例4</span><br><span class="line">输入</span><br><span class="line">123456</span><br><span class="line">输出</span><br><span class="line">23</span><br><span class="line"></span><br><span class="line">示例5</span><br><span class="line">输入</span><br><span class="line">00</span><br><span class="line">输出</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">备注:</span><br><span class="line">n为长度</span><br><span class="line">子任务1: n &lt;= 5</span><br><span class="line">子任务2: n &lt;= 20</span><br><span class="line">子任务3: 无限制</span><br></pre></td></tr></table></figure><p>动态转移方程为：</p><p><code>dp[i][j] += (dp[i-1][j] + dp[i-1][(j+3-m)%3]) % mod</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = input()</span><br><span class="line"></span><br><span class="line">mod = <span class="number">1000000007</span></span><br><span class="line">dp = [[<span class="number">0</span>] * <span class="number">3</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range (<span class="number">51</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">1</span>, len(s)+<span class="number">1</span>):</span><br><span class="line">    m = int(s[i<span class="number">-1</span>])%<span class="number">3</span></span><br><span class="line">    dp[i][m] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range (<span class="number">3</span>):</span><br><span class="line">        dp[i][j] += (dp[i<span class="number">-1</span>][j] + dp[i<span class="number">-1</span>][(j+<span class="number">3</span>-m)%<span class="number">3</span>]) % mod</span><br><span class="line">print(dp[len(s)][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 524288K，其他语言1048576K&lt;br&gt;64bit IO Format: %lld&lt;br&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/21302&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/21302&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;给你一个长度为50的数字串,问你有多少个子序列构成的数字可以被3整除&lt;br&gt;答案对1e9+7取模&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 670 最大交换 （暴力+贪心、Python）</title>
    <link href="http://1979F.github.io/2021/03/09/LeetCode%20670%20%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2%20%EF%BC%88%E6%9A%B4%E5%8A%9B+%E8%B4%AA%E5%BF%83%E3%80%81Python%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/03/09/LeetCode 670 最大交换 （暴力+贪心、Python）/</id>
    <published>2021-03-09T01:54:58.000Z</published>
    <updated>2021-03-10T08:34:05.613Z</updated>
    
    <content type="html"><![CDATA[<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/maximum-swap" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-swap</a></p><p><strong>问题描述</strong></p><p>给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1 :</span><br><span class="line"></span><br><span class="line">输入: 2736</span><br><span class="line">输出: 7236</span><br><span class="line">解释: 交换数字2和数字7。</span><br><span class="line"></span><br><span class="line">示例 2 :</span><br><span class="line"></span><br><span class="line">输入: 9973</span><br><span class="line">输出: 9973</span><br><span class="line">解释: 不需要交换。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">给定数字的范围是 [0, 108]</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>方法一：暴力法</strong></p><p>两重循环，每次交换两个相邻的数，取最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">T = int(input())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (T):</span><br><span class="line">    res = <span class="string">""</span></span><br><span class="line">    a = input()</span><br><span class="line">    res = int(a)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (len(a)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range (i+<span class="number">1</span>, len(a)):</span><br><span class="line">                b = list(a)</span><br><span class="line">                b[i], b[j] = b[j], b[i]</span><br><span class="line">                m = int(<span class="string">''</span>.join(b))</span><br><span class="line">                res = max(res, m)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure><p><strong>方法二：贪心算法</strong></p><ul><li>我们将计算 last[d] = i，最后一次出现的数字 d（如果存在）的索引i。</li><li>然后，从左到右扫描数字时，如果将来有较大的数字，我们将用最大的数字交换；如果有多个这样的数字，我们将用最开始遇到的数字交换。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">T = int(input())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fu</span><span class="params">(a)</span>:</span></span><br><span class="line">    t = list(a)</span><br><span class="line">    pos = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range (<span class="number">10</span>)]</span><br><span class="line">    <span class="comment"># 记录每个数字出现的最后一次出现的下标</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (len(a)):</span><br><span class="line">        pos[int(a[i])] = i</span><br><span class="line">    <span class="comment"># 从左向右扫描，找到当前位置右边的最大的数字并交换</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (len(a)<span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># 找最大，所以倒着找</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range (<span class="number">9</span>, int(t[i]), <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> pos[j] &gt; i:</span><br><span class="line">                t[pos[j]], t[i] = t[i], t[pos[j]]</span><br><span class="line">                <span class="comment"># 只允许交换一次，因此直接返回</span></span><br><span class="line">                <span class="keyword">return</span> int(<span class="string">''</span>.join(t))</span><br><span class="line">    <span class="keyword">return</span> a  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> range (T):</span><br><span class="line">    a = input()</span><br><span class="line">    res = fu(a)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-swap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximum-swap&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 2736&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 7236&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 交换数字2和数字7。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例 2 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: 9973&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 9973&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 不需要交换。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;给定数字的范围是 [0, 108]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统复习】操作系统的运行机制与体系结构</title>
    <link href="http://1979F.github.io/2021/03/08/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://1979F.github.io/2021/03/08/【操作系统复习】操作系统的运行机制与体系结构/</id>
    <published>2021-03-08T13:59:33.000Z</published>
    <updated>2021-03-10T08:54:23.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、两种指令、两种处理器状态、两种程序"><a href="#一、两种指令、两种处理器状态、两种程序" class="headerlink" title="一、两种指令、两种处理器状态、两种程序"></a>一、两种指令、两种处理器状态、两种程序</h2><p> ” <strong>指令</strong> ” 就是处理器（CPU）能识别、执行的最基本命令</p><ul><li><p><strong>特权指令：</strong> 如内存清零指令 –&gt; 不允许用户程序使用。</p></li><li><p><strong>非特权指令：</strong> 如普通的运算指令</p><p>CPU如何判断当前是否可以执行特权指令？</p></li></ul><p>用程序状态寄存器（PSW）中的某标志位来标识当前处理器处于什么状态，如0为用户态，1为核心态。</p><a id="more"></a><ul><li><strong>用户态（目态）：</strong> 此时CPU只能执行非特权指令</li><li><strong>核心态（管态）</strong>：特权指令、非特权指令都可以执行</li></ul><p><strong>两种程序</strong></p><ul><li><strong>内核程序：</strong> 操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</li><li><strong>应用程序：</strong> 为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。</li></ul><h2 id="二、操作系统的内核"><a href="#二、操作系统的内核" class="headerlink" title="二、操作系统的内核"></a>二、操作系统的内核</h2><p><strong>内核</strong> ：计算机上配置的 <code>底层软件</code>，是操作系统最基本、最核心的部分。</p><p>实现操作系统内核功能的那些程序就是==内核程序==。</p><ul><li><strong>时钟管理：</strong> 实现计时功能</li><li><strong>中断处理：</strong> 负责实现中断机制</li><li><strong>原语</strong><ul><li>是一种特殊的程序</li><li>处于操作系统最底层，是最接近硬件的部分</li><li>这种程序的运行具有<code>原子性</code> —— 其运行只能一气呵成，不可中断</li><li>运行时间较短，调用频繁</li></ul></li><li><strong>对系统资源进行管理的功能</strong> （有的操作系统不把这部分功能归为 “ 内核功能 ”。也就是说不同的操作系统，对内核功能的划分可能并不一样）<ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul><h2 id="三、操作系统的体系结构"><a href="#三、操作系统的体系结构" class="headerlink" title="三、操作系统的体系结构"></a>三、操作系统的体系结构</h2><ul><li><strong>大内核</strong><ul><li>将操作系统的主要功能模块都作为系统内核，运行在核心态</li><li>优点：高性能</li><li>缺点：内核代码庞大，结构混乱，难以维护</li></ul></li><li><strong>微内核</strong><ul><li>只把最基本的功能保留在内核</li><li>优点：内核功能少，结构清晰，方便维护</li><li>缺点：需要频繁地在核心态和用户态之间切换，性能低</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、两种指令、两种处理器状态、两种程序&quot;&gt;&lt;a href=&quot;#一、两种指令、两种处理器状态、两种程序&quot; class=&quot;headerlink&quot; title=&quot;一、两种指令、两种处理器状态、两种程序&quot;&gt;&lt;/a&gt;一、两种指令、两种处理器状态、两种程序&lt;/h2&gt;&lt;p&gt; ” &lt;strong&gt;指令&lt;/strong&gt; ” 就是处理器（CPU）能识别、执行的最基本命令&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;特权指令：&lt;/strong&gt; 如内存清零指令 –&amp;gt; 不允许用户程序使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;非特权指令：&lt;/strong&gt; 如普通的运算指令&lt;/p&gt;
&lt;p&gt;CPU如何判断当前是否可以执行特权指令？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用程序状态寄存器（PSW）中的某标志位来标识当前处理器处于什么状态，如0为用户态，1为核心态。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://1979F.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统复习】操作系统的发展与分类</title>
    <link href="http://1979F.github.io/2021/03/08/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB/"/>
    <id>http://1979F.github.io/2021/03/08/【操作系统复习】操作系统的发展与分类/</id>
    <published>2021-03-08T13:13:34.000Z</published>
    <updated>2021-03-10T08:55:46.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、手工操作阶段"><a href="#一、手工操作阶段" class="headerlink" title="一、手工操作阶段"></a>一、手工操作阶段</h2><p><strong>过程：</strong> 用户把程序写在纸带上（其实就是在纸带上打孔），然后输入到计算机中，计算机随后会处理这个程序，把输出结果又放在纸带中（其实还是打孔），展示给用户看。</p><p><img src="https://img-blog.csdnimg.cn/20190802135908168.png" alt="在这里插入图片描述"></p><p>由于用户在纸带上编写程序的速度很慢，纸带输入输出的速度也很慢，而计算机的处理速度快，所以系统资源的利用率极低。</p><p><strong>主要缺点：</strong>用户独占全机、人机速度矛盾导致资源利用率极低</p><a id="more"></a><h2 id="二、批处理阶段-——-单道批处理系统"><a href="#二、批处理阶段-——-单道批处理系统" class="headerlink" title="二、批处理阶段 —— 单道批处理系统"></a>二、批处理阶段 —— 单道批处理系统</h2><p>引入<code>脱机输入/输出技术</code>（用磁带完成），并使用<code>监督程序</code>（操作系统的雏形）负责控制作业的输入、输出。</p><p><img src="https://img-blog.csdnimg.cn/20190802142119391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MDE4Mjc3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>由于磁带录入到处理器中的速度比纸带快得多，所以单道批处理系统一定程序上缓和了人机速度矛盾，资源利用率有所提升。</p><p><strong>主要优点：</strong>  缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p><p><strong>主要缺点：</strong> <code>内存中仅能有一道程序运行</code>，只有该程序运行结束之后才能调入下一道程序。<code>CPU有大量的时间是在空闲等待I/O完成</code>。资源利用率依然很低。</p><h2 id="三、批处理阶段-——-多道批处理系统"><a href="#三、批处理阶段-——-多道批处理系统" class="headerlink" title="三、批处理阶段 —— 多道批处理系统"></a>三、批处理阶段 —— 多道批处理系统</h2><p>  每次往内存中输入多道程序，==操作系统正式诞生==，并引入了中断技术，由操作系统负责管理这些程序的运行。各个程序并发执行。</p><p><strong>主要优点：</strong>  多道程序<code>并发</code>执行，共享计算机资源。<code>资源利用率大幅提升</code>，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p><p><strong>主要缺点：</strong> 用户响应时间长，<code>没有人机交互功能</code>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p><p> 假设计算机需要处理三个作业：</p><p>作业一：输入1秒，计算1秒，输出1秒</p><p>作业二：输入1秒，计算1秒，输出1秒</p><p>作业三：输入1秒，计算1秒，输出1秒</p><p>采用单道批处理技术<br><img src="https://img-blog.csdnimg.cn/20210308211156686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>采用多道批处理技术<br><img src="https://img-blog.csdnimg.cn/20210308211218788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、分时操作系统"><a href="#四、分时操作系统" class="headerlink" title="四、分时操作系统"></a>四、分时操作系统</h2><p>计算机以==时间片==为单位<code>轮流为各个用户/作业服务</code>，各个用户可通过终端与计算机进行交互。</p><p><strong>主要优点：</strong> 用户请求可以被即时响应，<code>解决了人机交互问题</code>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p><strong>主要缺点：</strong> <code>不能优先处理一些紧急任务</code>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</p><img src="C:\Users\1979\AppData\Local\Temp\1615208248327.png" style="zoom:40%;"><h2 id="五、实时操作系统"><a href="#五、实时操作系统" class="headerlink" title="五、实时操作系统"></a>五、实时操作系统</h2><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<code>要在严格的时限内处理完事件</code>。实时操作系统的主要特点是==及时性和可靠性==。</p><p><strong>主要优点：</strong> 能够优先响应一些紧急任务，某些紧急任务不需时间片排队。<br><img src="https://img-blog.csdnimg.cn/20210308211240994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="六、其他操作系统"><a href="#六、其他操作系统" class="headerlink" title="六、其他操作系统"></a>六、其他操作系统</h2><p>网络操作系统、分布式操作系统、个人计算机操作系统</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、手工操作阶段&quot;&gt;&lt;a href=&quot;#一、手工操作阶段&quot; class=&quot;headerlink&quot; title=&quot;一、手工操作阶段&quot;&gt;&lt;/a&gt;一、手工操作阶段&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;过程：&lt;/strong&gt; 用户把程序写在纸带上（其实就是在纸带上打孔），然后输入到计算机中，计算机随后会处理这个程序，把输出结果又放在纸带中（其实还是打孔），展示给用户看。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190802135908168.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;&lt;p&gt;由于用户在纸带上编写程序的速度很慢，纸带输入输出的速度也很慢，而计算机的处理速度快，所以系统资源的利用率极低。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主要缺点：&lt;/strong&gt;用户独占全机、人机速度矛盾导致资源利用率极低&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://1979F.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯 历届试题 小数第n位</title>
    <link href="http://1979F.github.io/2021/03/08/%E8%93%9D%E6%A1%A5%E6%9D%AF%20%E5%8E%86%E5%B1%8A%E8%AF%95%E9%A2%98%20%E5%B0%8F%E6%95%B0%E7%AC%ACn%E4%BD%8D/"/>
    <id>http://1979F.github.io/2021/03/08/蓝桥杯 历届试题 小数第n位/</id>
    <published>2021-03-08T07:42:37.000Z</published>
    <updated>2021-03-10T08:35:23.961Z</updated>
    
    <content type="html"><![CDATA[<p><strong>资源限制</strong></p><p>时间限制：1.0s   内存限制：256.0MB</p><p><strong>问题描述</strong><br>　　我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。<br>　　如果我们把有限小数的末尾加上无限多个0，它们就有了统一的形式。</p><p>　　本题的任务是：在上面的约定下，求整数除法小数点后的第n位开始的3位数。<br>　　<br><strong>输入格式</strong><br>　　一行三个整数：a b n，用空格分开。a是被除数，b是除数，n是所求的小数后位置（0&lt;a,b,n&lt;1000000000）<br>　　<br><strong>输出格式</strong><br>　　一行3位数字，表示：a除以b，小数后第n位开始的3位数字。　　</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">样例输入</span><br><span class="line">1 8 1</span><br><span class="line">样例输出</span><br><span class="line">125</span><br><span class="line"></span><br><span class="line">样例输入</span><br><span class="line">1 8 3</span><br><span class="line">样例输出</span><br><span class="line">500</span><br><span class="line"></span><br><span class="line">样例输入</span><br><span class="line">282866 999000 6</span><br><span class="line">样例输出</span><br><span class="line">914</span><br></pre></td></tr></table></figure><p><strong>思路：</strong><br>问题可转化为   <strong>a / b * 10^n+2^ % 1000</strong></p><p>需要用下面的公式：</p><p><code>x/d%m = x%(d*m)/d</code></p><p>在求解10^n+2^时，用快速幂求解即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qpower</span><span class="params">(a, b, mod)</span>:</span></span><br><span class="line">    base = a</span><br><span class="line">    ans = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b:</span><br><span class="line">        <span class="keyword">if</span> b&amp;<span class="number">1</span>:</span><br><span class="line">            ans = ((ans%mod)*(base%mod))%mod</span><br><span class="line">        base = (base%mod)*(base%mod)</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">a, b, n = list(map(int, input().split()))</span><br><span class="line">mod = b*<span class="number">1000</span></span><br><span class="line">c = qpower(<span class="number">10</span>, n+<span class="number">2</span>, mod)</span><br><span class="line">res = (a%mod*c%mod)%mod</span><br><span class="line">print(res//b)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;资源限制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;时间限制：1.0s   内存限制：256.0MB&lt;/p&gt;&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;br&gt;　　我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。&lt;br&gt;　　如果我们把有限小数的末尾加上无限多个0，它们就有了统一的形式。&lt;/p&gt;&lt;p&gt;　　本题的任务是：在上面的约定下，求整数除法小数点后的第n位开始的3位数。&lt;br&gt;　　&lt;br&gt;&lt;strong&gt;输入格式&lt;/strong&gt;&lt;br&gt;　　一行三个整数：a b n，用空格分开。a是被除数，b是除数，n是所求的小数后位置（0&amp;lt;a,b,n&amp;lt;1000000000）&lt;br&gt;　　&lt;br&gt;&lt;strong&gt;输出格式&lt;/strong&gt;&lt;br&gt;　　一行3位数字，表示：a除以b，小数后第n位开始的3位数字。
　　&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://1979F.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统复习】操作系统的特征</title>
    <link href="http://1979F.github.io/2021/03/08/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81/"/>
    <id>http://1979F.github.io/2021/03/08/【操作系统复习】操作系统的特征/</id>
    <published>2021-03-08T02:52:31.000Z</published>
    <updated>2021-03-10T08:54:52.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、并发"><a href="#一、并发" class="headerlink" title="一、并发"></a>一、并发</h2><p><strong>并发</strong> ：指两个或多个事件在同一时间间隔内发生。这些事件==宏观上是同时发生==的，但==微观上是交替发生==的。</p><p><strong>并行</strong>：指两个或多个事件在同一时刻同时发生。</p><p><strong>操作系统的并发性</strong>指计算机系统中同时存在着多个运行着的程序。</p><p>一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但宏观上看起来就像是在同时执行）</p><a id="more"></a><p>事实上，操作系统就是伴随着“多道程序技术”而出现的。因此，<em>操作系统和程序并发是一起诞生的。</em></p><h2 id="二、共享"><a href="#二、共享" class="headerlink" title="二、共享"></a>二、共享</h2><p><strong>共享</strong>：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p><p><img src="https://img-blog.csdnimg.cn/20210308110058465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</p><ul><li>互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。</li></ul><ul><li>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</li></ul><p>💁 <strong>并发和共享的关系</strong>　　（互为存在条件）</p><p>通过上述例子来看并发与共享的关系：</p><p>使用QQ发送文件A，同时使用微信发送文件B。</p><p>１、两个进程正在并发执行（并发性）</p><p>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</p><p>２、需要共享地访问硬盘资源（共享性）</p><p>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。</p><h2 id="三、虚拟"><a href="#三、虚拟" class="headerlink" title="三、虚拟"></a>三、虚拟</h2><p><strong>虚拟</strong>：指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p><p>:chestnut:  例子一</p><p>某游戏需要４GB的运行内存，QQ需要256MB的内存，迅雷需要256MB的内存，网易云音乐需要256MB的内存……</p><p>我的电脑：4GB内存</p><p>❓  这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？</p><p>:arrow_forward:  这是<strong>虚拟存储器技术</strong>。实际只有4GB的内存，在用户看来似乎远远大于4GB。这里用到的是虚拟技术中的“==时分复用技术==”。</p><p>🌰  例子二</p><p>某单核CPU的计算机中，用户打开了QQ、谷歌浏览器、QQ音乐等</p><p>:question:  既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU的电脑中能同时运行这么多个程序呢？</p><p>▶️  这是<strong>虚拟处理器技术</strong>。实际上只有一个单核CPU，在用户看来似乎有6个CPU在同时为自己服务。这里用到的是虚拟技术中的“==时分复用技术==”。微观上处理机在各个微小的时间段内交替着为各个进程服务。</p><p><img src="https://img-blog.csdnimg.cn/20210308110126807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、异步"><a href="#四、异步" class="headerlink" title="四、异步"></a>四、异步</h2><p><strong>异步</strong>： 指在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p><p>显然，如果失去了并发性，则系统只能串行地处理各个进程，每个进程地执行会一贯到底。只有系统拥有并发性，才有可能导致异步性。</p><ul><li>没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、并发&quot;&gt;&lt;a href=&quot;#一、并发&quot; class=&quot;headerlink&quot; title=&quot;一、并发&quot;&gt;&lt;/a&gt;一、并发&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;并发&lt;/strong&gt; ：指两个或多个事件在同一时间间隔内发生。这些事件==宏观上是同时发生==的，但==微观上是交替发生==的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;并行&lt;/strong&gt;：指两个或多个事件在同一时刻同时发生。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;操作系统的并发性&lt;/strong&gt;指计算机系统中同时存在着多个运行着的程序。&lt;/p&gt;&lt;p&gt;一个单核处理机（CPU）同一时刻只能执行一个程序，因此操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但宏观上看起来就像是在同时执行）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://1979F.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>【操作系统复习】操作系统的概念、功能和目标</title>
    <link href="http://1979F.github.io/2021/03/07/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E3%80%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8A%9F%E8%83%BD%E5%92%8C%E7%9B%AE%E6%A0%87/"/>
    <id>http://1979F.github.io/2021/03/07/【操作系统复习】操作系统的概念、功能和目标/</id>
    <published>2021-03-07T03:15:15.000Z</published>
    <updated>2021-03-10T08:55:31.714Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p><img src="https://img-blog.csdnimg.cn/20210307111239972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>   <strong>操作系统（Operating System，OS）</strong>：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的==系统软件==。</p><h2 id="二、操作系统的功能和目标"><a href="#二、操作系统的功能和目标" class="headerlink" title="二、操作系统的功能和目标"></a>二、操作系统的功能和目标</h2><h3 id="2-1-作为系统资源的管理者"><a href="#2-1-作为系统资源的管理者" class="headerlink" title="2.1 作为系统资源的管理者"></a>2.1 作为系统资源的管理者</h3><p><img src="https://img-blog.csdnimg.cn/20210307111322475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>进程是一个程序的执行过程。执行前 <code>需要将该程序放到内存中</code>，才能被CPU处理。</p><p>举一个生活中的<strong>例子</strong>（用QQ和朋友视频聊天的过程）：</p></li></ul><a id="more"></a><p><strong>Step1</strong>：在各个文件夹中找到QQ安装的位置  —&gt; 逐层打开文件夹，找到QQ.exe这个程序（可执行文件）的存放位置；</p><p><strong>Step2</strong>：双击打开QQ.exe —&gt; 需要把该程序相关数据放入内存；</p><p><strong>Step3</strong>：QQ程序正常运行 —&gt; 对应的进程被处理机（CPU）处理；</p><p><strong>Step4</strong>：开始和朋友视频聊天 —&gt; 需要将摄像头设备分配给进程；</p><h3 id="2-2-作为用户和计算机硬件之间的接口"><a href="#2-2-作为用户和计算机硬件之间的接口" class="headerlink" title="2.2 作为用户和计算机硬件之间的接口"></a>2.2 作为用户和计算机硬件之间的接口</h3><p><img src="https://img-blog.csdnimg.cn/20210307111407115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>命令接口：</code>  允许用户==直接使用==</p><ul><li>联机命令接口：用户说一句，系统做一句 = ==交互式==命令接口</li><li>脱机命令接口：用户说一堆，系统做一堆 = ==批处理==命令接口</li></ul><p><code>程序接口：</code>  允许用户通过程序==间接使用==</p><p>由一组==系统调用==组成（程序接口=系统接口）</p><p><strong>易懵概念</strong>：</p><p><code>系统调用 = 系统调用命令 = 广义指令</code></p><p>如：程序员在程序中调用 uesr32.dll 即可实现创建窗口等功能</p><p><code>GUI：</code> 现代操作系统中最流行的图形用户接口</p><p>如windows、安卓、iOS、macOS的图形化操作界面</p><h3 id="2-3-作为最接近硬件的层次"><a href="#2-3-作为最接近硬件的层次" class="headerlink" title="2.3 作为最接近硬件的层次"></a>2.3 作为最接近硬件的层次</h3><p>需要提供的功能和目标：实现对硬件机器的拓展</p><p>没有任何软件支持的计算机称为==裸机==。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[toc]&lt;/p&gt;&lt;h2 id=&quot;一、概念&quot;&gt;&lt;a href=&quot;#一、概念&quot; class=&quot;headerlink&quot; title=&quot;一、概念&quot;&gt;&lt;/a&gt;一、概念&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210307111239972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;&lt;p&gt;   &lt;strong&gt;操作系统（Operating System，OS）&lt;/strong&gt;：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的==系统软件==。&lt;/p&gt;&lt;h2 id=&quot;二、操作系统的功能和目标&quot;&gt;&lt;a href=&quot;#二、操作系统的功能和目标&quot; class=&quot;headerlink&quot; title=&quot;二、操作系统的功能和目标&quot;&gt;&lt;/a&gt;二、操作系统的功能和目标&lt;/h2&gt;&lt;h3 id=&quot;2-1-作为系统资源的管理者&quot;&gt;&lt;a href=&quot;#2-1-作为系统资源的管理者&quot; class=&quot;headerlink&quot; title=&quot;2.1 作为系统资源的管理者&quot;&gt;&lt;/a&gt;2.1 作为系统资源的管理者&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210307111322475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程是一个程序的执行过程。执行前 &lt;code&gt;需要将该程序放到内存中&lt;/code&gt;，才能被CPU处理。&lt;/p&gt;
&lt;p&gt;举一个生活中的&lt;strong&gt;例子&lt;/strong&gt;（用QQ和朋友视频聊天的过程）：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="操作系统" scheme="http://1979F.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter notebook绘制热力图边缘只有一半的问题</title>
    <link href="http://1979F.github.io/2021/03/01/Jupyter%20notebook%E7%BB%98%E5%88%B6%E7%83%AD%E5%8A%9B%E5%9B%BE%E8%BE%B9%E7%BC%98%E5%8F%AA%E6%9C%89%E4%B8%80%E5%8D%8A%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://1979F.github.io/2021/03/01/Jupyter notebook绘制热力图边缘只有一半的问题/</id>
    <published>2021-03-01T01:38:40.000Z</published>
    <updated>2021-03-10T08:36:25.220Z</updated>
    
    <content type="html"><![CDATA[<p>同个人网站 <a href="https://www.serendipper-x.cn/" target="_blank" rel="noopener">https://www.serendipper-x.cn/</a>，欢迎访问 ！</p><p>添加如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bottom, top = ax.get_ylim() </span><br><span class="line"></span><br><span class="line">ax.set_ylim(bottom + <span class="number">0.5</span>, top - <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;同个人网站 &lt;a href=&quot;https://www.serendipper-x.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.serendipper-x.cn/&lt;/a&gt;，欢迎访问 ！&lt;/p&gt;
&lt;p&gt;添加如下代码：&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="其他" scheme="http://1979F.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>Python 绘制热力图参数详解</title>
    <link href="http://1979F.github.io/2021/03/01/Python%20%E7%BB%98%E5%88%B6%E7%83%AD%E5%8A%9B%E5%9B%BE%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://1979F.github.io/2021/03/01/Python 绘制热力图参数详解/</id>
    <published>2021-03-01T01:37:25.000Z</published>
    <updated>2021-03-10T08:37:05.217Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参数设置：</strong></p><p><code>（1）热力图输入数据参数:</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:矩阵数据集，可以是numpy的数组（array），也可以是pandas的DataFrame。</span><br><span class="line"></span><br><span class="line">如果是DataFrame，则df的index/column信息会分别对应到heatmap的columns和rows，</span><br><span class="line"></span><br><span class="line">即pt.index是热力图的行标，pt.columns是热力图的列标</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>（2）热力图矩阵块颜色参数:</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vmax,vmin:分别是热力图的颜色取值最大和最小范围，默认是根据data数据表里的取值确定</span><br><span class="line"></span><br><span class="line">cmap:从数字到色彩空间的映射，取值是matplotlib包里的colormap名称或颜色对象，或者表示颜色的列表；改参数默认值：根据center参数设定</span><br><span class="line"></span><br><span class="line">center:数据表取值有差异时，设置热力图的色彩中心对齐值；通过设置center值，可以调整生成的图像颜色的整体深浅；设置center数据时，如果有数据溢出，则手动设置的vmax、vmin会自动改变</span><br><span class="line"></span><br><span class="line">robust:默认取值False；如果是False，且没设定vmin和vmax的值，热力图的颜色映射范围根据具有鲁棒性的分位数设定，而不是用极值设定</span><br></pre></td></tr></table></figure><p><code>（3）热力图矩阵块注释参数:</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annot(annotate的缩写):默认取值False；如果是True，在热力图每个方格写入数据；如果是矩阵，在热力图每个方格写入该矩阵对应位置数据</span><br><span class="line"></span><br><span class="line">fmt:字符串格式代码，矩阵上标识数字的数据格式，比如保留小数点后几位数字</span><br><span class="line"></span><br><span class="line">annot_kws:默认取值False；如果是True，设置热力图矩阵上数字的大小颜色字体，matplotlib包text类下的字体设置；</span><br></pre></td></tr></table></figure><p><code>（4）热力图矩阵块之间间隔及间隔线参数：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linewidths:定义热力图里“表示两两特征关系的矩阵小块”之间的间隔大小</span><br><span class="line"></span><br><span class="line">linecolor:切分热力图上每个矩阵小块的线的颜色，默认值是’white’</span><br></pre></td></tr></table></figure><p><code>（5）热力图颜色刻度条参数：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cbar:是否在热力图侧边绘制颜色刻度条，默认值是True</span><br><span class="line"></span><br><span class="line">cbar_kws:热力图侧边绘制颜色刻度条时，相关字体设置，默认值是None</span><br><span class="line"></span><br><span class="line">cbar_ax:热力图侧边绘制颜色刻度条时，刻度条位置设置，默认值是None</span><br></pre></td></tr></table></figure><p><code>（6）square:设置热力图矩阵小块形状：</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">默认值是False xticklabels,</span><br><span class="line"></span><br><span class="line">yticklabels:xticklabels控制每列标签名的输出；yticklabels控制每行标签名的输出。默认值是auto。</span><br><span class="line"></span><br><span class="line">如果是True，则以DataFrame的列名作为标签名。</span><br><span class="line"></span><br><span class="line">如果是False，则不添加行标签名。如果是列表，则标签名改为列表中给的内容。</span><br><span class="line"></span><br><span class="line">如果是整数K，则在图上每隔K个标签进行一次标注。</span><br><span class="line"></span><br><span class="line">如果是auto，则自动选择标签的标注间距，将标签名不重叠的部分(或全部)输出</span><br></pre></td></tr></table></figure><p><code>（7）mask:控制某个矩阵块是否显示出来：</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">默认值是None。</span><br><span class="line"></span><br><span class="line">如果是布尔型的DataFrame，则将DataFrame里True的位置用白色覆盖掉</span><br><span class="line"></span><br><span class="line">ax:设置作图的坐标轴，一般画多个子图时需要修改不同的子图的该值</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;参数设置：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;（1）热力图输入数据参数:&lt;/code&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;data:矩阵数据集，可以是numpy的数组（array），也可以是pandas的DataFrame。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果是DataFrame，则df的index/column信息会分别对应到heatmap的columns和rows，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;即pt.index是热力图的行标，pt.columns是热力图的列标&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="其他" scheme="http://1979F.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>pyecharts 绘制地图</title>
    <link href="http://1979F.github.io/2021/03/01/pyecharts%20%E7%BB%98%E5%88%B6%E5%9C%B0%E5%9B%BE/"/>
    <id>http://1979F.github.io/2021/03/01/pyecharts 绘制地图/</id>
    <published>2021-03-01T01:27:25.000Z</published>
    <updated>2021-03-10T08:37:37.783Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入相关包</span></span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map, Geo, Lin</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">r'C:\Users\1979\Desktop\处理后的数据\谷物产量（公吨）（2000-2017）.csv'</span>)</span><br><span class="line"></span><br><span class="line">value = data.iloc[:,<span class="number">18</span>]</span><br><span class="line">attr = data.iloc[:,<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 显示世界地图</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_world</span><span class="params">()</span> -&gt; Map:</span></span><br><span class="line">    c = (</span><br><span class="line">        Map(init_opts=opts.InitOpts(</span><br><span class="line">            <span class="comment"># 设置主题</span></span><br><span class="line">            theme=<span class="string">'wonderland'</span>))</span><br><span class="line">        .add(<span class="string">""</span>, [list(z) <span class="keyword">for</span> z <span class="keyword">in</span> zip(attr, value)], <span class="string">"world"</span>,is_map_symbol_show=<span class="literal">False</span>)</span><br><span class="line">        .set_series_opts(label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>),</span><br><span class="line">                         itemstyle_opts=&#123;<span class="string">'normal'</span>: &#123;</span><br><span class="line">                      </span><br><span class="line">                       <span class="string">'opacity'</span>: <span class="number">0.6</span></span><br><span class="line">                       &#125;&#125;</span><br><span class="line">                   </span><br><span class="line">)</span><br><span class="line">        .set_global_opts(</span><br><span class="line">            title_opts=opts.TitleOpts(title=<span class="string">"Distribution map of global grain production"</span>,pos_right=<span class="string">"center"</span>,pos_top=<span class="string">"1%"</span>),</span><br><span class="line">            visualmap_opts=opts.VisualMapOpts(max_=<span class="number">710000000</span>,min_=<span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">country_ = map_world()</span><br><span class="line">country_.render_notebook()</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20210301092626864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 导入相关包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; pyecharts &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; options &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; opts&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; pyecharts.charts &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Map, Geo, Lin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data = pd.read_csv(&lt;span class=&quot;string&quot;&gt;r&#39;C:\Users\1979\Desktop\处理后的数据\谷物产量（公吨）（2000-2017）.csv&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;value = data.iloc[:,&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;attr = data.iloc[:,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 显示世界地图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;map_world&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; -&amp;gt; Map:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c = (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Map(init_opts=opts.InitOpts(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 设置主题&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            theme=&lt;span class=&quot;string&quot;&gt;&#39;wonderland&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .add(&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;, [list(z) &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; z &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; zip(attr, value)], &lt;span class=&quot;string&quot;&gt;&quot;world&quot;&lt;/span&gt;,is_map_symbol_show=&lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .set_series_opts(label_opts=opts.LabelOpts(is_show=&lt;span class=&quot;literal&quot;&gt;False&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                         itemstyle_opts=&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;normal&#39;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       &lt;span class=&quot;string&quot;&gt;&#39;opacity&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0.6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                       &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .set_global_opts(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            title_opts=opts.TitleOpts(title=&lt;span class=&quot;string&quot;&gt;&quot;Distribution map of global grain production&quot;&lt;/span&gt;,pos_right=&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;,pos_top=&lt;span class=&quot;string&quot;&gt;&quot;1%&quot;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            visualmap_opts=opts.VisualMapOpts(max_=&lt;span class=&quot;number&quot;&gt;710000000&lt;/span&gt;,min_=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;country_ = map_world()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;country_.render_notebook()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="其他" scheme="http://1979F.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>【知识图谱】一、知识表示与知识建模</title>
    <link href="http://1979F.github.io/2021/02/21/%E3%80%90%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E3%80%91%E4%B8%80%E3%80%81%E7%9F%A5%E8%AF%86%E8%A1%A8%E7%A4%BA%E4%B8%8E%E7%9F%A5%E8%AF%86%E5%BB%BA%E6%A8%A1/"/>
    <id>http://1979F.github.io/2021/02/21/【知识图谱】一、知识表示与知识建模/</id>
    <published>2021-02-21T08:44:57.000Z</published>
    <updated>2021-03-10T08:41:57.978Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、早期知识表示简介"><a href="#一、早期知识表示简介" class="headerlink" title="一、早期知识表示简介"></a>一、早期知识表示简介</h3><p><code>知识表示的重要性</code></p><ul><li><strong>知识是智能的基础</strong><ul><li>机器可以获得知识</li><li>机器可以运用知识<ul><li><strong>符合计算机要求的知识模式</strong></li></ul></li><li>计算机能存储、处理的知识表示模式</li><li>数据结构（List、Table、Tree、Graph、etc.）</li></ul></li></ul><p><code>知识的特性</code></p><ul><li><p>相对正确性</p><ul><li>一定条件下</li><li>某种环境中</li><li>……</li></ul></li><li><p>不确定性</p><ul><li>存在“中间状态”</li><li>“真”（“假”）程度</li><li>随机性、模糊性、经验性、不完全性</li><li>……</li></ul></li><li><p>可表示性&amp;可利用性</p><ul><li>语言、文字、图形、图像、视频、音频</li><li>神经网络</li><li>概率图模型</li><li>……</li></ul></li></ul><a id="more"></a><p><code>知识分类</code></p><ul><li>常识性知识、领域性知识（范围）</li><li>事实性知识、过程性知识、控制性知识（作用及表示）</li><li>确定性知识、不确定性知识（确定性）</li><li>逻辑性知识、形象性知识（结构及表现形式）</li></ul><p><code>早期知识表示方法</code></p><ul><li>一阶谓词逻辑（First-Order Logic）</li><li>产生式规则（Production Rule）</li><li>框架（Framework）</li><li>语义网络（Semantic Network）</li><li><em>逻辑程序（Logic Programming）</em></li><li><em>缺省逻辑（Default Logic）</em></li><li><em>模态逻辑（Modal Logic）</em></li></ul><p>待补……</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、早期知识表示简介&quot;&gt;&lt;a href=&quot;#一、早期知识表示简介&quot; class=&quot;headerlink&quot; title=&quot;一、早期知识表示简介&quot;&gt;&lt;/a&gt;一、早期知识表示简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;知识表示的重要性&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;知识是智能的基础&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;机器可以获得知识&lt;/li&gt;
&lt;li&gt;机器可以运用知识&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;符合计算机要求的知识模式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算机能存储、处理的知识表示模式&lt;/li&gt;
&lt;li&gt;数据结构（List、Table、Tree、Graph、etc.）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;知识的特性&lt;/code&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;相对正确性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一定条件下&lt;/li&gt;
&lt;li&gt;某种环境中&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不确定性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在“中间状态”&lt;/li&gt;
&lt;li&gt;“真”（“假”）程度&lt;/li&gt;
&lt;li&gt;随机性、模糊性、经验性、不完全性&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可表示性&amp;amp;可利用性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语言、文字、图形、图像、视频、音频&lt;/li&gt;
&lt;li&gt;神经网络&lt;/li&gt;
&lt;li&gt;概率图模型&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="知识图谱" scheme="http://1979F.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
  </entry>
  
  <entry>
    <title>算法竞赛入门经典 例题6-6 小球（C、python）</title>
    <link href="http://1979F.github.io/2021/02/19/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%20%E4%BE%8B%E9%A2%986-6%20%E5%B0%8F%E7%90%83%E4%B8%8B%E8%90%BD%EF%BC%88python%E3%80%81C%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/19/算法竞赛入门经典 例题6-6 小球下落（python、C）/</id>
    <published>2021-02-19T09:27:13.000Z</published>
    <updated>2021-03-10T08:47:36.976Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>有一颗二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右编号为 1，2，3，… ，2^D^ - 1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，初始全部关闭，当每次由小球落到一个开关上时，状态都会改变。当小球到达一个内结点时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所示。</p><a id="more"></a><p>一些小球从结点1处下落，最后一个小球将会落到哪里呢？输入叶子深度 <em>D</em> 和小球个数 <em>I</em>，输出第 <em>I</em> 个小球最后所在的叶子编号。假设 <em>I</em> 不超过整棵树的叶子个数，<em>D</em> ≤ 20。<br><img src="https://img-blog.csdnimg.cn/20210219170015810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>tips:</strong><br>给定一颗包含2^d^个结点（其中d为树的高度）的完全二叉树，如果把结点从上到下从左到右编号为1，2，3……，则结点k的左右子结点编号分别为<code>2k</code> 和 <code>2k+1</code>。</p><p>Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        D, I = list(map(int, input().split()))</span><br><span class="line">        n = (<span class="number">1</span>&lt;&lt;D) - <span class="number">1</span>   <span class="comment"># n是最大结点编号</span></span><br><span class="line">        s = [<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range (<span class="number">1</span>&lt;&lt;<span class="number">20</span>)]  <span class="comment"># 初始值都为假</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (I):</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                s[k] = ~s[k]  <span class="comment"># 状态改变</span></span><br><span class="line">                <span class="keyword">if</span> s[k] == <span class="number">0</span>:</span><br><span class="line">                    k = <span class="number">2</span> * k + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k = <span class="number">2</span> * k</span><br><span class="line">                <span class="keyword">if</span> k &gt; n:   <span class="comment"># 出界</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">print</span> (k//<span class="number">2</span>)  <span class="comment"># 出界之前的叶子编号</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxd = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> D, I;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;D, &amp;I) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">        <span class="keyword">int</span> k, n = (<span class="number">1</span>&lt;&lt;D)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; I; i++) &#123;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                s[k] = !s[k];</span><br><span class="line">                k = s[k] ? k*<span class="number">2</span> : k*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用题目中给的编号 I，则当 I 是奇数时，它是往左走的的第（I+1）/ 2个小球；当 I 是偶数时，它是往右走的第 I/2 个小球。这样，可以直接模拟最后一个小球的路线：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;D, &amp;I) == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D<span class="number">-1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(I%<span class="number">2</span>) &#123;</span><br><span class="line">k = k*<span class="number">2</span>;</span><br><span class="line">I = (I+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">k = k*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">I /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;br&gt;有一颗二叉树，最大深度为D，且所有叶子的深度都相同。所有结点从上到下从左到右编号为 1，2，3，… ，2^D^ - 1。在结点1处放一个小球，它会往下落。每个内结点上都有一个开关，初始全部关闭，当每次由小球落到一个开关上时，状态都会改变。当小球到达一个内结点时，如果该结点上的开关关闭，则往左走，否则往右走，直到走到叶子结点，如图所示。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://1979F.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法竞赛入门经典 例题6-2 铁轨（C、python）</title>
    <link href="http://1979F.github.io/2021/02/19/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%20%E4%BE%8B%E9%A2%986-2%20%E9%93%81%E8%BD%A8%EF%BC%88C%E3%80%81python%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/19/算法竞赛入门经典 例题6-2 铁轨（C、python）/</id>
    <published>2021-02-19T08:03:09.000Z</published>
    <updated>2021-03-10T08:46:59.029Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>某城市有一个火车站，铁轨铺设如图所示。有n节车厢从A方向驶入车站，按进站顺序编号为 1~n 。你的任务是判断是否能让它们按照某种特定的顺序进入 B 方向的铁轨并驶出车站。例如，出栈顺序（5 4 1 2 3）是不可能的，但（5 4 3 2 1）是可能的。</p><p>为了重组车厢，你可以借助中转站 C。这是一个可以停放任意多节车厢的车站，但由于末端封顶，驶入 C 的车厢必须按照相反的顺序驶出 C。对于每个车厢，一旦从 A 移入 C ，就不能再回到 A 了；一旦从 C 移入 B，就不能回到 C 了。换句话说，在任意时刻，只能由两种选择： A -&gt; C 和 C -&gt; B。<br><img src="https://img-blog.csdnimg.cn/20210219160521878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><p><strong>分析：</strong>  在这里中转站 C 符合<strong>先进后出</strong>的原则，可以把它当作是<strong>栈</strong>。</p><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, target[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">int</span> A = <span class="number">1</span>, B = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;target[i]);</span><br><span class="line"><span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(B &lt;= n)&#123;</span><br><span class="line"><span class="keyword">if</span>(A == target[B])&#123;</span><br><span class="line">A++;B++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!s.empty() &amp;&amp; s.top() == target[B])&#123;</span><br><span class="line">s.pop();B++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(A &lt;= n)</span><br><span class="line">s.push(A++);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ok = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ok ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line">target = list(map(int, input().split()))  <span class="comment"># 测试队列</span></span><br><span class="line">stack = []</span><br><span class="line"></span><br><span class="line">ok, A, B = <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> B &lt; n:</span><br><span class="line">    <span class="keyword">if</span> A == target[B]:</span><br><span class="line">        A += <span class="number">1</span></span><br><span class="line">        B += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> len(stack) != <span class="number">0</span> <span class="keyword">and</span> stack[len(stack)<span class="number">-1</span>] == target[B]:</span><br><span class="line">        stack.pop()</span><br><span class="line">        B += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> A &lt;= n:</span><br><span class="line">        stack.append(A)</span><br><span class="line">        A += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ok = <span class="number">0</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> ok == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"Yes"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"No"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;br&gt;某城市有一个火车站，铁轨铺设如图所示。有n节车厢从A方向驶入车站，按进站顺序编号为 1~n 。你的任务是判断是否能让它们按照某种特定的顺序进入 B 方向的铁轨并驶出车站。例如，出栈顺序（5 4 1 2 3）是不可能的，但（5 4 3 2 1）是可能的。&lt;/p&gt;&lt;p&gt;为了重组车厢，你可以借助中转站 C。这是一个可以停放任意多节车厢的车站，但由于末端封顶，驶入 C 的车厢必须按照相反的顺序驶出 C。对于每个车厢，一旦从 A 移入 C ，就不能再回到 A 了；一旦从 C 移入 B，就不能回到 C 了。换句话说，在任意时刻，只能由两种选择： A -&amp;gt; C 和 C -&amp;gt; B。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210219160521878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://1979F.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速幂模板（Python）</title>
    <link href="http://1979F.github.io/2021/02/17/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF%EF%BC%88Python%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/17/快速幂模板（Python）/</id>
    <published>2021-02-17T03:48:19.000Z</published>
    <updated>2021-02-17T05:33:26.573Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们需要知道下面这个公式：<br><code>(a^b) mod c=((a mod c)^b) mod c</code></p><p>现在试着用最常规的方法计算 a^b</p><p><strong>算法一：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spow</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (m):</span><br><span class="line">        res *= n</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(spow(<span class="number">2</span>, <span class="number">100</span>))</span><br></pre></td></tr></table></figure><a id="more"></a><p>显然这个算法的时间复杂度为 <code>O(n)</code>，我们需要找到一个复杂度较低的算法。<br>对于幂次运算，例如a^5</p><p>如果直接运算，需要5次循环了。</p><p>但是如果写成 a^5 = a*((a^2)^2)，如果是这样，就仅仅需要3次运算了，一下子省了两次运算，对于这次次数低的运算都如此可观，对于次数多的运算可想而知了。</p><p>对于上面的情况，计算幂的时候，明显需要分情况考虑。</p><p>1、当b为偶数的时候，a^b = (a^2)^(b/2)；<br>2、当b为奇数的时候，a^b = a*(a^2)((b-1)/2)。</p><p>时间复杂度降到了 <code>O(logn)</code></p><p><strong>算法二：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qpow</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    base = n</span><br><span class="line">    <span class="keyword">while</span> m != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (m&amp;<span class="number">1</span>) != <span class="number">0</span>:</span><br><span class="line">            res = res*base</span><br><span class="line">        base = base*base</span><br><span class="line">        m = m &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(qpow(<span class="number">2</span>, <span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>如果要取余</p><p><strong>算法三：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mod = <span class="number">1000000007</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qpow</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    base = n</span><br><span class="line">    <span class="keyword">while</span> m != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> (m&amp;<span class="number">1</span>) != <span class="number">0</span>:</span><br><span class="line">            res = res*base%mod</span><br><span class="line">        base = base*base%mod</span><br><span class="line">        m = m &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(qpow(<span class="number">2</span>, <span class="number">100</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们需要知道下面这个公式：&lt;br&gt;&lt;code&gt;(a^b) mod c=((a mod c)^b) mod c&lt;/code&gt;&lt;/p&gt;&lt;p&gt;现在试着用最常规的方法计算 a^b&lt;/p&gt;&lt;p&gt;&lt;strong&gt;算法一：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;spow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(n, m)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range (m):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        res *= n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; res&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(spow(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="算法" scheme="http://1979F.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客16732 序列（排列组合）</title>
    <link href="http://1979F.github.io/2021/02/17/%E7%89%9B%E5%AE%A216732%20%E5%BA%8F%E5%88%97%EF%BC%88%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%EF%BC%89/"/>
    <id>http://1979F.github.io/2021/02/17/牛客16732 序列（排列组合）/</id>
    <published>2021-02-17T03:48:19.000Z</published>
    <updated>2021-02-17T05:31:15.015Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/16732" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/16732</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>有一个长度为n的序列a，已知a[1]=a[n]=1，且对于2 &lt;= x &lt;= n，a[x] / a[x-1]是以下三个数字之一 [ 1，-2，0.5 ],问有多少种不同的序列满足题意。<br>两个序列不同当且仅当它们有至少一个位置上的数字不同，序列a可以为任何实数。</p><a id="more"></a><p><strong>输入描述:</strong></p><p>一个整数 表示n (1&lt;= n &lt;= 1e3)</p><p><strong>输出描述:</strong></p><p>一个整数 表示答案模 10^9^ +7</p><p><img src="https://img-blog.csdnimg.cn/20210217113849153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>直接整体来看，a[x] = a[x-1]*[1, -2, 0.5]，那么等于选出n-1个数值相乘</p><p>最后答案要是1，所以-2就必须有偶数个，同理0.5的个数要等于-2，顺序无关</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = int(input())</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">MOD = <span class="number">1000000007</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> math.factorial(m) // math.factorial(n) // math.factorial(m - n) % MOD</span><br><span class="line">ans = <span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">num = n<span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= num // <span class="number">2</span>:</span><br><span class="line">    ans = (ans + c(num, i) * c(num - i, i)) % MOD</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line">print(ans)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16732&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/16732&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;有一个长度为n的序列a，已知a[1]=a[n]=1，且对于2 &amp;lt;= x &amp;lt;= n，a[x] / a[x-1]是以下三个数字之一 [ 1，-2，0.5 ],问有多少种不同的序列满足题意。&lt;br&gt;两个序列不同当且仅当它们有至少一个位置上的数字不同，序列a可以为任何实数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>牛客16596 计算系数（排列组合）</title>
    <link href="http://1979F.github.io/2021/02/17/%E8%AE%A1%E7%AE%97%E7%B3%BB%E6%95%B0/"/>
    <id>http://1979F.github.io/2021/02/17/计算系数/</id>
    <published>2021-02-17T01:11:40.000Z</published>
    <updated>2021-02-17T05:30:23.202Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/16596" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/16596</a><br>来源：牛客网</p><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format: %lld</p><p><strong>题目描述</strong> </p><p>给定一个多项式(ax+by)k，请求出多项式展开后x^n * y^m项的系数。</p><a id="more"></a><p><strong>输入描述:</strong></p><p>共一行，包含5个整数，分别为a，b，k，n，m，每两个整数之间用一个空格隔开。</p><p><strong>输出描述:</strong></p><p>输出共1行，包含一个整数，表示所求的系数，这个系数可能很大，输出对10007取模后的结果。</p><p><img src="https://img-blog.csdnimg.cn/2021021709105043.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a, b, k, n, m = list(map(int, input().split()))</span><br><span class="line"></span><br><span class="line">k1=<span class="number">1</span></span><br><span class="line">m1=<span class="number">1</span></span><br><span class="line">n1=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">    k1 = k1*i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,m+<span class="number">1</span>):</span><br><span class="line">    m1 = m1*i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    n1 = n1*i</span><br><span class="line">s = ((k1//(m1*n1))*a**n*b**m)%<span class="number">10007</span></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16596&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/16596&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;/p&gt;&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;给定一个多项式(ax+by)k，请求出多项式展开后x^n * y^m项的系数。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="NOWCODER" scheme="http://1979F.github.io/tags/NOWCODER/"/>
    
  </entry>
  
  <entry>
    <title>智力题：64匹马8个跑道，至少需要多少轮才能挑选出最快的4匹马</title>
    <link href="http://1979F.github.io/2021/02/17/%E6%99%BA%E5%8A%9B%E9%A2%98%EF%BC%9A64%E5%8C%B9%E9%A9%AC8%E4%B8%AA%E8%B7%91%E9%81%93%EF%BC%8C%E8%87%B3%E5%B0%91%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E8%BD%AE%E6%89%8D%E8%83%BD%E6%8C%91%E9%80%89%E5%87%BA%E6%9C%80%E5%BF%AB%E7%9A%844%E5%8C%B9%E9%A9%AC/"/>
    <id>http://1979F.github.io/2021/02/17/智力题：64匹马8个跑道，至少需要多少轮才能挑选出最快的4匹马/</id>
    <published>2021-02-17T00:58:45.000Z</published>
    <updated>2021-02-17T05:29:22.929Z</updated>
    
    <content type="html"><![CDATA[<div id="article_content" class="article_content clearfix">        <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b5506197d8.css">                <div id="content_views" class="markdown_views prism-atom-one-dark"><h4><a id="_0"></a>题意：</h4> <p>64匹马8个跑道需要多少轮才能挑选出最快的四匹马？</p> <h4><a id="_3"></a>解法：</h4> <p>1.分成八组，每组8匹马。</p> <p>2.八组内部分别比赛，总共比八场，对每组的马排序。<br> 每组的后四匹显然不是答案，直接淘汰。</p> <p>现在只剩下八组，每组4匹。</p> <p>3.选出八组的第一名进行比赛，后四名所在的组的所有马显然不是答案，直接淘汰。</p> <p>现在只剩下前四组，每组只剩下前四匹马，总共十六匹。</p> <p>4.剩下四组中，第四组的后三匹一定不是答案，因为比他们快的已经至少有四匹了（四个组的第一匹），<br> 同时，第三组的后两匹一定不是答案；第二组的后一匹一定不是答案。理由同上。</p> <p>其实第一组的第一匹一定是答案，因为最快。</p> <p>那么现在只剩下第一组3匹，第二组3匹，第三组2匹，第四组1匹。总共9匹。</p> <p>5.剩下的9匹用两次选出前3匹即可。</p> <p>总比赛次数为：8+1+2=11次。</p> <hr>                </div><div><div></div></div>                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-d7a94ec6ab.css" rel="stylesheet">                <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-80ad9b4f5b.css" rel="stylesheet">        </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://csdnimg.cn/release/blogv2/dist/mded
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://1979F.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
