<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Serendipper-x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1979F.github.io/"/>
  <updated>2020-11-22T05:45:15.040Z</updated>
  <id>http://1979F.github.io/</id>
  
  <author>
    <name>XIAO_JING</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jupyter notebook 导入和卸载 conda 虚拟环境</title>
    <link href="http://1979F.github.io/2020/11/21/Jupyter%20notebook%20%E5%AF%BC%E5%85%A5%E5%92%8C%E5%8D%B8%E8%BD%BD%20conda%20%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://1979F.github.io/2020/11/21/Jupyter notebook 导入和卸载 conda 虚拟环境/</id>
    <published>2020-11-21T03:10:32.000Z</published>
    <updated>2020-11-22T05:45:15.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、导入"><a href="#一、导入" class="headerlink" title="一、导入"></a>一、导入</h3><p>进入Anaconda Prompt，激活要使用的虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate xxx <span class="comment"># 你要使用的虚拟环境名称</span></span><br></pre></td></tr></table></figure><p>安装 ipykernel 插件， 建议使用 pip 进行安装， conda 安装容易失败</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ipykernel</span><br></pre></td></tr></table></figure><p>安装完成之后，键入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ipykernel install --name (你要导入的虚拟环境名称)  --display-name (你要显示的名称)</span><br></pre></td></tr></table></figure><a id="more"></a><p>例如：<br><img src="https://img-blog.csdnimg.cn/20201121110206620.png#pic" alt="在这里插入图片描述"><br>打开 jupyter notebook， 可以看到环境已经成功导入</p><p><img src="https://img-blog.csdnimg.cn/2020112111081565.png#pic" alt="在这里插入图片描述"></p><h3 id="二、删除"><a href="#二、删除" class="headerlink" title="二、删除"></a>二、删除</h3><p>使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter kernelspec remove (你要删除的虚拟环境名称  注意不是显示名称)</span><br></pre></td></tr></table></figure><p>例如：<br><img src="https://img-blog.csdnimg.cn/20201121111008966.png#pic" alt="在这里插入图片描述"><br>删除成功 ！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、导入&quot;&gt;&lt;a href=&quot;#一、导入&quot; class=&quot;headerlink&quot; title=&quot;一、导入&quot;&gt;&lt;/a&gt;一、导入&lt;/h3&gt;&lt;p&gt;进入Anaconda Prompt，激活要使用的虚拟环境。&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conda activate xxx &lt;span class=&quot;comment&quot;&gt;# 你要使用的虚拟环境名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;安装 ipykernel 插件， 建议使用 pip 进行安装， conda 安装容易失败&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install ipykernel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;安装完成之后，键入以下命令&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python -m ipykernel install --name (你要导入的虚拟环境名称)  --display-name (你要显示的名称)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leaf 叶子(张量)</title>
    <link href="http://1979F.github.io/2020/11/20/leaf%20%E5%8F%B6%E5%AD%90(%E5%BC%A0%E9%87%8F)/"/>
    <id>http://1979F.github.io/2020/11/20/leaf 叶子(张量)/</id>
    <published>2020-11-20T13:07:34.000Z</published>
    <updated>2020-11-22T05:46:02.559Z</updated>
    
    <content type="html"><![CDATA[<p>在pytorch的tensor类中,有个<strong>is_leaf</strong>的属性,姑且把它作为叶子节点. <strong>is_leaf</strong> 为<strong>False</strong>的时候,则不是叶子节点, <strong>is_leaf</strong>为<strong>True</strong>的时候为叶子节点(或者叶张量)</p><p><strong>所以问题来了</strong>: <strong><em>leaf的作用是什么?为什么要加 leaf?</em></strong><br> 我们都知道tensor中的 requires_grad()属性，当requires_grad()为True时我们将会记录tensor的运算过程并为自动求导做准备，但是并不是每个requires_grad()设为True的值都会在backward的时候得到相应的grad，它还必须为leaf。这就说明： <strong><em><code>leaf成为了在 requires_grad()下判断是否需要保留 grad的前提条件</code></em></strong></p><a id="more"></a>  <h4><a id="_is_leaf__8"></a><em>is_leaf()</em></h4> <ol><li>按照惯例,所有requires_grad为False的张量(Tensor) 都为叶张量( leaf Tensor)</li><li>requires_grad为True的张量(Tensor),如果他们是由用户创建的,则它们是叶张量(leaf Tensor).这意味着它们不是运算的结果,因此gra_fn为None</li><li>只有是叶张量的tensor在反向传播时才会将本身的grad传入的backward的运算中. 如果想得到当前tensor在反向传播时的grad, 可以用retain_grad()这个属性</li></ol> <p>例子:</p> <pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.signin(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a<span class="token punctuation">.</span>is_leaf<span class="token boolean">True</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b<span class="token punctuation">.</span>is_leaf<span class="token boolean">False</span><span class="token comment"># b was created by the operation that cast a cpu Tensor into a cuda Tensor</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> c <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> c<span class="token punctuation">.</span>is_leaf<span class="token boolean">False</span><span class="token comment"># c was created by the addition operation</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> d <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> d<span class="token punctuation">.</span>is_leaf<span class="token boolean">True</span><span class="token comment"># d does not require gradients and so has no operation creating it (that is tracked by the autograd engine)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> e <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> e<span class="token punctuation">.</span>is_leaf<span class="token boolean">True</span><span class="token comment"># e requires gradients and has no operations creating it</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">"cuda"</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> f<span class="token punctuation">.</span>is_leaf<span class="token boolean">True</span><span class="token comment"># f requires grad, has no operation creating it</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在pytorch的tensor类中,有个&lt;strong&gt;is_leaf&lt;/strong&gt;的属性,姑且把它作为叶子节点. &lt;strong&gt;is_leaf&lt;/strong&gt; 为&lt;strong&gt;False&lt;/strong&gt;的时候,则不是叶子节点, &lt;strong&gt;is_leaf&lt;/strong&gt;为&lt;strong&gt;True&lt;/strong&gt;的时候为叶子节点(或者叶张量)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;所以问题来了&lt;/strong&gt;: &lt;strong&gt;&lt;em&gt;leaf的作用是什么?为什么要加 leaf?&lt;/em&gt;&lt;/strong&gt;&lt;br&gt; 我们都知道tensor中的 requires_grad()属性，当requires_grad()为True时我们将会记录tensor的运算过程并为自动求导做准备，但是并不是每个requires_grad()设为True的值都会在backward的时候得到相应的grad，它还必须为leaf。这就说明： &lt;strong&gt;&lt;em&gt;&lt;code&gt;leaf成为了在 requires_grad()下判断是否需要保留 grad的前提条件&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习 PyTorch版》学习笔记（三）：线性回归</title>
    <link href="http://1979F.github.io/2020/10/09/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://1979F.github.io/2020/10/09/《动手学深度学习 PyTorch版》学习笔记（三）：线性回归/</id>
    <published>2020-10-09T06:59:41.000Z</published>
    <updated>2020-11-22T05:41:11.015Z</updated>
    
    <content type="html"><![CDATA[<p>线性回归输出是一个连续值，因此适用于回归问题。回归问题在实际中很常见，如预测房屋价格、气温、销售额等连续值的问题。</p><h3 id="一、基本要素"><a href="#一、基本要素" class="headerlink" title="一、基本要素"></a>一、基本要素</h3><p><code>摘自原书</code></p><p><strong>模型定义</strong></p><p>设房屋的面积为 x1，房龄为 x2，售出价格为 y。我们需要建立基于输入 x1 和 x2 来计算输出 y 的表达式，也就是 <strong><code>模型（model）</code></strong> 。顾名思义，线性回归假设输出与各个输入之间是线性关系：<br><img src="https://img-blog.csdnimg.cn/20201009100323806.png#pic_center" alt="在这里插入图片描述"><br>其中 w1 和 w2 是 <strong><code>权重（weight）</code></strong>，b 是 <strong><code>偏差（bias）</code></strong>，且均为标量。它们是线性回归模型的  参数（parameter）。模型输出 yˆ  是线性回归对真实价格 y 的预测或估计。我们通常允许它们之间有一定误差。</p><a id="more"></a><p><strong>模型训练</strong></p><p>我们需要通过数据来寻找特定的模型参数值，使模型在数据上的误差尽可能小。这个过程叫作 <strong><code>模型训练（model training）</code></strong>，包含三个要素：</p><ul><li>训练数据</li></ul><p>我们通常收集一系列的真实数据，例如多栋房屋的真实售出价格和它们对应的面积和房龄。我们希望在这个数据上面寻找模型参数来使模型的预测价格与真实价格的误差最小。在机器学习术语里，该数据集被称为 <strong><code>训练数据集（training data set）</code></strong> 或 <strong><code>训练集（training set）</code></strong> ，一栋房屋被称为一个  <strong><code>样本（sample）</code></strong>  ，其真实售出价格叫作 <strong><code>标签（label）</code></strong> ，用来预测标签的两个因素叫作  <strong><code>特征（feature）</code></strong>。特征用来表征样本的特点。<br><img src="https://img-blog.csdnimg.cn/20201009101536359.png#pic_center" alt="在这里插入图片描述"></p><ul><li>损失函数</li></ul><p>在模型训练中，我们需要衡量价格预测值与真实值之间的误差。通常我们会选取一个非负数作为误差，且数值越小表示误差越小。一个常用的选择是平方函数。它在评估索引为 i 的样本误差的表达式为：<br><img src="https://img-blog.csdnimg.cn/20201009101639483.png#pic_center" alt="在这里插入图片描述"><br>其中常数 1/2 使对平方项求导后的常数系数为1，这样在形式上稍微简单一些。显然，误差越小表示预测价格与真实价格越相近，且当二者相等时误差为0。给定训练数据集，这个误差只与模型参数相关，因此我们将它记为以模型参数为参数的函数。在机器学习里，将衡量误差的函数称为 <strong><code>损失函数（loss function）</code></strong> 。这里使用的平方误差函数也称为 <strong><code>平方损失（square loss）</code></strong> 。<br>通常，我们用训练数据集中所有样本误差的平均来衡量模型预测的质量，即<br><img src="https://img-blog.csdnimg.cn/20201009101817831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>优化算法</li></ul><p>当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫作 <strong><code>解析解（analytical solution）</code></strong> 。本节使用的线性回归和平方误差刚好属于这个范畴。然而，大多数深度学习模型并没有解析解，<strong>只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值</strong>。这类解叫作 <strong><code>数值解（numerical solution）</code></strong>。</p><p>在求数值解的优化算法中，<strong>小批量随机梯度下降（mini-batch stochastic gradient descent）</strong> 在深度学习中被广泛使用。它的算法很简单：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch）B，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。</p><p>在训练本节讨论的线性回归模型的过程中，模型的每个参数将作如下迭代：<br><img src="https://img-blog.csdnimg.cn/20201009103857374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201009103924921.png#pic_center" alt="在这里插入图片描述"></p><ul><li>模型预测</li></ul><p><img src="https://img-blog.csdnimg.cn/20201009105609277.png#pic_center" alt="在这里插入图片描述"></p><h3 id="二、线性回归的表示方法"><a href="#二、线性回归的表示方法" class="headerlink" title="二、线性回归的表示方法"></a>二、线性回归的表示方法</h3><p>如果我们对训练数据集里的3个房屋样本（索引分别为1、2和3）逐一预测价格<br><img src="https://img-blog.csdnimg.cn/20201009124246381.png#pic_center" alt="在这里插入图片描述"><br>现在，我们将上面3个等式转化成矢量计算。设：</p><p><img src="https://img-blog.csdnimg.cn/2020100912431818.png#pic_center" alt="在这里插入图片描述"><br>对3个房屋样本预测价格的矢量计算表达式为yˆ=Xw+b, 其中的加法运算使用了 <code>广播机制</code></p><p> <img src="https://img-blog.csdnimg.cn/20201009145117634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性回归输出是一个连续值，因此适用于回归问题。回归问题在实际中很常见，如预测房屋价格、气温、销售额等连续值的问题。&lt;/p&gt;&lt;h3 id=&quot;一、基本要素&quot;&gt;&lt;a href=&quot;#一、基本要素&quot; class=&quot;headerlink&quot; title=&quot;一、基本要素&quot;&gt;&lt;/a&gt;一、基本要素&lt;/h3&gt;&lt;p&gt;&lt;code&gt;摘自原书&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;模型定义&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;设房屋的面积为 x1，房龄为 x2，售出价格为 y。我们需要建立基于输入 x1 和 x2 来计算输出 y 的表达式，也就是 &lt;strong&gt;&lt;code&gt;模型（model）&lt;/code&gt;&lt;/strong&gt; 。顾名思义，线性回归假设输出与各个输入之间是线性关系：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201009100323806.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其中 w1 和 w2 是 &lt;strong&gt;&lt;code&gt;权重（weight）&lt;/code&gt;&lt;/strong&gt;，b 是 &lt;strong&gt;&lt;code&gt;偏差（bias）&lt;/code&gt;&lt;/strong&gt;，且均为标量。它们是线性回归模型的  参数（parameter）。模型输出 yˆ  是线性回归对真实价格 y 的预测或估计。我们通常允许它们之间有一定误差。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习 PyTorch版》学习笔记（二）：自动求梯度</title>
    <link href="http://1979F.github.io/2020/10/08/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%B1%82%E6%A2%AF%E5%BA%A6/"/>
    <id>http://1979F.github.io/2020/10/08/《动手学深度学习 PyTorch版》学习笔记（二）：自动求梯度/</id>
    <published>2020-10-08T15:28:53.000Z</published>
    <updated>2020-11-22T05:41:50.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、自动求梯度"><a href="#一、自动求梯度" class="headerlink" title="一、自动求梯度"></a>一、自动求梯度</h2><p><strong>1、requires_grad_(), detach(), torch.no_grad()的区别</strong><br>参考博客：<a href="https://www.jianshu.com/p/ff74ccae25f3" target="_blank" rel="noopener">https://www.jianshu.com/p/ff74ccae25f3</a></p><p><strong>2、.grad_fn</strong><br>每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function, 就是说该Tensor是不是通过某些运算得到的，若是，则grad_fn返回一个与这些运算相关的对象，否则是None。</p><a id="more"></a><p><strong>3、梯度</strong></p><ul><li>grad在反向传播过程中是累加的(accumulated)，这意味着每一次运行反向传播，梯度都会累加之前的梯度，所以一般在反向传播之前需把梯度清零 <code>.grad.data.zero_()</code></li><li>在y.backward()时，如果y是标量，则不需要为backward()传入任何参数；否则，需要传入一个与y同形的Tensor</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = <span class="number">2</span> * x</span><br><span class="line">z = y.view(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">2.</span>, <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">8.</span>]], grad_fn=&lt;ViewBackward&gt;)</span><br></pre></td></tr></table></figure><p>现在 z 不是一个标量，所以在调用backward时需要传入一个和z同形的权重向量进行加权求和得到一个标量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = torch.tensor([[<span class="number">1.0</span>, <span class="number">0.1</span>], [<span class="number">0.01</span>, <span class="number">0.001</span>]], dtype=torch.float)</span><br><span class="line">z.backward(v)</span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">2.0000</span>, <span class="number">0.2000</span>, <span class="number">0.0200</span>, <span class="number">0.0020</span>])</span><br></pre></td></tr></table></figure><p><strong>4、中断梯度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor(<span class="number">1.0</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y1 = x ** <span class="number">2</span> </span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    y2 = x ** <span class="number">3</span></span><br><span class="line">y3 = y1 + y2</span><br><span class="line"></span><br><span class="line">print(x.requires_grad)</span><br><span class="line">print(y1, y1.requires_grad) <span class="comment"># True</span></span><br><span class="line">print(y2, y2.requires_grad) <span class="comment"># False</span></span><br><span class="line">print(y3, y3.requires_grad) <span class="comment"># True</span></span><br><span class="line">y3.backward()</span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201008232836301.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、自动求梯度&quot;&gt;&lt;a href=&quot;#一、自动求梯度&quot; class=&quot;headerlink&quot; title=&quot;一、自动求梯度&quot;&gt;&lt;/a&gt;一、自动求梯度&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1、requires_grad_(), detach(), torch.no_grad()的区别&lt;/strong&gt;&lt;br&gt;参考博客：&lt;a href=&quot;https://www.jianshu.com/p/ff74ccae25f3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/ff74ccae25f3&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、.grad_fn&lt;/strong&gt;&lt;br&gt;每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function, 就是说该Tensor是不是通过某些运算得到的，若是，则grad_fn返回一个与这些运算相关的对象，否则是None。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习 PyTorch版》学习笔记（一）：数据操作</title>
    <link href="http://1979F.github.io/2020/10/08/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    <id>http://1979F.github.io/2020/10/08/《动手学深度学习 PyTorch版》学习笔记（一）：数据操作/</id>
    <published>2020-10-08T14:57:32.000Z</published>
    <updated>2020-11-22T05:42:22.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据操作"><a href="#一、数据操作" class="headerlink" title="一、数据操作"></a>一、数据操作</h2><p>在PyTorch中，torch.Tensor是存储和变换数据的主要工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;tensor&quot;这个单词一般可译作“张量”，张量可以看作是一个多维数组。</span><br><span class="line">标量可以看作是0维张量，向量可以看作1维张量，矩阵可以看作是二维张量。</span><br></pre></td></tr></table></figure><p><strong>1、torch.arange() 和torch.linspace</strong></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arange(s, e, step) =&gt; 从s到e，步长为step</span></span><br><span class="line">x8 = torch.arange(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># print(x8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># linspace(s, e, steps) =&gt; 从s到e，均匀切分成steps份</span></span><br><span class="line">x9 = torch.linspace(<span class="number">2</span>,<span class="number">8</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># print(x9)</span></span><br></pre></td></tr></table></figure><p><strong>2、torch.range() 和torch.arange() 的区别</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y=torch.range(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.dtype</span><br><span class="line">torch.float32</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z=torch.arange(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z.dtype</span><br><span class="line">torch.int64</span><br></pre></td></tr></table></figure><p><strong>3、torch.randn与torch.rand的区别</strong></p><p><strong>randn</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.randn(*sizes, out=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>返回一个包含了从<code>标准正态分布</code>中抽取的一组随机数的张量</p><p><code>size</code>：张量的形状</p><p><code>out</code>：结果张量</p><p><strong>rand</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.rand(*sizes, out=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>返回一个张量，包含了从区间[0, 1)的<code>均匀分布</code>中抽取的一组随机数</p><p><strong>4、NumPy数组与Tensor的互相转换</strong>（共享内存）</p><p>NumPy转Tensor：<code>torch.from_numpy()</code><br>Tensor转NumPy：<code>numpy()</code><br>另：可以使用 torch.tensor() 将NumPy数组转换成Tensor，但不再共享内存</p><p><strong>5、Tensor on GPU</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span>)          <span class="comment"># GPU</span></span><br><span class="line">    y = torch.ones_like(x, device=device)  <span class="comment"># 直接创建一个在GPU上的Tensor</span></span><br><span class="line">    x = x.to(device)                       <span class="comment"># 等价于 .to("cuda")</span></span><br><span class="line">    z = x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(<span class="string">"cpu"</span>, torch.double))       <span class="comment"># to()还可以同时更改数据类型</span></span><br></pre></td></tr></table></figure><p><strong>6、索引</strong></p><p>索引出来的结果与元数据共享内存 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">print(x)</span><br><span class="line">y = x[<span class="number">0</span>, :]  <span class="comment"># 取出第一行</span></span><br><span class="line">print(y)</span><br><span class="line">y += <span class="number">1</span></span><br><span class="line">print(y)</span><br><span class="line">print(x[<span class="number">0</span>, :]) <span class="comment"># 源tensor也被改了</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">tensor([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">tensor([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p><strong>7、广播机制</strong></p><p>当对两个形状不同的Tensor按元素运算时，可能会触发广播（broadcasting）机制：先适当复制元素使这两个Tensor形状相同后再按元素运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">1</span>, <span class="number">3</span>).view(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(x)</span><br><span class="line">y = torch.arange(<span class="number">1</span>, <span class="number">4</span>).view(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">print(y)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line">tensor([[<span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>]])</span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据操作&quot;&gt;&lt;a href=&quot;#一、数据操作&quot; class=&quot;headerlink&quot; title=&quot;一、数据操作&quot;&gt;&lt;/a&gt;一、数据操作&lt;/h2&gt;&lt;p&gt;在PyTorch中，torch.Tensor是存储和变换数据的主要工具。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;tensor&amp;quot;这个单词一般可译作“张量”，张量可以看作是一个多维数组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;标量可以看作是0维张量，向量可以看作1维张量，矩阵可以看作是二维张量。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;1、torch.arange() 和torch.linspace&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>指定tensorflow运行的GPU或CPU设备</title>
    <link href="http://1979F.github.io/2020/07/29/%E6%8C%87%E5%AE%9Atensorflow%E8%BF%90%E8%A1%8C%E7%9A%84GPU%E6%88%96CPU%E8%AE%BE%E5%A4%87/"/>
    <id>http://1979F.github.io/2020/07/29/指定tensorflow运行的GPU或CPU设备/</id>
    <published>2020-07-29T08:11:15.000Z</published>
    <updated>2020-11-22T05:44:23.748Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>如果 TensorFlow 指令中兼有 CPU 和 GPU 实现，当该指令分配到设备时，GPU 设备有优先权。</p></li><li><p>如果你的系统里有多个 GPU, 那么 ID 最小的 GPU 会默认使用。</p></li></ul><p>当我们要指定tensorflow运行的GPU或CPU设备时，可以使用<code>tf.device()</code>命令</p><p> 首先查看可用运算设备(CPU,GPU)</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python.client <span class="keyword">import</span> device_lib</span><br><span class="line">print(device_lib.list_local_devices())</span><br></pre></td></tr></table></figure><p>得到类似以下的输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[name: <span class="string">"/device:CPU:0"</span></span><br><span class="line">device_type: <span class="string">"CPU"</span></span><br><span class="line">memory_limit: <span class="number">268435456</span></span><br><span class="line">locality &#123;</span><br><span class="line">&#125;</span><br><span class="line">incarnation: <span class="number">13177083330855175469</span></span><br><span class="line">, name: <span class="string">"/device:GPU:0"</span></span><br><span class="line">device_type: <span class="string">"GPU"</span></span><br><span class="line">memory_limit: <span class="number">10968950375</span></span><br><span class="line">locality &#123;</span><br><span class="line">  bus_id: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">incarnation: <span class="number">6161624703599064583</span></span><br><span class="line">physical_device_desc: <span class="string">"device: 0, name: GeForce GTX 1080 Ti, pci bus id: 0000:00:08.0, compute capability: 6.1"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>name即是对应设备名称，一般来说（以各自实际情况为准，每个人的情况可能不同）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;/cpu:0&quot;：机器的 CPU。</span><br><span class="line">&quot;/device:GPU:0&quot;：机器的 GPU（如果有一个）。</span><br><span class="line">&quot;/device:GPU:1&quot;：机器的第二个 GPU（以此类推）。</span><br></pre></td></tr></table></figure><p><strong>使用命令tf.device()进行指定</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">'/device:GPU:0'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果 TensorFlow 指令中兼有 CPU 和 GPU 实现，当该指令分配到设备时，GPU 设备有优先权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你的系统里有多个 GPU, 那么 ID 最小的 GPU 会默认使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当我们要指定tensorflow运行的GPU或CPU设备时，可以使用&lt;code&gt;tf.device()&lt;/code&gt;命令&lt;/p&gt;&lt;p&gt; 首先查看可用运算设备(CPU,GPU)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>VMware安装CentOS7超详细版</title>
    <link href="http://1979F.github.io/2020/02/11/VMware%E5%AE%89%E8%A3%85CentOS7%E8%B6%85%E8%AF%A6%E7%BB%86%E7%89%88/"/>
    <id>http://1979F.github.io/2020/02/11/VMware安装CentOS7超详细版/</id>
    <published>2020-02-11T07:44:47.000Z</published>
    <updated>2020-11-22T04:44:51.424Z</updated>
    
    <content type="html"><![CDATA[<p><strong>写在前面</strong><br>云计算与分布式这门课程的老师让我们使用vmware安装好centos7.6并配置好Java编译环境，刚好复习一波，下面是详细的安装过程。<br><strong>准备工作</strong></p><ul><li>VMware，我用的是VMware Workstation Pro 15，下载与安装方法就不提了毕竟重点在后头。<br><img src="https://img-blog.csdnimg.cn/20200211145314796.png" alt="在这里插入图片描述"></li><li>CentOS7镜像文件，由于7.6版本已经停更，这里我用的是7.7版本。<br>下载地址  <a href="http://isoredirect.centos.org/centos/7/isos/x86_64" target="_blank" rel="noopener">http://isoredirect.centos.org/centos/7/isos/x86_64</a><br>习惯性选择阿里的镜像，点击下载即可。<br><img src="https://img-blog.csdnimg.cn/20200211144757837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><strong>安装过程</strong></li></ul><a id="more"></a><p>打开vmware，点击<code>创建新的虚拟机</code><br><img src="https://img-blog.csdnimg.cn/20200211145350363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择<code>自定义配置</code>，点击下一步<br><img src="https://img-blog.csdnimg.cn/20200211145515558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里直接默认下一步<br><img src="https://img-blog.csdnimg.cn/20200211145556890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择<code>稍后安装操作系统</code>，点击下一步<br><img src="https://img-blog.csdnimg.cn/20200211145636922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>客户机操作系统选择<code>Linux</code>，版本选择<code>CentOS 7 64位</code>，点击下一步<br><img src="https://img-blog.csdnimg.cn/20200211145734446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>虚拟机名称可以自定义，这里建议以<code>见名知意</code>为原则，位置尽量放在C盘外的其他盘符，这里我选择的是D盘。<br><img src="https://img-blog.csdnimg.cn/20200211145937790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>处理器数量和每个处理器的内核数可根据自己电脑配置进行选择。这里<code>默认都选择1</code>。<br><img src="https://img-blog.csdnimg.cn/20200211150050763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>同样的，虚拟机内存也依据自己电脑配置进行选择，由于我的电脑是8GB，所以这里我选<code>2GB</code>。<br><img src="https://img-blog.csdnimg.cn/20200211150212890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>网络连接选择<code>NAT</code><br><img src="https://img-blog.csdnimg.cn/20200211150239867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>后两项默认推荐，点击下一步。<br><img src="https://img-blog.csdnimg.cn/20200211150310864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200211150315173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击创建新虚拟磁盘<br><img src="https://img-blog.csdnimg.cn/2020021115033458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最大磁盘大小按需分配，我给了<code>20GB</code>，选择<code>将虚拟磁盘拆分成多个文件</code>。<br><img src="https://img-blog.csdnimg.cn/2020021115042989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>默认点击下一步<br><img src="https://img-blog.csdnimg.cn/20200211150444117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到CentOS7已经添加进去了<br><img src="https://img-blog.csdnimg.cn/20200211150511685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>右键CentOS7,点击设置进入设置页面，点击<code>CD/DVD</code>,<code>使用ISO映像文件</code>，选择之前下载的文件即可。</p><p><img src="https://img-blog.csdnimg.cn/20200211150648314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>开启虚拟机，见到如下页面，选择<code>Install CentOS Linux 7</code>,直接Enter<br><img src="https://img-blog.csdnimg.cn/20200211150751239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>滑动右侧滚动条选择<code>中文=》简体中文</code>，英文好的同学当然可以选择英文<br><img src="https://img-blog.csdnimg.cn/20200211152702258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里配置一些基本信息<br>1、点击安装源，进入之后直接选择done，警告符号随即消失。<br>2、软件选择：<code>GNOME桌面</code>，一个友好的图形化界面<br>3、根据需要禁用Kdump<br>4、自动分区，一般化为4个分区，如图所示</p><p><img src="https://img-blog.csdnimg.cn/20200211153016322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200211153021164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211153033776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200211153039336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211153046588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>完成后点击开始安装<br><img src="https://img-blog.csdnimg.cn/2020021115310720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>安装过程中会弹出用户设置界面，填好并<code>记住密码</code>。<br><img src="https://img-blog.csdnimg.cn/20200211153156193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200211153159822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200211153206327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>安装完成后点击<code>重启</code>，看到如下界面<br><img src="https://img-blog.csdnimg.cn/20200211153325530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击<code>接受许可</code><br><img src="https://img-blog.csdnimg.cn/20200211153344606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>设置一下网络<br><img src="https://img-blog.csdnimg.cn/20200211153359611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击完成配置<br><img src="https://img-blog.csdnimg.cn/20200211153421447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>现在可以使用之前创建的用户进行登录了<br><img src="https://img-blog.csdnimg.cn/20200211153438473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>登录成功后可看到图形化界面<br><img src="https://img-blog.csdnimg.cn/20200211153443108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>上网</strong></p><p>开启windows下的VMnet8<br><img src="https://img-blog.csdnimg.cn/20200211153555503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>cmd窗口ping出主机ip地址<br><img src="https://img-blog.csdnimg.cn/20200211153638636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开有线设置<br><img src="https://img-blog.csdnimg.cn/20200211153705525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>网络=》开启，点击设置图标<br><img src="https://img-blog.csdnimg.cn/2020021115373027.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择自动连接<br><img src="https://img-blog.csdnimg.cn/2020021115375095.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200211153816163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开终端，使用ifconfig命令获取ip地址<br><img src="https://img-blog.csdnimg.cn/20200211153845106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在终端ping下windows 中VMnet8的IP地址，若出现下图所示信息，则表示linux的ip地址设置成功。<br>此时，若windows能上网，则linux也能上网<br><img src="https://img-blog.csdnimg.cn/20200211154126108.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>打开火狐浏览器，上网成功！<br><img src="https://img-blog.csdnimg.cn/20200211154148568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;br&gt;云计算与分布式这门课程的老师让我们使用vmware安装好centos7.6并配置好Java编译环境，刚好复习一波，下面是详细的安装过程。&lt;br&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;VMware，我用的是VMware Workstation Pro 15，下载与安装方法就不提了毕竟重点在后头。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200211145314796.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/li&gt;
&lt;li&gt;CentOS7镜像文件，由于7.6版本已经停更，这里我用的是7.7版本。&lt;br&gt;下载地址  &lt;a href=&quot;http://isoredirect.centos.org/centos/7/isos/x86_64&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://isoredirect.centos.org/centos/7/isos/x86_64&lt;/a&gt;&lt;br&gt;习惯性选择阿里的镜像，点击下载即可。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200211144757837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;strong&gt;安装过程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://1979F.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot集成Spring Security（一）登录注销</title>
    <link href="http://1979F.github.io/2020/02/05/SpringBoot%E9%9B%86%E6%88%90Spring%20Security%EF%BC%88%E4%B8%80%EF%BC%89%E7%99%BB%E5%BD%95%E6%B3%A8%E9%94%80/"/>
    <id>http://1979F.github.io/2020/02/05/SpringBoot集成Spring Security（一）登录注销/</id>
    <published>2020-02-05T10:44:17.000Z</published>
    <updated>2020-11-22T05:46:47.459Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/tsundere_x/article/details/104196411" target="_blank" rel="noopener">SpringBoot集成Spring Security（二）注册 、密码加密、修改密码</a><br><strong>写在前面</strong><br>Spring Security是一种基于 Spring AOP 和 Servlet 过滤器的安全框架。它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理身份确认和授权。<br>由于最近写的项目用到了这方面知识，这里做一些总结。下面直接看代码<br><strong>一、创建项目</strong><br>这里以<code>多模块项目</code>为例。</p><a id="more"></a><p><code>多模块项目优点：</code> 帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便各个模块的构建，而不用每次都构建整个项目，使得针对某个模块的特殊控制更为方便。<br><img src="https://img-blog.csdnimg.cn/20200205181403708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>二、引入pom依赖</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>三、web层</strong></p><p>项目最核心的代码<br><code>SecurityConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiao</span></span><br><span class="line"><span class="comment"> * 使用springsecurity对用户登录、注销以及权限进行控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.userDetailsService(studentService).passwordEncoder(<span class="keyword">new</span> BCryptPasswordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line"><span class="comment">//                .authenticationProvider(authenticationProvider())</span></span><br><span class="line">                .httpBasic()</span><br><span class="line">                <span class="comment">//未登录时</span></span><br><span class="line">                .authenticationEntryPoint((request,response,authException) -&gt; &#123;</span><br><span class="line">                    response.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    RespBean error = RespBean.error(<span class="string">"未登录"</span>);</span><br><span class="line">                    String s = <span class="keyword">new</span> ObjectMapper().writeValueAsString(error);</span><br><span class="line">                    out.write(s);</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated() <span class="comment">//必须授权才能范围</span></span><br><span class="line"></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin() <span class="comment">//使用自带的登录</span></span><br><span class="line">                .usernameParameter(<span class="string">"username"</span>)</span><br><span class="line">                .passwordParameter(<span class="string">"password"</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">                <span class="comment">//登录失败，返回json</span></span><br><span class="line">                .failureHandler(<span class="keyword">new</span> AuthenticationFailureHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationFailure</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                        resp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        RespBean respBean = RespBean.error(<span class="string">"登录失败!"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> UsernameNotFoundException || exception <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">                            respBean.setMsg(<span class="string">"用户名或者密码输入错误，请重新输入!"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">                            respBean.setMsg(<span class="string">"账户被禁用"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            respBean.setMsg(<span class="string">"未知错误"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.write(objectMapper.writeValueAsString(respBean));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//登录成功，返回json</span></span><br><span class="line">                .successHandler(<span class="keyword">new</span> AuthenticationSuccessHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAuthenticationSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        Student student = (Student) authentication.getPrincipal();</span><br><span class="line">                        student.setPassword(<span class="keyword">null</span>);</span><br><span class="line">                        RespBean ok = RespBean.ok(<span class="string">"登录成功!"</span>, student);</span><br><span class="line">                        String s = <span class="keyword">new</span> ObjectMapper().writeValueAsString(ok);</span><br><span class="line">                        out.write(s);</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .and()</span><br><span class="line">                .exceptionHandling()</span><br><span class="line">                <span class="comment">//没有权限，返回json</span></span><br><span class="line">                .accessDeniedHandler((request,response,ex) -&gt; &#123;</span><br><span class="line">                    response.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                    response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(RespBean.error(<span class="string">"权限不足"</span>)));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                .and()</span><br><span class="line">                .logout()</span><br><span class="line">                <span class="comment">//退出成功，返回json</span></span><br><span class="line">                .logoutSuccessHandler(<span class="keyword">new</span> LogoutSuccessHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLogoutSuccess</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                        resp.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">                        PrintWriter out = resp.getWriter();</span><br><span class="line">                        out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(RespBean.ok(<span class="string">"注销成功!"</span>)));</span><br><span class="line">                        out.flush();</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll();</span><br><span class="line">        <span class="comment">//开启跨域访问</span></span><br><span class="line">        http.cors().disable();</span><br><span class="line">        <span class="comment">//开启模拟请求，比如API POST测试工具的测试，不开启时，API POST为报403错误</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于在header里面增加token等类似情况，放行所有OPTIONS请求。</span></span><br><span class="line">        web.ignoring()</span><br><span class="line">                .antMatchers(HttpMethod.OPTIONS, <span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四、mapper层</strong></p><p><code>mapper下的StudentMapper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">loadUserBySno</span><span class="params">(String sno)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resource下的StudentMapper.xml**</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.jxnu.os.mapper.StudentMapper&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.jxnu.os.model.Student&quot;&gt;</span><br><span class="line">        &lt;id column=&quot;id&quot; property=&quot;id&quot; jdbcType=&quot;INTEGER&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;username&quot; property=&quot;username&quot; jdbcType=&quot;VARCHAR&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;sno&quot; property=&quot;sno&quot; jdbcType=&quot;VARCHAR&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;s_sex&quot; property=&quot;s_sex&quot; jdbcType=&quot;CHAR&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;t_id&quot; property=&quot;t_id&quot; jdbcType=&quot;INTEGER&quot;/&gt;</span><br><span class="line">        &lt;result column=&quot;password&quot; property=&quot;password&quot; jdbcType=&quot;VARCHAR&quot;/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;loadUserByUsername&quot; resultMap=&quot;BaseResultMap&quot;&gt;</span><br><span class="line">        select * from student where username=#&#123;username&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p><strong>五、model层</strong></p><p><code>model下的Student.java</code><br>注意一定要<code>implements UserDetails</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiao</span></span><br><span class="line"><span class="comment"> * 学生实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    <span class="comment">//学生主键ID</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">//学生姓名</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="comment">//登录密码</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;? extends GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthorities</span><span class="params">(Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>六、service层</strong><br><code>service下的StudentService.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UsernameNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Student student = studentMapper.loadUserBySno(username);</span><br><span class="line">        <span class="keyword">if</span> (student == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UsernameNotFoundException(<span class="string">"用户不存在"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tsundere_x/article/details/104196411&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SpringBoot集成Spring Security（二）注册 、密码加密、修改密码&lt;/a&gt;&lt;br&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;br&gt;Spring Security是一种基于 Spring AOP 和 Servlet 过滤器的安全框架。它提供全面的安全性解决方案，同时在 Web 请求级和方法调用级处理身份确认和授权。&lt;br&gt;由于最近写的项目用到了这方面知识，这里做一些总结。下面直接看代码&lt;br&gt;&lt;strong&gt;一、创建项目&lt;/strong&gt;&lt;br&gt;这里以&lt;code&gt;多模块项目&lt;/code&gt;为例。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="后端" scheme="http://1979F.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Cisco Packet Tracer的安装与汉化</title>
    <link href="http://1979F.github.io/2020/02/02/Cisco%20Packet%20Tracer%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B1%89%E5%8C%96/"/>
    <id>http://1979F.github.io/2020/02/02/Cisco Packet Tracer的安装与汉化/</id>
    <published>2020-02-02T02:20:41.000Z</published>
    <updated>2020-11-22T04:44:39.172Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、下载</strong><br>1、官网下载<br>首先去<a href="https://www.netacad.com/zh-hans/courses/packet-tracer" target="_blank" rel="noopener">思科官网</a>下载对应的压缩包。<br>点击图中所示注册下载按钮按照提示步骤完成注册<br><img src="https://img-blog.csdnimg.cn/20200202095928743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200202100117247.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注册之后登陆，点击导航栏中资源-&gt;所有资源，即可看到各版本压缩包。<br>PTUI文件夹下有对应的汉化包，有需要的也可以自行下载。<br><img src="https://img-blog.csdnimg.cn/20200202100315657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200202100402959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">2、网盘获取<br>为方便大家下载我已经把安装包和汉化包放在了百度网盘中（7.2.1版本）<br>链接：链接：<a href="https://pan.baidu.com/s/15_HGAcYW-pfbwyyWCwVdaA" target="_blank" rel="noopener">https://pan.baidu.com/s/15_HGAcYW-pfbwyyWCwVdaA</a><br>提取码：li5u<br><strong>二、安装</strong><br>安装步骤比较简单<br>1、解压缩之后双击.exe文件开始安装软件。<br><img src="https://img-blog.csdnimg.cn/20200202101320397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">2、一路默认next即可（中途可以更换安装目录，自己随意）<br>3、安装完成之后，点击finsh完成安装。<br><img src="https://img-blog.csdnimg.cn/20200202101448104.png" alt="在这里插入图片描述"><br><strong>三、汉化</strong><br>1、将Simplified Chinese.ptl文件复制进languages文件夹下。<br><img src="https://img-blog.csdnimg.cn/20200202101621245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">2、菜单栏中选择<code>Option-&gt;Preferences</code>,Select Language选择对应文件后重启服务即可（我这里是已经汉化成功的界面）。大功告成！<br><img src="https://img-blog.csdnimg.cn/20200202101858825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、下载&lt;/strong&gt;&lt;br&gt;1、官网下载&lt;br&gt;首先去&lt;a href=&quot;https://www.netacad.com/zh-hans/courses/packet-tracer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;思科官网
      
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://1979F.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述（二）</title>
    <link href="http://1979F.github.io/2020/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://1979F.github.io/2020/02/01/计算机网络概述（二）/</id>
    <published>2020-02-01T06:24:22.000Z</published>
    <updated>2020-11-22T05:42:52.771Z</updated>
    
    <content type="html"><![CDATA[<p><strong>网络协议</strong><br>           网络协议规定了通信双方具体的通信规则，包括消息的传递细节。<br>协议的三要素：<em>语法、语义、同步</em><br> <code>语义</code>：对构成协议元素的含义的解释，即“讲什么”。<br> <code>语法</code>：数据与控制信息的结构或格式，即“怎么讲”。<br> <code>同步</code>：规定了事件的执行顺序。<br><strong>交换的概念和分类</strong><br><strong>概念</strong>：网络中间结点按照某种方式动态地分配传输线路的资源，从输入链路选择连通到输出链路的过程称为交换。<br><strong>分类</strong>：电路交换技术、分组交换技术、报文交换技术<br>电路交换技术特性：<br><img src="https://img-blog.csdnimg.cn/20200201141322738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1）提供面向连接的服务（拨号建立连接，通信，挂机释放连接）<br>电路交换最典型的例子就是打电话，当打电话时，别人无法打进同一个电话，资源独占。<br>每次打电话时首先要拨号建立连接，打完电话需要挂机释放连接，属于面向连接的服务。<br>2）资源独占，价格高<br>3）通信可靠性高</p><a id="more"></a><p>分组交换技术核心思想：<br>分组：将需要传输的较大的文件或报文分成多个小的包（分组）。<br>存储转发：分组交换机（路由器）收到分组，存储到缓存中，排队等待处理，最后选择输出链路转发。<br>资源共享：由于存储转发使得多个用户可以共享一段链路。资源共享是宏观的。<br><img src="https://img-blog.csdnimg.cn/20200201141348731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>为什么要分组？</code></p><ul><li>数据越大，传输中出错的概率越大，重传分组的代价越高</li><li>数据越大，路由器缓存越大，不利于存储转发</li></ul><p><code>分组分多大最合理？</code></p><ul><li>低出错不影响路由器存储转发的前提下尽可能大</li><li>一般链路的分组最大为1500Byte</li></ul><p><code>每个分组加上首部有什么作用？</code></p><ul><li>首部实现了协议的规则<ul><li>使接收方能够有效的将分组还原</li></ul></li></ul><p><code>分组交换网的优点和缺点？</code></p><ul><li>优点：适合计算机通信，实现宏观上的资源共享，通信效率高。</li><li>缺点：存储交换排队导致网络延迟很大甚至出现网络拥塞。</li></ul><p>报文交换技术特点：<br>不分组、存储转发、资源共享<br><img src="https://img-blog.csdnimg.cn/20200201141429784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>网络的带宽和时延</strong><br><strong>带宽</strong>：网络的最高数据传输率，即每秒最高能传输多少bit的数据。单位：<code>b/s或bps（每秒钟可以发送的比特数）</code><br>一个网络的带宽是该网络所有链路带宽的最小值。</p><p><strong>吞吐量</strong>：在单位时间内实际通过某个网络（或信道、接口）的数据量，单位<code>b/s</code>。<br>   吞吐量是网络实际的带宽。<br>传播速度：信号（即电磁波）在传输介质上的传播速率，单位m/s（米/秒）或千米/小时。</p><p><strong>分组交换网络的时延</strong><br><code>传输时延</code>（发送时延）：数据从结点发送到链路上的时间<br><code>传播时延</code>：信号从链路的一端发送到另一端传播的时间<br><code>接收时延</code>：一般作为结点处理时延考虑<br><code>结点处理时延</code>（排队转发时延）：路由器接收数据，排队等待处理，查找转发表决定输出链路所花费的时间</p><p>分组交换网络时延的计算<br><code>传输时延=数据大小/网络带宽</code><br>由网络带宽、数据大小决定</p><p><code>传播时延=链路长度/传播速度</code><br>由传播介质、传播速度、链路长度决定</p><p><strong>分组交换网的网络拥塞</strong><br><strong>网络拥塞现象</strong>：当中间节点（路由器）收到数据的速度大于发出数据的速度时，缓冲将被填满，部分分组将被丢弃，网络出现拥塞。<br><strong>往返时延RTT</strong><br>RTT（Roud-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的确认为止总共经历的时延。<br>RTT反映了分组传输总的时延，使用ping命令可以测量RTT。<br><strong>时延带宽积</strong><br>链路的时延带宽积又称为以比特为单位的链路长度。<br>    <code>时延带宽积 = 传播时延 x 带宽</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;网络协议&lt;/strong&gt;&lt;br&gt;           网络协议规定了通信双方具体的通信规则，包括消息的传递细节。&lt;br&gt;协议的三要素：&lt;em&gt;语法、语义、同步&lt;/em&gt;&lt;br&gt; &lt;code&gt;语义&lt;/code&gt;：对构成协议元素的含义的解释，即“讲什么”。&lt;br&gt; &lt;code&gt;语法&lt;/code&gt;：数据与控制信息的结构或格式，即“怎么讲”。&lt;br&gt; &lt;code&gt;同步&lt;/code&gt;：规定了事件的执行顺序。&lt;br&gt;&lt;strong&gt;交换的概念和分类&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;概念&lt;/strong&gt;：网络中间结点按照某种方式动态地分配传输线路的资源，从输入链路选择连通到输出链路的过程称为交换。&lt;br&gt;&lt;strong&gt;分类&lt;/strong&gt;：电路交换技术、分组交换技术、报文交换技术&lt;br&gt;电路交换技术特性：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200201141322738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;1）提供面向连接的服务（拨号建立连接，通信，挂机释放连接）&lt;br&gt;电路交换最典型的例子就是打电话，当打电话时，别人无法打进同一个电话，资源独占。&lt;br&gt;每次打电话时首先要拨号建立连接，打完电话需要挂机释放连接，属于面向连接的服务。&lt;br&gt;2）资源独占，价格高&lt;br&gt;3）通信可靠性高&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://1979F.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>网络的性能指标与分组交换网络</title>
    <link href="http://1979F.github.io/2020/02/01/%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C/"/>
    <id>http://1979F.github.io/2020/02/01/网络的性能指标与分组交换网络/</id>
    <published>2020-02-01T06:14:53.000Z</published>
    <updated>2020-11-22T05:43:42.888Z</updated>
    
    <content type="html"><![CDATA[<p>同个人网站：<a href="http://tsundere-x.top/" target="_blank" rel="noopener">http://tsundere-x.top/</a><br><a href="https://blog.csdn.net/tsundere_x/article/details/104154667" target="_blank" rel="noopener"><strong>计算机网络概述（三）</strong></a><br><strong><a href="https://blog.csdn.net/tsundere_x/article/details/104122668" target="_blank" rel="noopener">计算机网络概述（一）</a></strong></p><h5 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h5><pre><code>网络协议规定了通信双方具体的通信规则，包括消息的传递细节。</code></pre><p>协议的三要素：<em>语法、语义、同步</em><br> <code>语义</code>：对构成协议元素的含义的解释，即“讲什么”。<br> <code>语法</code>：数据与控制信息的结构或格式，即“怎么讲”。<br> <code>同步</code>：规定了事件的执行顺序。</p><a id="more"></a><h5 id="交换的概念和分类"><a href="#交换的概念和分类" class="headerlink" title="交换的概念和分类"></a>交换的概念和分类</h5><p><strong>概念</strong>：网络中间结点按照某种方式动态地分配传输线路的资源，从输入链路选择连通到输出链路的过程称为交换。<br><strong>分类</strong>：电路交换技术、分组交换技术、报文交换技术</p><p><strong>电路交换技术</strong></p><img src="https://img-blog.csdnimg.cn/20200201141322738.png" width="50%"><p><strong>特性</strong><br>1）提供面向连接的服务（拨号建立连接，通信，挂机释放连接）<br>电路交换最典型的例子就是打电话，当打电话时，别人无法打进同一个电话，资源独占。<br>每次打电话时首先要拨号建立连接，打完电话需要挂机释放连接，属于面向连接的服务。<br>2）资源独占，价格高<br>3）通信可靠性高</p><p><strong>分组交换技术</strong></p><img src="https://img-blog.csdnimg.cn/20200601152435366.png" width="50%"><p><strong>核心思想：</strong><br><code>分组</code>：将需要传输的较大的文件或报文分成多个小的包（分组）。<br><code>存储转发</code>：分组交换机（路由器）收到分组，存储到缓存中，排队等待处理，最后选择输出链路转发。<br><code>资源共享</code>：由于存储转发使得多个用户可以共享一段链路。资源共享是宏观的。</p><img src="https://img-blog.csdnimg.cn/20200201141348731.png" width="50%"><p><code>为什么要分组？</code></p><ul><li>数据越大，传输中出错的概率越大，重传分组的代价越高</li><li>数据越大，路由器缓存越大，不利于存储转发</li></ul><p><code>分组分多大最合理？</code></p><ul><li>低出错不影响路由器存储转发的前提下尽可能大</li><li>一般链路的分组最大为1500Byte</li></ul><p><code>每个分组加上首部有什么作用？</code></p><ul><li>首部实现了协议的规则<ul><li>使接收方能够有效的将分组还原</li></ul></li></ul><p><code>分组交换网的优点和缺点？</code></p><ul><li>优点：适合计算机通信，实现宏观上的资源共享，通信效率高。</li><li>缺点：存储交换排队导致网络延迟很大甚至出现网络拥塞。</li></ul><p>报文交换技术特点：<br>不分组、存储转发、资源共享</p><img src="https://img-blog.csdnimg.cn/20200201141429784.png" width="50%"><p><strong>三种交换技术比较</strong></p><img src="https://img-blog.csdnimg.cn/20200601152746688.png" width="50%"><h5 id="网络的性能指标"><a href="#网络的性能指标" class="headerlink" title="网络的性能指标"></a>网络的性能指标</h5><p><strong>网络的带宽和时延</strong><br><strong>带宽</strong>：网络的最高数据传输率，即每秒最高能传输多少bit的数据。单位：<code>b/s或bps（每秒钟可以发送的比特数）</code><br>一个网络的带宽是该网络所有链路带宽的最小值。</p><img src="https://img-blog.csdnimg.cn/20200416160606139.png" width="50%"><p><code>网络带宽的进一步说明</code></p><ul><li>为什么20Mb/s的带宽下载速度约2.4MB/S？</li></ul><p><code>网络带宽单位</code>：1Mb/s = 10^3^kb/s = 10^6^b/s<br><code>计算机存储单位</code>：1M = 1024K = 2^20^Byte = 8*2^20^bit</p><p><strong>吞吐量</strong>：在单位时间内实际通过某个网络（或信道、接口）的数据量，单位<code>b/s</code>。</p><ul><li>吞吐量是网络实际的带宽。</li><li>带宽是网络最高的吞吐量</li></ul><p><strong>传播速度</strong>：信号（即电磁波）在传输介质上的传播速率，单位m/s（米/秒）或千米/小时。</p><p><strong>分组交换网络的时延</strong></p><img src="https://img-blog.csdnimg.cn/20200416161238148.png" width="50%"><p><code>传输时延</code>（发送时延）：数据从结点发送到链路上的时间<br><code>传播时延</code>：信号从链路的一端发送到另一端传播的时间<br><code>接收时延</code>：一般作为结点处理时延考虑<br><code>结点处理时延</code>（排队转发时延）：路由器接收数据，排队等待处理，查找转发表决定输出链路所花费的时间</p><ul><li>在移动网访问部署在电信的服务器为什么会很慢？</li></ul><img src="https://img-blog.csdnimg.cn/20200416162116835.png" width="50%"><p>分组交换网络时延的计算<br><code>传输时延=数据大小/网络带宽</code><br>由网络带宽、数据大小决定</p><p><code>传播时延=链路长度/传播速度</code><br>由传播介质、传播速度、链路长度决定</p><p><strong>分组交换网的网络拥塞</strong><br><strong>网络拥塞现象</strong>：当中间节点（路由器）收到数据的速度大于发出数据的速度时，缓冲将被填满，部分分组将被丢弃，网络出现拥塞。<br><strong>往返时延RTT</strong><br>RTT（Roud-Trip Time）表示从发送端发送数据开始，到发送端收到来自接收端的确认为止总共经历的时延。<br>RTT反映了分组传输总的时延，使用ping命令可以测量RTT。<br><strong>时延带宽积</strong><br>链路的时延带宽积又称为以比特为单位的链路长度。<br>    <code>时延带宽积 = 传播时延 x 带宽</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同个人网站：&lt;a href=&quot;http://tsundere-x.top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://tsundere-x.top/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/tsundere_x/article/details/104154667&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;计算机网络概述（三）&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;&lt;strong&gt;&lt;a href=&quot;https://blog.csdn.net/tsundere_x/article/details/104122668&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;计算机网络概述（一）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h5 id=&quot;网络协议&quot;&gt;&lt;a href=&quot;#网络协议&quot; class=&quot;headerlink&quot; title=&quot;网络协议&quot;&gt;&lt;/a&gt;网络协议&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;网络协议规定了通信双方具体的通信规则，包括消息的传递细节。&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;协议的三要素：&lt;em&gt;语法、语义、同步&lt;/em&gt;&lt;br&gt; &lt;code&gt;语义&lt;/code&gt;：对构成协议元素的含义的解释，即“讲什么”。&lt;br&gt; &lt;code&gt;语法&lt;/code&gt;：数据与控制信息的结构或格式，即“怎么讲”。&lt;br&gt; &lt;code&gt;同步&lt;/code&gt;：规定了事件的执行顺序。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://1979F.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述（一）</title>
    <link href="http://1979F.github.io/2020/01/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://1979F.github.io/2020/01/31/计算机网络概述（一）/</id>
    <published>2020-01-31T04:13:22.000Z</published>
    <updated>2020-11-22T05:42:45.439Z</updated>
    
    <content type="html"><![CDATA[<pre><code>计算机网络 = 通信技术 + 计算机技术计算机网络是通信技术海域计算机技术紧密结合的产物计算机网络就是一种通信网络</code></pre><p><strong>什么是计算机网络？</strong><br><code>广义的计算机网络定义</code>：在协议控制下，由一台或多台计算机、若干台终端设备、数据传输设备，以及用于终端和计算机之间、或者若干台计算机之间数据流动的通信控制处理机组成的系统的集合。<br><code>计算机网络</code>：是一个将分散的、具有独立功能的计算机系统，通过通信设备（交换机、路由器等）与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。<br><img src="https://img-blog.csdnimg.cn/20200131120111597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>计算机网络就是互连的、自治的计算机集合（公认的概念）</p><a id="more"></a><p><code>自治-无主从关系</code>   ： 一台计算机不能控制另一台计算机<br><code>互连-互联互通</code>        ：通过通信链路—》网络中两个节点之间的物理通道称为通信链路。通信链路的传输介质主要有双绞线、光纤和微波。</p><p><strong>计算机网络的发展</strong><br>20世纪60年代：<code>分组交换思想</code>的提出，可能比世界上第一个网络的意义更加重大，它使得网络传输数据成为可能，并一直沿用到今天。</p><p>20世纪70~80年代：<code>TCP/IP协议思想</code>的提出，提供了这样一种可能：即不同厂商生产的计算机，不同结构的网络间实现互通。所以它既是一个协议簇，更是一种标准，它使得网络飞速向前发展。</p><p>20世纪90年代：<code>Web技术</code>真正把网络引入民用行业，使得网络行业生机勃勃，飞速发展。随着网络的逐步普及，网络用户在这个时期飞速增长，现如今各行各业都已经离不开网络</p><p><strong>计算机网络的功能</strong><br><code>数据通信</code>：数据通信是计算机网络最基本、最重要的功能，包括连接控制，传输控制，差错控制，流量控制，路由选择，多路复用等子功能。<br><code>资源共享</code>：包括硬件资源、软件资源和数据资源。<br><code>分布式处理</code>：当计算机网络中的某个计算机负荷过重时，可以将其处理的任务传送给网络中的其他计算机系统进行处理，利用空闲计算机资源提高整个系统的利用率。典型的有Hadoop平台。<br><code>提高可靠性</code>：计算机网络中的每台计算机可以通过网络互为替代机，一台计算机宕机了可有另一台计算机替代。<br><code>负载均衡</code>：将工作任务均衡地分配给计算机网络中的各台计算机。</p><p><strong>计算机网络的组成</strong><br><code>物理组成</code>（硬件、软件、协议三大部分）<br> 1、<em>硬件</em>：由主机、通信处理机、通信线路（包括有线线路和无线线路）和交换设备（交换机等连接设备）组成。<br> 2、<em>软件</em>：主要包括实现资源共享的软件和方便用户使用的各种工具软件（如QQ）。<br> 3、<em>协议</em>：就是一种规则，如汽车在道路上行驶必须遵循交通规则一样，数据在线路上传输也必须遵循一定的规则。<br><code>工作方式组成</code>（边缘部分、核心部分）<br>1、<em>边缘部分</em>：由所有链接在互联网上，供用户直接使用的主机组成，用来进行通信和资源共享—》C/S方式、P2P方式。<br>2、<em>核心部分</em>：由大量的网络和链接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。<br><img src="https://img-blog.csdnimg.cn/20200131120139233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><code>功能组成</code>（通信子网、资源子网）<br>            1、<em>通信子网</em>：由各种传输介质、通信设备和相应的网络协议组成，为网络提供数据传输、交换和控制能力，实现联网计算机之间的数据通信。包括网络层、数据链路层、物理层<br>            2、<em>资源子网</em>：由主机、终端以及各种软件资源、信息资源组成，负责全网的数据处理业务，向网络用户提供各种网络资源和服务。包括应用层、表示层、会话层</p><p><img src="https://img-blog.csdnimg.cn/20200131120151995.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>局域网（Local Area Network, LAN）：</strong><br>一种覆盖一座或几座大楼、一个校园或者一个厂区等地理区域的小范围的计算机网络。包括以太网、令牌环网等。<br>当前的局域网主流是<code>以太网</code>。<br>局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。</p><p><strong>域域网（Metropolitan Area Network，MAN）：</strong><br>一种介于局域网与广域网之间，覆盖一个城市的地理范围，用来将同一区域内的多个局域网互连起来的中等范围的计算机网络。<br>这些网络通常涵盖一个大学校园或一座城市。<br>MAN的一个重要用途是用作骨干网，通过它将位于同一城市内不同地点的主机、数据库，以及LAN等互相联接起来。</p><p><strong>广域网（Wide Area Network，WAN）：</strong><br>一种用来实现不同地区的局域网或域域网的互连，可提供不同地区、城市和国家之间的计算机通信的远程计算机网络。所覆盖的范围从几十公里到几千里。<br>它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;计算机网络 = 通信技术 + 计算机技术
计算机网络是通信技术海域计算机技术紧密结合的产物
计算机网络就是一种通信网络&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;什么是计算机网络？&lt;/strong&gt;&lt;br&gt;&lt;code&gt;广义的计算机网络定义&lt;/code&gt;：在协议控制下，由一台或多台计算机、若干台终端设备、数据传输设备，以及用于终端和计算机之间、或者若干台计算机之间数据流动的通信控制处理机组成的系统的集合。&lt;br&gt;&lt;code&gt;计算机网络&lt;/code&gt;：是一个将分散的、具有独立功能的计算机系统，通过通信设备（交换机、路由器等）与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200131120111597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;计算机网络就是互连的、自治的计算机集合（公认的概念）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机网络" scheme="http://1979F.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Spring中注解大全</title>
    <link href="http://1979F.github.io/2019/11/30/Spring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%A4%A7%E5%85%A8%20/"/>
    <id>http://1979F.github.io/2019/11/30/Spring中注解大全 /</id>
    <published>2019-11-30T13:43:22.000Z</published>
    <updated>2019-11-30T13:43:55.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h1><p>标识一个该类是Spring MVC controller 处理器，用来创建处理http请求的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h2><p>Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@RestController，默认返回json格式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h2><p>用于标注业务层组件，说白了就是加入你有一个用注解的方式把这个类注入到spring配置中</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>用来装配bean，都可以写在字段上，或者方法上。</p><p>默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，例如：@Autowired（required=false）</p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>类定义处：提供初步的请求映射信息，相对于WEB应用的根目录。</p><p>方法处：提供进一步的细分映射信息，相对于类定义处的URL。</p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><p>用于将请求参数区数据映射到功能处理方法的参数上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resp <span class="title">test</span><span class="params">(@RequestParam Integer id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Resp.success(customerInfoService.fetch(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个id就是要接收从接口传递过来的参数id的值的，如果传递过来的参数名和接收的不一致，也可以如下 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resp <span class="title">test</span><span class="params">(@RequestParam(value=<span class="string">"course_id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Resp.success(customerInfoService.fetch(id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中course_id就是接口传递的参数，id即使映射course_id的参数名 </p><h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h2><p><strong><em>1、标记在方法上</em></strong></p><p>标记在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中。</p><p><strong>A、在有返回的方法上：</strong></p><p>当ModelAttribute设置了value，方法返回的值会以这个value为key，以参数接受到的值作为value，存入到Model中，如下面的方法执行之后，最终相当于model.addAttribute（“user_name”，name）;假如</p><p> @model.addAtrribute没有自定义value，则相当于model.addAttribute（“name”，name）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span>(value=<span class="string">"user_name"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">before2</span><span class="params">(@RequestParam(required = <span class="keyword">false</span>)</span> String name,Model model)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"进入了2，"</span> + name);</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>B、在没返回的方法上：</strong></p><p>需要手动model.add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(@RequestParam(required = <span class="keyword">false</span>)</span> Integer age, Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"age"</span>,age);</span><br><span class="line">    System.out.println(<span class="string">"进入了1："</span> + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在当前类下建一个请求方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/mod"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Resp <span class="title">mod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @RequestParam(required = <span class="keyword">false</span>)</span> String name</span>;</span><br><span class="line">    <span class="meta">@RequestParam</span>(required = <span class="keyword">false</span>) Integer age;</span><br><span class="line">    Model model)&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入mod"</span>);</span><br><span class="line">        System.out.println(<span class="string">"参数接受的数值&#123;name="</span>+name+<span class="string">";age="</span>+age+<span class="string">"&#125;"</span>);</span><br><span class="line">        System.out.println(<span class="string">"model传过来的值："</span> + model);</span><br><span class="line">        <span class="keyword">return</span> Resp.success(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在浏览器中输入访问地址并且加上参数：</p><p><a href="http://localhost:8080/api/test/mod?name" target="_blank" rel="noopener">http://localhost:8080/api/test/mod?name</a> = 我是哈哈 &amp; age = 12 </p><p><strong>最终输出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入了<span class="number">1</span>：:<span class="number">40</span></span><br><span class="line">进入了<span class="number">2</span>：我是哈哈</span><br><span class="line">进入mod</span><br><span class="line">参数接受的数值(name = 我是哈哈， age = <span class="number">18</span>)</span><br><span class="line">model传来的值：&#123;age = <span class="number">40</span>, user_name = 我是哈哈 &#125;</span><br></pre></td></tr></table></figure><p><strong><em>2、标记在方法的参数上</em></strong></p><p>标记在方法的参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。我们在上面的类中加入一个方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/mod2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Resp <span class="title">mod2</span><span class="params">(@ModelAttribute(<span class="string">"user_name"</span>)</span> String user_name,</span></span><br><span class="line"><span class="function">    @<span class="title">ModelAttribute</span><span class="params">(<span class="string">"name"</span>)</span> String name,</span></span><br><span class="line"><span class="function">    @<span class="title">ModelAttribute</span><span class="params">(<span class="string">"age"</span>)</span> Integer age, Model model)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入mod2"</span>);</span><br><span class="line">        System.out.println(<span class="string">"user_name:"</span> + user_name);</span><br><span class="line">        System.out.println(<span class="string">"name:"</span> + name);</span><br><span class="line">        System.out.println(<span class="string">"age:"</span> + age);</span><br><span class="line">        System.out.println(<span class="string">"model:"</span> + model);</span><br><span class="line">        <span class="keyword">return</span> Resp.success(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在浏览器中输入访问地址并且加上参数：</p><p><a href="http://localhost:8080/api/test/mod2?name" target="_blank" rel="noopener">http://localhost:8080/api/test/mod2?name</a> = 我是哈哈 &amp; age = 12</p><p><strong>最终输出</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进入了<span class="number">1</span>：<span class="number">40</span></span><br><span class="line">进入了<span class="number">2</span>：我是哈哈</span><br><span class="line">进入了mod2</span><br><span class="line">user_name：我是哈哈</span><br><span class="line">name：我是哈哈</span><br><span class="line">age：<span class="number">40</span></span><br><span class="line">model:&#123;user_name = 我是哈哈，org.springframework.validation.BindingResult.user_name=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors, name=我是小菜, org.springframework.validation.BindingResult.name=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors, age=<span class="number">40</span>, org.springframework.validation.BindingResult.age=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，用在方法参数中的@ModelAttribute注解，实际上是一种接受参数并且自动放入Model对象中，便于使用。 </p><h2 id="Cacheable"><a href="#Cacheable" class="headerlink" title="@Cacheable"></a>@Cacheable</h2><p>用来标记缓存查询。可用用于方法或者类中</p><p>当标记在一个方法上时表示该方法是支持缓存的，</p><p>当标记在一个类上时则表示该类所有的方法都是支持缓存的。<br><img src="https://img-blog.csdnimg.cn/20191130213520899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>比如@Cacheable(value=”UserCache”) 标识的是当调用了标记了这个注解的方法时，逻辑默认加上从缓存中获取结果的逻辑，如果缓存中没有数据，则执行用户编写查询逻辑，查询成功之后，同时将结果放入缓存中。</p><p>但凡说到缓存，都是key-value的形式的，因此key就是方法中的参数（id），value就是查询的结果，而命名空间UserCache是在spring*.xml中定义.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value=<span class="string">"UserCache"</span>)<span class="comment">// 使用了一个缓存名叫 accountCache   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">getUserAge</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//这里不用写缓存的逻辑，直接按正常业务逻辑走即可，</span></span><br><span class="line">    <span class="comment">//缓存通过切面自动切入  </span></span><br><span class="line">    <span class="keyword">int</span> age=getUser(id);   </span><br><span class="line">    <span class="keyword">return</span> age;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CacheEvict"><a href="#CacheEvict" class="headerlink" title="@CacheEvict"></a>@CacheEvict</h2><p>用来标记要清空缓存的方法，当这个方法被调用后，即会清空缓存。@CacheEvict(value=”UserCache”)<br><img src="https://img-blog.csdnimg.cn/20191130213537508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p>@Resource的作用相当于@Autowired</p><p>只不过@Autowired按byType自动注入，</p><p>而@Resource默认按 byName自动注入罢了。</p><p>@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>@Resource装配顺序:</p><ol><li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常</li><li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常</li><li>如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常</li><li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</li></ol><h2 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h2><p>用来标记是在项目启动的时候执行这个方法。用来修饰一个非静态的void()方法</p><p>也就是spring容器启动时就执行，多用于一些全局配置、数据字典之类的加载</p><p>被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行,init()方法之前执行。PreDestroy（）方法在destroy()方法执行执行之后执行</p><h2 id="PreDestroy"><a href="#PreDestroy" class="headerlink" title="@PreDestroy"></a>@PreDestroy</h2><p>被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前</p><h2 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h2><p>用于标注数据访问组件，即DAO组件</p><h2 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h2><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注</p><h2 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h2><p>用来配置 spring bean 的作用域，它标识 bean 的作用域。</p><p>默认值是单例</p><ol><li>singleton:单例模式,全局有且仅有一个实例</li><li>prototype:原型模式,每次获取Bean的时候会有一个新的实例</li><li>request:request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效</li><li>session:session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效</li><li>global session:只在portal应用中有用，给每一个 global http session 新建一个Bean实例。</li></ol><h2 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h2><p>默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中</p><p><strong>参数：</strong></p><ol><li><p>names：这是一个字符串数组。里面应写需要存储到session中数据的名称。</p></li><li><p>types：根据指定参数的类型，将模型中对应类型的参数存储到session中</p></li><li><p>value：和names是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"> <span class="meta">@SessionAttributes</span>(value=&#123;<span class="string">"names"</span>&#125;,types=&#123;Integer.class&#125;)</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeService</span> </span>&#123;</span><br><span class="line">     <span class="meta">@RequestMapping</span>(<span class="string">"/testSession"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>&#123;</span><br><span class="line">         map.put(<span class="string">"names"</span>, Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>));</span><br><span class="line">         map.put(<span class="string">"age"</span>, <span class="number">12</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Required"><a href="#Required" class="headerlink" title="@Required"></a>@Required</h2><p>适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。</p><h2 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h2><p>当你创建多个具有相同类型的 bean 时，并且想要用一个属性只为它们其中的一个进行装配，在这种情况下，你可以使用 @Qualifier 注释和 @Autowired 注释通过指定哪一个真正的 bean 将会被装配来消除混乱。  </p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Controller&quot;&gt;&lt;a href=&quot;#Controller&quot; class=&quot;headerlink&quot; title=&quot;@Controller&quot;&gt;&lt;/a&gt;@Controller&lt;/h1&gt;&lt;p&gt;标识一个该类是Spring MVC controller 处理器，用来创建处理http请求的对象&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Controller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestController&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Map&amp;lt;String,Object&amp;gt; map)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;hello&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="spring" scheme="http://1979F.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Java线程知识点（三）线程的互斥与同步机制</title>
    <link href="http://1979F.github.io/2019/10/07/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://1979F.github.io/2019/10/07/线程知识点（三）线程的互斥与同步机制/</id>
    <published>2019-10-07T13:56:01.000Z</published>
    <updated>2019-10-07T13:59:34.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程的互斥与同步机制"><a href="#线程的互斥与同步机制" class="headerlink" title="线程的互斥与同步机制"></a>线程的互斥与同步机制</h1><h2 id="一、互斥"><a href="#一、互斥" class="headerlink" title="一、互斥"></a>一、互斥</h2><p><strong>为何需要引入互斥机制？</strong></p><p>当多个线程对同一数据并发读写（至少有一个线程执行写操作）时，这种情形被称为竞争。竞争会导致数据读或写的不确定性。而有时这种不确定性是不可容忍的。</p><p><strong>如何实现互斥？</strong><a id="more"></a></p><p>在并发程序设计中，通常使用锁机制来实现互斥</p><p>1、由用户标记必须原子执行的代码段，即使用synchronized关键字</p><p>2、给资源一把配有自动机制的锁</p><p><strong>【注意】</strong>：</p><p>Java将资源限定为引用型对象，并为每一对象自动配备一把锁：锁初始时处于打开状态。synchronized标记的原子代码段在访问资源前，会自动检测资源对象持有的锁是否处于打开状态。若是，则占用并同时将锁置为锁闭态，并在该代码段执行完毕后。将锁的状态值为打开态；若否，则持有该代码的线程因等待资源占用而进入阻塞态。</p><p>• 只有对象才有锁，对基本类型的数据，无法实现线程的互斥访问。</p><p>• 对于未使用synchronized标记的代码，锁机制不起作用。</p><p>• 无论正常结束还是异常退出，都将自动释放锁。</p><p><strong>死锁和活锁</strong></p><p><strong><em>死锁</em></strong>：就是多个线程对临界资源的循环等待，使得这些线程均都无法获得执行。</p><p>例如：A，B，C三个线程分别占用D1、D2、D3三个临界资源，A只有获得B占用的资源D2,方能继续运行；而B只有获得C占用的资源D3，方能继续运行；C只有获得A占用的资源D1，方能继续运行。这样，A,B,C处在对资源的循环等待状态，均无法前进。</p><p><strong><em>活锁</em></strong>：也称饥饿。就是某线程虽有执行的资格，但由于某种原因总是得不到执行。</p><p>例如：A,B,C三个线程循环访问临界资源D，但A，B的优先级相同，但均高于C。由于Java的抢占式策略，C线程可能总得不到执行。</p><h2 id="二、同步"><a href="#二、同步" class="headerlink" title="二、同步"></a>二、同步</h2><p><strong>同步（Sync）</strong></p><p>多个线程的运行满足特定的节奏</p><p>所谓同步，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。</p><p>根据这个定义，Java中所有方法都是同步调用，应为必须要等到结果后才会继续执行。我们在说同步、异步的时候，一般而言是特指那些需要其他端协作或者需要一定时间完成的任务。</p><p>简单来说，同步就是必须一件一件事做，等前一件做完了才能做下一件事。</p><p><strong>异步（Async）</strong></p><p>多个线程的运行相互独立，彼此间无依赖性</p><p>异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。</p><p>举个例子简单说明下两者的区别：</p><p><strong>同步</strong>：火车站多个窗口卖火车票，假设A窗口当卖第288张时，在这个短暂的过程中，其他窗口都不能卖这张票，也不能继续往下卖，必须这张票处理完其他窗口才能继续卖票。直白点说就是当你看见程序里出现synchronized这个关键字，将任务锁起来，当某个线程进来时，不能让其他线程继续进来，那就代表是同步了。</p><p><strong>异步</strong>：当我们用手机下载某个视频时，我们大多数人都不会一直等着这个视频下载完，而是在下载的过程看看手机里的其他东西，比如用qq或者是微信聊聊天，这种的就是异步，你执行你的，我执行我的，互不干扰。比如上面卖火车票，如果多个窗口之间互不影响，我行我素，A窗口卖到第288张了，B窗口不管A窗口，自己也卖第288张票，那显然会出错了。</p><p><strong>并发</strong></p><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个<a href="http://baike.baidu.com/view/2107226.htm" target="_blank" rel="noopener">处理机</a>上运行。其中两种并发关系分别是同步和互斥。</p><p><strong>并行</strong></p><p>在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事 件之间不一定要同一时刻发生。</p><p><strong>*<u>Java的同步机制 = 存取共享资源的互斥机制 + 线程间的通信机制</u>*</strong></p><p>用于线程通信的方法存在于Object类中，包括wait()、notify()、notifyAll()。wait()会暂停当前线程的执行，并释放所持有的锁，进入等待状态；notify()操作将唤醒一个等待的线程；notifyAll()将唤醒所有等待的进程。</p><p><strong>【注意】</strong></p><p>wait()、notify()、notifyAll()都是final方法，不允许被重写；这些方法只能直接或间接地用于临界区中，否则，将会产生非法监控锁状态异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程的互斥与同步机制&quot;&gt;&lt;a href=&quot;#线程的互斥与同步机制&quot; class=&quot;headerlink&quot; title=&quot;线程的互斥与同步机制&quot;&gt;&lt;/a&gt;线程的互斥与同步机制&lt;/h1&gt;&lt;h2 id=&quot;一、互斥&quot;&gt;&lt;a href=&quot;#一、互斥&quot; class=&quot;headerlink&quot; title=&quot;一、互斥&quot;&gt;&lt;/a&gt;一、互斥&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;为何需要引入互斥机制？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当多个线程对同一数据并发读写（至少有一个线程执行写操作）时，这种情形被称为竞争。竞争会导致数据读或写的不确定性。而有时这种不确定性是不可容忍的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何实现互斥？&lt;/strong&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://1979F.github.io/tags/Java/"/>
    
      <category term="后端" scheme="http://1979F.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java线程知识点（二）线程的构造和运行</title>
    <link href="http://1979F.github.io/2019/10/07/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%BF%90%E8%A1%8C/"/>
    <id>http://1979F.github.io/2019/10/07/线程知识点（二）线程的构造和运行/</id>
    <published>2019-10-07T13:29:22.000Z</published>
    <updated>2019-10-07T13:39:54.357Z</updated>
    
    <content type="html"><![CDATA[<p><strong>① 用Thread类构造线程对象</strong>（继承Thread类来创建并启动多线程）<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.sxt.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程方式一：</span></span><br><span class="line"><span class="comment"> * 1、创建：继承Thread+重写run</span></span><br><span class="line"><span class="comment"> * 2、启动：创建子类对象+start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 1979</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程入口点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"一边听歌"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程</span></span><br><span class="line"><span class="comment"> * for(int i=0;i&lt;20;i++) &#123;</span></span><br><span class="line"><span class="comment"> *  System.out.println("一边coding");</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子类对象</span></span><br><span class="line">StartThread st = <span class="keyword">new</span> StartThread();</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">st.start();<span class="comment">//不保证立即运行   由cpu调用</span></span><br><span class="line"><span class="comment">//st.run();//普通方法调用，只能听完歌再敲代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"一边coding"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【运行结果】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一边coding</span><br><span class="line">一边coding</span><br><span class="line">...</span><br><span class="line">一边听歌</span><br><span class="line">一边听歌</span><br><span class="line">...</span><br><span class="line">一边coding</span><br><span class="line">一边coding</span><br></pre></td></tr></table></figure><p><strong>【缺点】</strong>：<u>由于java采用单继承机制，若为实现多线程而继承了Thread，将无法再继承其他类，是非常不明智的做法。</u></p><p><strong>② 用Runnable辅助构造线程</strong>（实现Runnable接口创建线程类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.sxt.thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 创建线程方式二</span></span><br><span class="line"><span class="comment"> * 1、创建：实现Runnable+重写run</span></span><br><span class="line"><span class="comment"> * 2、启动：创建实现类对象+Thread对象+start</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 推荐：避免单继承的局限性，优先使用接口</span></span><br><span class="line"><span class="comment"> * 方便共享资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 1979</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程入口点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"一边听歌"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果放在这里，那么要先敲完代码再听歌，for循环结束后才启动线程</span></span><br><span class="line"><span class="comment"> * for(int i=0;i&lt;20;i++) &#123;</span></span><br><span class="line"><span class="comment"> *  System.out.println("一边coding");</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建实现类对象</span></span><br><span class="line">StartRun sr = <span class="keyword">new</span> StartRun();</span><br><span class="line"><span class="comment">//创建代理类对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(sr);</span><br><span class="line"><span class="comment">//启动</span></span><br><span class="line">t.start();<span class="comment">//不保证立即运行   由cpu调用</span></span><br><span class="line"><span class="comment">//st.run();//普通方法调用，只能听完歌再敲代码</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"一边coding"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【运行结果】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一边coding</span><br><span class="line">一边coding</span><br><span class="line">...</span><br><span class="line">一边听歌</span><br><span class="line">一边听歌</span><br><span class="line">...</span><br><span class="line">一边coding</span><br><span class="line">一边coding</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> liti_07;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本例展现这样一种方式：利用Runnable接口直接构造线程并运行</span></span><br><span class="line"><span class="comment"> *有如下关键点：</span></span><br><span class="line"><span class="comment"> *1、希望该类中创建线程对象，就必须有线程成员，即私有变量t;</span></span><br><span class="line"><span class="comment"> *2、在构造函数中构造t引用的线程对象，注意把自己作为参数传给t;</span></span><br><span class="line"><span class="comment"> *3、还需要启动线程。由于t长设为私有，故不能直接t.start()，</span></span><br><span class="line"><span class="comment"> *      需要设置其他方法，如本例另提供一个公共的start()方法。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ch_7_3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.print(<span class="string">"Main 开始"</span>);</span><br><span class="line">Ch_7_3 m1=<span class="keyword">new</span> Ch_7_3(<span class="number">1</span>,<span class="string">"奇数线程"</span>);  <span class="comment">//注意，m1依旧不是线程对象</span></span><br><span class="line">Ch_7_3 m2=<span class="keyword">new</span> Ch_7_3(<span class="number">2</span>,<span class="string">"偶数线程"</span>);</span><br><span class="line">m1.start();                 <span class="comment">//注意，调用的是类R自己定义的start()</span></span><br><span class="line">m2.start();</span><br><span class="line">System.out.print(<span class="string">"当前共有"</span>+ Thread.activeCount()+<span class="string">"个线程"</span>);</span><br><span class="line">System.out.print(<span class="string">"Main 结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> d;</span><br><span class="line"><span class="keyword">private</span> Thread t;                   <span class="comment">//-----新增成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123; </span><br><span class="line">t.start(); </span><br><span class="line">&#125;        <span class="comment">//-----关键点2 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ch_7_3</span><span class="params">(<span class="keyword">int</span> x, String s)</span></span>&#123;</span><br><span class="line">d=x;</span><br><span class="line"><span class="comment">//t=new Thread(this); t.setName(s);  //----关键点1</span></span><br><span class="line">t=<span class="keyword">new</span> Thread(<span class="keyword">this</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=d; i&lt;<span class="number">50</span>;i=i+<span class="number">2</span>)</span><br><span class="line">System.out.print(<span class="string">" "</span>+i);</span><br><span class="line"><span class="comment">//Thread t=Thread.currentThread();  //---此句不再需要</span></span><br><span class="line">System.out.print(t.getName()+<span class="string">"结束！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>线程的一些常用方法</strong></p><p> 1、<code>currentThread()</code></p><p>返回对当前正在执行的线程对象的引用。</p><p> 2、<code>getId()</code></p><p>返回此线程的标识符</p><p> 3、<code>getName()</code></p><p>返回此线程的名称</p><p> 4、<code>getPriority()</code></p><p>返回此线程的优先级</p><p> 5、<code>isAlive()</code></p><p>测试这个线程是否还处于活动状态。</p><p>什么是活动状态呢？</p><p>活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备运行的状态。</p><p> 6、<code>sleep(long millis)</code></p><p>使当前正在执行的线程以指定的毫秒数“休眠”（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。</p><p> 7、<code>interrupt()</code></p><p>中断这个线程。</p><p> 8、<code>interrupted() 和isInterrupted()</code></p><p>interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能</p><p>isInterrupted()： 测试线程Thread对相关是否已经是中断状态，但不清楚状态标志</p><p> 9、 <code>setName(String name)</code></p><p>将此线程的名称更改为等于参数 name 。</p><p> 10、<code>isDaemon()</code></p><p>测试这个线程是否是守护线程。</p><p> 11、<code>setDaemon(boolean on)</code></p><p>将此线程标记为 daemon线程或用户线程。</p><p> 12、<code>join()</code></p><p>在很多情况下，主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，也就是主线程需要等待子线程执行完成之后再结束，这个时候就要用到join()方法了。</p><p>join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行</p><p> 13、<code>yield()</code></p><p>yield()方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU时间。注意：放弃的时间不确定，可能一会就会重新获得CPU时间片。</p><p> 14、<code>setPriority(int newPriority)</code></p><p>更改此线程的优先级</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;① 用Thread类构造线程对象&lt;/strong&gt;（继承Thread类来创建并启动多线程）
    
    </summary>
    
    
    
      <category term="Java" scheme="http://1979F.github.io/tags/Java/"/>
    
      <category term="后端" scheme="http://1979F.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>3分钟教你Hexo如何绑定个人域名</title>
    <link href="http://1979F.github.io/2019/10/06/Hexo%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D/"/>
    <id>http://1979F.github.io/2019/10/06/Hexo如何绑定个人域名/</id>
    <published>2019-10-06T02:47:48.000Z</published>
    <updated>2019-10-06T08:12:22.992Z</updated>
    
    <content type="html"><![CDATA[<p>前两天用Hexo+GitHub搭建好了自己的个人博客<a href="http://tsundere-x.top/" target="_blank" rel="noopener">http://tsundere-x.top/</a> ，默认域名github下的二级域名：username.github.io，为了提升访问速度和博客的格调，绑定个人域名是多数人的选择。下面给大家介绍详细过程。<a id="more"></a></p><p><strong>购买域名</strong></p><p>国内有很多不错的域名服务商，这里我给大家推荐阿里云的<a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">万网</a>。我购买的域名是：<a href="http://tsundere-x.top/" target="_blank" rel="noopener">tsundere-x.top</a>。</p><p>大家可以根据自身的需求购买相应的域名。点击查域名后确认域名没有被使用后即可下单购买，当然在付款之前你还需要进行邮箱验证和实名认证（虽然上面提示实名认证需要3-5天，但正常情况下其实只要一个小时左右）。<br><img src="https://img-blog.csdnimg.cn/20191006103725534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>实名认证通过后进行域名解析</strong></p><p>在此之前需要获取自己 github 的二级域名的 IP地址 。cmd下ping+自己博客的地址即可获得。<br><img src="https://img-blog.csdnimg.cn/20191006103834723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>实名认证后来到域名控制台，点击解析。<br><img src="https://img-blog.csdnimg.cn/2019100610390655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>进入新手指导，将得到的 IP 地址填到记录值一栏 即可。<br><img src="https://img-blog.csdnimg.cn/20191006103924178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>仓库的custom domain绑定域名</strong></p><p>进入仓库中， 点击  setting 往下滑 会看到<strong>custom domain</strong>  将自己购买的域名填写进去 。<br><img src="https://img-blog.csdnimg.cn/20191006103951330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>最后一步，设置CNAME</strong></p><p>进入Hexo根目录下的<code>source</code>文件夹，新建CNAME文件（文件！！！，不需要任何后缀）。<br><img src="https://img-blog.csdnimg.cn/20191006104030127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>接下来 使用 <code>hexo d -g</code> 重新部署，就可以成功访问咯！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天用Hexo+GitHub搭建好了自己的个人博客&lt;a href=&quot;http://tsundere-x.top/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://tsundere-x.top/&lt;/a&gt; ，默认域名github下的二级域名：username.github.io，为了提升访问速度和博客的格调，绑定个人域名是多数人的选择。下面给大家介绍详细过程。
    
    </summary>
    
    
    
      <category term="Hexo" scheme="http://1979F.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java线程知识点（一）</title>
    <link href="http://1979F.github.io/2019/10/05/%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%20%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%E3%80%81Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://1979F.github.io/2019/10/05/线程知识点（一）—— 程序、进程、线程之间的区别与联系、Java的线程状态和生命周期/</id>
    <published>2019-10-04T16:30:22.000Z</published>
    <updated>2019-10-06T08:13:17.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-程序、进程、线程之间的区别与联系"><a href="#1-程序、进程、线程之间的区别与联系" class="headerlink" title="1  程序、进程、线程之间的区别与联系"></a>1  程序、进程、线程之间的区别与联系</h3><p>  三者之间的形象化理解：<br>    * 程序：代码实现了功能，就是程序，是静态的；<br>    * 进程：执行中的程序就是进程，是动态的；<br>     * 线程：进程内的一个执行单元,也是进程内的可调度实体，可以并发执行提高了进程的效率。</p><a id="more"></a><p><strong><em>进程和线程的关系：</em></strong><br>（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。<br>（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。<br>（3）处理机分给线程，即真正在处理机上运行的是线程。<br>（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p><p><strong><em>线程与进程的区别:</em></strong><br>  (1)  调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位 。<br>  (2)  并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行 。<br>  (3)  拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。<br>  (4)  系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p><p><strong><em>程序与进程的区别：</em></strong><br>程序是指令的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。 </p><p>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。程序是永久的，进程是暂时的。 </p><p>进程更能真实地描述并发，而程序不能；进程是由程序和数据两部分组成的。进程具有创建其他进程的功能，而程序没有。 </p><p>同一程序同时运行于若干个数据集合上，它将属于若干个不同的进程。也就是说同一程序可以对应多个进程。</p><h3 id="2-Java的线程状态和生命周期"><a href="#2-Java的线程状态和生命周期" class="headerlink" title="2  Java的线程状态和生命周期"></a>2  Java的线程状态和生命周期</h3><p><img src="https://img-blog.csdnimg.cn/20191005001816162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODE2NTU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20191005001825156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0ODE2NTU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>==<strong>新建状态:</strong>==<br>使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。</p><p>==<strong>就绪状态:</strong>==<br>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p><p>==<strong>运行状态:</strong>==<br>如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p><p>==<strong>阻塞状态:</strong>==<br>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p><ol><li><em>等待阻塞</em>：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li><li><em>同步阻塞</em>：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 </li><li><em>其他阻塞</em>：通过调用线程的 sleep() 或join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O处理完毕，线程重新转入就绪状态。</li></ol><p>==<strong>死亡状态:</strong>==<br>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-程序、进程、线程之间的区别与联系&quot;&gt;&lt;a href=&quot;#1-程序、进程、线程之间的区别与联系&quot; class=&quot;headerlink&quot; title=&quot;1  程序、进程、线程之间的区别与联系&quot;&gt;&lt;/a&gt;1  程序、进程、线程之间的区别与联系&lt;/h3&gt;&lt;p&gt;  三者之间的形象化理解：&lt;br&gt;    * 程序：代码实现了功能，就是程序，是静态的；&lt;br&gt;    * 进程：执行中的程序就是进程，是动态的；&lt;br&gt;     * 线程：进程内的一个执行单元,也是进程内的可调度实体，可以并发执行提高了进程的效率。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://1979F.github.io/tags/Java/"/>
    
      <category term="后端" scheme="http://1979F.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Java中this和super的用法总结</title>
    <link href="http://1979F.github.io/2019/10/04/Java%E4%B8%ADthis%E5%92%8Csuper%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://1979F.github.io/2019/10/04/Java中this和super的用法总结/</id>
    <published>2019-10-04T14:50:22.000Z</published>
    <updated>2019-10-06T08:12:50.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul><li><p>this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</p></li><li><p>this 的用法在 Java 中大体可以分为3种：</p></li></ul><h5 id="1-普通的直接引用"><a href="#1-普通的直接引用" class="headerlink" title="1.普通的直接引用"></a>1.普通的直接引用</h5><p>   this 相当于是指向当前对象本身。<a id="more"></a></p><h5 id="2-形参与成员名字重名，用-this-来区分："><a href="#2-形参与成员名字重名，用-this-来区分：" class="headerlink" title="2.形参与成员名字重名，用 this 来区分："></a>2.形参与成员名字重名，用 this 来区分：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"初始化年龄："</span>+age);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person Harry = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(<span class="string">"Harry's age is "</span>+Harry.GetAge(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>运行结果：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化年龄：10 Harry&apos;s age is 12</span><br></pre></td></tr></table></figure><p>可以看到，这里 age 是 GetAge 成员方法的形参，this.age 是 Person 类的成员变量。</p><h5 id="3-引用构造函数"><a href="#3-引用构造函数" class="headerlink" title="3.引用构造函数"></a>3.引用构造函数</h5><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super 可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p><p>super 也有三种用法：</p><h5 id="1-普通的直接引用-1"><a href="#1-普通的直接引用-1" class="headerlink" title="1.普通的直接引用"></a>1.普通的直接引用</h5><p>与 this 类似，super 相当于是指向当前对象的父类，这样就可以用 super.xxx 来引用父类的成员。</p><h5 id="2-子类中的成员变量或方法与父类中的成员变量或方法同名"><a href="#2-子类中的成员变量或方法与父类中的成员变量或方法同名" class="headerlink" title="2.子类中的成员变量或方法与父类中的成员变量或方法同名"></a>2.子类中的成员变量或方法与父类中的成员变量或方法同名</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       name = <span class="string">"China"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">extends</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    name = <span class="string">"Shanghai"</span>;</span><br><span class="line">    <span class="keyword">super</span>.value();      <span class="comment">//调用父类的方法</span></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(<span class="keyword">super</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       City c=<span class="keyword">new</span> City();</span><br><span class="line">       c.value();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>运行结果：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shanghai China</span><br></pre></td></tr></table></figure><p>可以看到，这里既调用了父类的方法，也调用了父类的变量。若不调用父类方法 value()，只调用父类变量 name 的话，则父类 name 值为默认值 null。</p><h5 id="3-引用构造函数-1"><a href="#3-引用构造函数-1" class="headerlink" title="3.引用构造函数"></a>3.引用构造函数</h5><ul><li><p>super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</p></li><li><p>this(参数)：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prt</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">       System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    Person() &#123; </span><br><span class="line">       prt(<span class="string">"父类·无参数构造方法： "</span>+<span class="string">"A Person."</span>); </span><br><span class="line">    &#125;<span class="comment">//构造方法(1) </span></span><br><span class="line">    </span><br><span class="line">    Person(String name) &#123; </span><br><span class="line">       prt(<span class="string">"父类·含一个参数的构造方法： "</span>+<span class="string">"A person's name is "</span> + name); </span><br><span class="line">    &#125;<span class="comment">//构造方法(2) </span></span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    Chinese() &#123; </span><br><span class="line">       <span class="keyword">super</span>(); <span class="comment">// 调用父类构造方法（1） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类"</span>无参数构造方法<span class="string">"： "</span>+<span class="string">"A chinese coder."</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name) &#123; </span><br><span class="line">       <span class="keyword">super</span>(name);<span class="comment">// 调用父类具有相同形参的构造方法（2） </span></span><br><span class="line">       prt(<span class="string">"子类·调用父类"</span>含一个参数的构造方法<span class="string">"： "</span>+<span class="string">"his name is "</span> + name); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    Chinese(String name, <span class="keyword">int</span> age) &#123; </span><br><span class="line">       <span class="keyword">this</span>(name);<span class="comment">// 调用具有相同形参的构造方法（3） </span></span><br><span class="line">       prt(<span class="string">"子类：调用子类具有相同形参的构造方法：his age is "</span> + age); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       Chinese cn = <span class="keyword">new</span> Chinese(); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>); </span><br><span class="line">       cn = <span class="keyword">new</span> Chinese(<span class="string">"codersai"</span>, <span class="number">18</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><em>运行结果：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">父类·无参数构造方法： A Person.</span><br><span class="line">子类·调用父类”无参数构造方法“： A chinese coder.</span><br><span class="line">父类·含一个参数的构造方法： A person&apos;s name is codersai</span><br><span class="line">子类·调用父类”含一个参数的构造方法“： his name is codersai</span><br><span class="line">父类·含一个参数的构造方法： A person&apos;s name is codersai</span><br><span class="line">子类·调用父类”含一个参数的构造方法“： his name is codersai</span><br><span class="line">子类：调用子类具有相同形参的构造方法：his age is 18</span><br></pre></td></tr></table></figure><p>从本例可以看到，可以用 super 和 this 分别调用父类的构造方法和本类中其他形式的构造方法。</p><p>例子中 Chinese 类第三种构造方法调用的是本类中第二种构造方法，而第二种构造方法是调用父类的，因此也要先调用父类的构造方法，再调用本类中第二种，最后是重写第三种构造方法。</p><p>==<strong>super 和 this 的异同</strong>==</p><ul><li>super(参数)：调用基类中的某一个构造函数（应该为构造函数中的第一条语句）</li><li>this(参数)：调用本类中另一种形成的构造函数（应该为构造函数中的第一条语句）</li><li>super:　它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用 this 来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用 this 来指明成员变量名）</li><li>调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用 super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。</li><li>super() 和 this() 类似,区别是，super() 从子类中调用父类的构造方法，this() 在同一类内调用其它方法。</li><li>super() 和 this() 均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this 和 super 不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this() 和 super() 都指的是对象，所以，均不可以在 static 环境中使用。包括：static 变量,static 方法，static 语句块。</li><li>从本质上讲，this 是一个指向本对象的指针, 然而 super 是一个 Java 关键字。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;this 是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;this 的用法在 Java 中大体可以分为3种：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;1-普通的直接引用&quot;&gt;&lt;a href=&quot;#1-普通的直接引用&quot; class=&quot;headerlink&quot; title=&quot;1.普通的直接引用&quot;&gt;&lt;/a&gt;1.普通的直接引用&lt;/h5&gt;&lt;p&gt;   this 相当于是指向当前对象本身。
    
    </summary>
    
    
    
      <category term="Java" scheme="http://1979F.github.io/tags/Java/"/>
    
      <category term="后端" scheme="http://1979F.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
</feed>
