<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Serendipper-x</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://1979F.github.io/"/>
  <updated>2020-11-25T01:13:10.823Z</updated>
  <id>http://1979F.github.io/</id>
  
  <author>
    <name>XIAO_JING</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 1470. 重新排列数组</title>
    <link href="http://1979F.github.io/2020/11/24/LeetCode%201470.%20%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/"/>
    <id>http://1979F.github.io/2020/11/24/LeetCode 1470. 重新排列数组/</id>
    <published>2020-11-24T15:26:39.000Z</published>
    <updated>2020-11-25T01:13:10.823Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。</p><p>请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,5,1,3,4,7], n = 3</span><br><span class="line">输出：[2,3,5,4,1,7] </span><br><span class="line">解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,4,3,2,1], n = 4</span><br><span class="line">输出：[1,4,2,3,3,2,4,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2,2], n = 2</span><br><span class="line">输出：[1,2,1,2]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shuffle(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           res[i] = nums[j];</span><br><span class="line">           <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">           j = j + n;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">           j = j - n + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,…,xn,y1,y2,…,yn] 的格式排列。&lt;/p&gt;&lt;p&gt;请你将数组按 [x1,y1,x2,y2,…,xn,yn] 格式重新排列，返回重排后的数组。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [2,5,1,3,4,7], n = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[2,3,5,4,1,7] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 771. 宝石与石头</title>
    <link href="http://1979F.github.io/2020/11/24/LeetCode%20771.%20%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/"/>
    <id>http://1979F.github.io/2020/11/24/LeetCode 771. 宝石与石头/</id>
    <published>2020-11-24T15:21:05.000Z</published>
    <updated>2020-11-25T01:14:39.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>： 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p><p>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] a = <span class="keyword">new</span> <span class="keyword">char</span>[J.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; J.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = J.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; S.length(); j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a.length; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(S.charAt(j) == (a[k]))</span><br><span class="line">                    num++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201124232032364.png#pic" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;： 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。&lt;/p&gt;&lt;p&gt;J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: J = &amp;quot;aA&amp;quot;, S = &amp;quot;aAAbbbb&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1486.数组异或操作</title>
    <link href="http://1979F.github.io/2020/11/24/LeetCode%201486.%20%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/"/>
    <id>http://1979F.github.io/2020/11/24/LeetCode 1486. 数组异或操作/</id>
    <published>2020-11-24T15:18:54.000Z</published>
    <updated>2020-11-25T01:12:42.705Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：</p><p>给你两个整数，n 和 start 。</p><p>数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。</p><p>请返回 nums 中所有元素按位异或（XOR）后得到的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 5, start = 0</span><br><span class="line">输出：8</span><br><span class="line">解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。</span><br><span class="line">     &quot;^&quot; 为按位异或 XOR 运算符。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, start = 3</span><br><span class="line">输出：8</span><br><span class="line">解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, start = 7</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = start + <span class="number">2</span> * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res ^ a[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/202011242318261.png#pic" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;给你两个整数，n 和 start 。&lt;/p&gt;&lt;p&gt;数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。&lt;/p&gt;&lt;p&gt;请返回 nums 中所有元素按位异或（XOR）后得到的结果。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 5, start = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;quot;^&amp;quot; 为按位异或 XOR 运算符。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode LCP 06. 拿硬币</title>
    <link href="http://1979F.github.io/2020/11/24/LeetCode%20LCP%2006.%20%E6%8B%BF%E7%A1%AC%E5%B8%81/"/>
    <id>http://1979F.github.io/2020/11/24/LeetCode LCP 06. 拿硬币/</id>
    <published>2020-11-24T15:16:03.000Z</published>
    <updated>2020-11-25T01:11:58.424Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：<code>桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</code></p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,2,1]</span><br><span class="line"></span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,3,10]</span><br><span class="line"></span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCount</span><span class="params">(<span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>((coins[i] % <span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">                m = (coins[i] / <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                m = coins[i] / <span class="number">2</span>;</span><br><span class="line">            n += m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201124231526717.png#pic" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;code&gt;桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[4,2,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 222. 完全二叉树的节点个数</title>
    <link href="http://1979F.github.io/2020/11/24/LeetCode%20222.%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/"/>
    <id>http://1979F.github.io/2020/11/24/LeetCode 222. 完全二叉树的节点个数/</id>
    <published>2020-11-24T15:12:52.000Z</published>
    <updated>2020-11-25T01:15:28.951Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：<code>给出一个完全二叉树，求出该树的节点个数。</code></p><p><strong>说明：</strong></p><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \  /</span><br><span class="line">4  5 6</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>思路</strong>：分为两种情况，第一种是左子树的高度 n 与右子树的高度 m 相同，说明左子树已经填满了，左子树的节点数加上根节点的总数为 2^n，只需遍历右子树的节点个数即可；第二种是 n 与 m 不相等，说明右子树已经填满了，右子树的节点数加上根节点的总数为 2^m，只需遍历左子树的节点个数即可。这里计算节点个数要用到递归的思想。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = countLevel(root.left);</span><br><span class="line">        <span class="keyword">int</span> m = countLevel(root.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n == m)&#123;</span><br><span class="line">            <span class="keyword">return</span> (countNodes(root.right) + (<span class="number">1</span>&lt;&lt;n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (countNodes(root.left) + (<span class="number">1</span>&lt;&lt;m));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countLevel</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(countLevel(root.left), countLevel(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201124231235254.png#pic" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;code&gt;给出一个完全二叉树，求出该树的节点个数。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \  /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4  5 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1108. IP地址无效化</title>
    <link href="http://1979F.github.io/2020/11/24/LeetCode%201108.%20IP%20%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/"/>
    <id>http://1979F.github.io/2020/11/24/LeetCode 1108. IP 地址无效化/</id>
    <published>2020-11-24T15:06:59.000Z</published>
    <updated>2020-11-25T01:14:14.722Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：</p><p><code>给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。所谓无效化 IP 地址，其实就是用 &quot;[.]&quot; 代替了每个 &quot;.&quot;。</code></p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：address = &quot;1.1.1.1&quot;</span><br><span class="line">输出：&quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：address = &quot;255.100.50.0&quot;</span><br><span class="line">输出：&quot;255[.]100[.]50[.]0&quot;</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：直接使用Java的替换函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">defangIPaddr</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> address.replace(<span class="string">"."</span>, <span class="string">"[.]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201124230621696.png#pic" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。
所谓无效化 IP 地址，其实就是用 &amp;quot;[.]&amp;quot; 代替了每个 &amp;quot;.&amp;quot;。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：address = &amp;quot;1.1.1.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&amp;quot;1[.]1[.]1[.]1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 237. 删除链表中的节点</title>
    <link href="http://1979F.github.io/2020/11/24/LeetCode%20237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <id>http://1979F.github.io/2020/11/24/LeetCode 237. 删除链表中的节点/</id>
    <published>2020-11-24T15:03:51.000Z</published>
    <updated>2020-11-25T01:15:07.050Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：<img src="https://img-blog.csdnimg.cn/20201124230138838.png#pic" alt="在这里插入图片描述"><br><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,5,1,9], node = 5</span><br><span class="line">输出：[4,1,9]</span><br><span class="line">解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,5,1,9], node = 1</span><br><span class="line">输出：[4,5,9]</span><br><span class="line">解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201124230329670.png#pic" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;img src=&quot;https://img-blog.csdnimg.cn/20201124230138838.png#pic&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [4,5,1,9], node = 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,1,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [4,5,1,9], node = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[4,5,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1281. 整数的各位积和之差</title>
    <link href="http://1979F.github.io/2020/11/24/LeetCode%201281.%20%E6%95%B4%E6%95%B0%E7%9A%84%E5%90%84%E4%BD%8D%E7%A7%AF%E5%92%8C%E4%B9%8B%E5%B7%AE/"/>
    <id>http://1979F.github.io/2020/11/24/LeetCode 1281. 整数的各位积和之差/</id>
    <published>2020-11-24T15:00:40.000Z</published>
    <updated>2020-11-25T01:13:48.642Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：<code>给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。</code></p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 234</span><br><span class="line">输出：15 </span><br><span class="line">解释：</span><br><span class="line">各位数之积 = 2 * 3 * 4 = 24 </span><br><span class="line">各位数之和 = 2 + 3 + 4 = 9 </span><br><span class="line">结果 = 24 - 9 = 15</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4421</span><br><span class="line">输出：21</span><br><span class="line">解释： </span><br><span class="line">各位数之积 = 4 * 4 * 2 * 1 = 32 </span><br><span class="line">各位数之和 = 4 + 4 + 2 + 1 = 11 </span><br><span class="line">结果 = 32 - 11 = 21</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>思路</strong>：先将 int 类型转换为 String 类型，获取到每一位的值，然后计算和与乘积，返回题目所需的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String s = String.valueOf(n);</span><br><span class="line">        <span class="keyword">int</span> x = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[x];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mul = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++)&#123;</span><br><span class="line">            t[i] = s.charAt(i) - <span class="number">48</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j++)&#123;</span><br><span class="line">            sum += t[j];</span><br><span class="line">            mul *= t[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  mul - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201124230023297.png#pic" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;code&gt;给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 234&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：15 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;各位数之积 = 2 * 3 * 4 = 24 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;各位数之和 = 2 + 3 + 4 = 9 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;结果 = 24 - 9 = 15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = 4421&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;各位数之积 = 4 * 4 * 2 * 1 = 32 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;各位数之和 = 4 + 4 + 2 + 1 = 11 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;结果 = 32 - 11 = 21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 1480 一维数组的动态和</title>
    <link href="http://1979F.github.io/2020/11/22/LeetCode%201480%20%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/"/>
    <id>http://1979F.github.io/2020/11/22/LeetCode 1480 一维数组的动态和/</id>
    <published>2020-11-22T09:30:21.000Z</published>
    <updated>2020-11-22T09:31:52.040Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：</p><p><code>给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。</code></p><p><code>请返回 nums 的动态和。</code></p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：[1,3,6,10]</span><br><span class="line">解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1]</span><br><span class="line">输出：[1,2,3,4,5]</span><br><span class="line">解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,2,10,1]</span><br><span class="line">输出：[3,4,6,16,17]</span><br></pre></td></tr></table></figure><p><strong>思路</strong>：遍历相加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] runningSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] s = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        s[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)</span><br><span class="line">            s[i] = s[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">        <span class="comment">// System.out.println(s);</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201122172958636.png#pic" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;请返回 nums 的动态和。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [1,2,3,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[1,3,6,10]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>小白 LeetCode 5605 检查两个字符串数据是否相等</title>
    <link href="http://1979F.github.io/2020/11/22/%E5%B0%8F%E7%99%BD%20LeetCode%205605%20%E6%A3%80%E6%9F%A5%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
    <id>http://1979F.github.io/2020/11/22/小白 LeetCode 5605 检查两个字符串数据是否相等/</id>
    <published>2020-11-22T09:07:07.000Z</published>
    <updated>2020-11-22T09:08:24.420Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目</strong>：<code>给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。</code></p><p><strong>数组表示的字符串</strong> 是由数组中的所有元素 按顺序 连接形成的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = [<span class="string">"ab"</span>, <span class="string">"c"</span>], word2 = [<span class="string">"a"</span>, <span class="string">"bc"</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">word1 表示的字符串为 <span class="string">"ab"</span> + <span class="string">"c"</span> -&gt; <span class="string">"abc"</span></span><br><span class="line">word2 表示的字符串为 <span class="string">"a"</span> + <span class="string">"bc"</span> -&gt; <span class="string">"abc"</span></span><br><span class="line">两个字符串相同，返回 <span class="keyword">true</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = [<span class="string">"a"</span>, <span class="string">"cb"</span>], word2 = [<span class="string">"ab"</span>, <span class="string">"c"</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：word1  = [<span class="string">"abc"</span>, <span class="string">"d"</span>, <span class="string">"defg"</span>], word2 = [<span class="string">"abcddefg"</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>思路</strong>：先把字符串数组合并成字符串，再比较两个字符串是否相等，若相等，则返回true；否则，返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">arrayStringsAreEqual</span><span class="params">(String[] word1, String[] word2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String s1 = <span class="string">""</span>;</span><br><span class="line">        String s2 = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.length; i++)&#123;</span><br><span class="line">            s1 = s1.concat(word1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word2.length; j++)&#123;</span><br><span class="line">            s2 = s2.concat(word2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s1.equals(s2))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201122170548350.png#pic" alt="在这里插入图片描述"></p><ul><li>concat() 方法：<code>用于将指定的字符串参数连接到字符串上。</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题目&lt;/strong&gt;：&lt;code&gt;给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数组表示的字符串&lt;/strong&gt; 是由数组中的所有元素 按顺序 连接形成的字符串。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：word1 = [&lt;span class=&quot;string&quot;&gt;&quot;ab&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt;], word2 = [&lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bc&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;word1 表示的字符串为 &lt;span class=&quot;string&quot;&gt;&quot;ab&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;c&quot;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;word2 表示的字符串为 &lt;span class=&quot;string&quot;&gt;&quot;a&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;bc&quot;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;两个字符串相同，返回 &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>小白 LeetCode 242  有效的字母异位词</title>
    <link href="http://1979F.github.io/2020/11/22/%E5%B0%8F%E7%99%BD%20LeetCode%20242%20%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>http://1979F.github.io/2020/11/22/小白 LeetCode 242  有效的字母异位词/</id>
    <published>2020-11-22T08:39:27.000Z</published>
    <updated>2020-11-22T08:40:50.312Z</updated>
    
    <content type="html"><![CDATA[<p><strong>字母异位词</strong></p><p>字符串由相同字母组成，但允许排列顺序不同。<br>如“aaabbb” 与 “ababab” 是字母异位词，<br>而“aabb” 与 “ab” 不是字母异位词。</p><p>题目：<code>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">"anagram"</span>, t = <span class="string">"nagaram"</span></span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">"rat"</span>, t = <span class="string">"car"</span></span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>思路：先判断字符串长度是否相同，若不同，直接返回false；若相同则继续判断，给两个字符串排序，若排序后的字符串完全相等，那么返回true，否则，返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = s.length();</span><br><span class="line">        <span class="keyword">int</span> lt = t.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ls != lt)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span>[] arrayS = s.toCharArray(); <span class="comment">//把字符串转换为数组</span></span><br><span class="line">            <span class="keyword">char</span>[] arrayT = t.toCharArray();</span><br><span class="line">            Arrays.sort(arrayS); <span class="comment">//利用数组帮助类自动排序</span></span><br><span class="line">            Arrays.sort(arrayT);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(Arrays.equals(arrayS, arrayT))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201122163611486.png#pic" alt="在这里插入图片描述"></p><ul><li>字符串转为数组 <code>.toCharArray()</code></li><li>数组排序：<code>Arrays.sort(array)</code></li><li>判断数组是否相同：<code>Arrays.equals(array1, array2)</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;字符串由相同字母组成，但允许排列顺序不同。&lt;br&gt;如“aaabbb” 与 “ababab” 是字母异位词，&lt;br&gt;而“aabb” 与 “ab” 不是字母异位词。&lt;/p&gt;&lt;p&gt;题目：&lt;code&gt;给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。&lt;/code&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s = &lt;span class=&quot;string&quot;&gt;&quot;anagram&quot;&lt;/span&gt;, t = &lt;span class=&quot;string&quot;&gt;&quot;nagaram&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="LeetCode" scheme="http://1979F.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter notebook 导入和卸载 conda 虚拟环境</title>
    <link href="http://1979F.github.io/2020/11/21/Jupyter%20notebook%20%E5%AF%BC%E5%85%A5%E5%92%8C%E5%8D%B8%E8%BD%BD%20conda%20%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://1979F.github.io/2020/11/21/Jupyter notebook 导入和卸载 conda 虚拟环境/</id>
    <published>2020-11-21T03:10:32.000Z</published>
    <updated>2020-11-22T05:45:15.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、导入"><a href="#一、导入" class="headerlink" title="一、导入"></a>一、导入</h3><p>进入Anaconda Prompt，激活要使用的虚拟环境。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate xxx <span class="comment"># 你要使用的虚拟环境名称</span></span><br></pre></td></tr></table></figure><p>安装 ipykernel 插件， 建议使用 pip 进行安装， conda 安装容易失败</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install ipykernel</span><br></pre></td></tr></table></figure><p>安装完成之后，键入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m ipykernel install --name (你要导入的虚拟环境名称)  --display-name (你要显示的名称)</span><br></pre></td></tr></table></figure><a id="more"></a><p>例如：<br><img src="https://img-blog.csdnimg.cn/20201121110206620.png#pic" alt="在这里插入图片描述"><br>打开 jupyter notebook， 可以看到环境已经成功导入</p><p><img src="https://img-blog.csdnimg.cn/2020112111081565.png#pic" alt="在这里插入图片描述"></p><h3 id="二、删除"><a href="#二、删除" class="headerlink" title="二、删除"></a>二、删除</h3><p>使用命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter kernelspec remove (你要删除的虚拟环境名称  注意不是显示名称)</span><br></pre></td></tr></table></figure><p>例如：<br><img src="https://img-blog.csdnimg.cn/20201121111008966.png#pic" alt="在这里插入图片描述"><br>删除成功 ！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、导入&quot;&gt;&lt;a href=&quot;#一、导入&quot; class=&quot;headerlink&quot; title=&quot;一、导入&quot;&gt;&lt;/a&gt;一、导入&lt;/h3&gt;&lt;p&gt;进入Anaconda Prompt，激活要使用的虚拟环境。&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;conda activate xxx &lt;span class=&quot;comment&quot;&gt;# 你要使用的虚拟环境名称&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;安装 ipykernel 插件， 建议使用 pip 进行安装， conda 安装容易失败&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pip install ipykernel&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;安装完成之后，键入以下命令&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;python -m ipykernel install --name (你要导入的虚拟环境名称)  --display-name (你要显示的名称)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>leaf 叶子(张量)</title>
    <link href="http://1979F.github.io/2020/11/20/leaf%20%E5%8F%B6%E5%AD%90(%E5%BC%A0%E9%87%8F)/"/>
    <id>http://1979F.github.io/2020/11/20/leaf 叶子(张量)/</id>
    <published>2020-11-20T13:07:34.000Z</published>
    <updated>2020-11-22T05:46:02.559Z</updated>
    
    <content type="html"><![CDATA[<p>在pytorch的tensor类中,有个<strong>is_leaf</strong>的属性,姑且把它作为叶子节点. <strong>is_leaf</strong> 为<strong>False</strong>的时候,则不是叶子节点, <strong>is_leaf</strong>为<strong>True</strong>的时候为叶子节点(或者叶张量)</p><p><strong>所以问题来了</strong>: <strong><em>leaf的作用是什么?为什么要加 leaf?</em></strong><br> 我们都知道tensor中的 requires_grad()属性，当requires_grad()为True时我们将会记录tensor的运算过程并为自动求导做准备，但是并不是每个requires_grad()设为True的值都会在backward的时候得到相应的grad，它还必须为leaf。这就说明： <strong><em><code>leaf成为了在 requires_grad()下判断是否需要保留 grad的前提条件</code></em></strong></p><a id="more"></a>  <h4><a id="_is_leaf__8"></a><em>is_leaf()</em></h4> <ol><li>按照惯例,所有requires_grad为False的张量(Tensor) 都为叶张量( leaf Tensor)</li><li>requires_grad为True的张量(Tensor),如果他们是由用户创建的,则它们是叶张量(leaf Tensor).这意味着它们不是运算的结果,因此gra_fn为None</li><li>只有是叶张量的tensor在反向传播时才会将本身的grad传入的backward的运算中. 如果想得到当前tensor在反向传播时的grad, 可以用retain_grad()这个属性</li></ol> <p>例子:</p> <pre class="prettyprint"><code class="prism language-python has-numbering" onclick="mdcp.signin(event)" style="position: unset;"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> a<span class="token punctuation">.</span>is_leaf<span class="token boolean">True</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> b<span class="token punctuation">.</span>is_leaf<span class="token boolean">False</span><span class="token comment"># b was created by the operation that cast a cpu Tensor into a cuda Tensor</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> c <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> c<span class="token punctuation">.</span>is_leaf<span class="token boolean">False</span><span class="token comment"># c was created by the addition operation</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> d <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> d<span class="token punctuation">.</span>is_leaf<span class="token boolean">True</span><span class="token comment"># d does not require gradients and so has no operation creating it (that is tracked by the autograd engine)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> e <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cuda<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> e<span class="token punctuation">.</span>is_leaf<span class="token boolean">True</span><span class="token comment"># e requires gradients and has no operations creating it</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token string">"cuda"</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> f<span class="token punctuation">.</span>is_leaf<span class="token boolean">True</span><span class="token comment"># f requires grad, has no operation creating it</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在pytorch的tensor类中,有个&lt;strong&gt;is_leaf&lt;/strong&gt;的属性,姑且把它作为叶子节点. &lt;strong&gt;is_leaf&lt;/strong&gt; 为&lt;strong&gt;False&lt;/strong&gt;的时候,则不是叶子节点, &lt;strong&gt;is_leaf&lt;/strong&gt;为&lt;strong&gt;True&lt;/strong&gt;的时候为叶子节点(或者叶张量)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;所以问题来了&lt;/strong&gt;: &lt;strong&gt;&lt;em&gt;leaf的作用是什么?为什么要加 leaf?&lt;/em&gt;&lt;/strong&gt;&lt;br&gt; 我们都知道tensor中的 requires_grad()属性，当requires_grad()为True时我们将会记录tensor的运算过程并为自动求导做准备，但是并不是每个requires_grad()设为True的值都会在backward的时候得到相应的grad，它还必须为leaf。这就说明： &lt;strong&gt;&lt;em&gt;&lt;code&gt;leaf成为了在 requires_grad()下判断是否需要保留 grad的前提条件&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习 PyTorch版》学习笔记（三）：线性回归</title>
    <link href="http://1979F.github.io/2020/10/09/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://1979F.github.io/2020/10/09/《动手学深度学习 PyTorch版》学习笔记（三）：线性回归/</id>
    <published>2020-10-09T06:59:41.000Z</published>
    <updated>2020-11-22T05:41:11.015Z</updated>
    
    <content type="html"><![CDATA[<p>线性回归输出是一个连续值，因此适用于回归问题。回归问题在实际中很常见，如预测房屋价格、气温、销售额等连续值的问题。</p><h3 id="一、基本要素"><a href="#一、基本要素" class="headerlink" title="一、基本要素"></a>一、基本要素</h3><p><code>摘自原书</code></p><p><strong>模型定义</strong></p><p>设房屋的面积为 x1，房龄为 x2，售出价格为 y。我们需要建立基于输入 x1 和 x2 来计算输出 y 的表达式，也就是 <strong><code>模型（model）</code></strong> 。顾名思义，线性回归假设输出与各个输入之间是线性关系：<br><img src="https://img-blog.csdnimg.cn/20201009100323806.png#pic_center" alt="在这里插入图片描述"><br>其中 w1 和 w2 是 <strong><code>权重（weight）</code></strong>，b 是 <strong><code>偏差（bias）</code></strong>，且均为标量。它们是线性回归模型的  参数（parameter）。模型输出 yˆ  是线性回归对真实价格 y 的预测或估计。我们通常允许它们之间有一定误差。</p><a id="more"></a><p><strong>模型训练</strong></p><p>我们需要通过数据来寻找特定的模型参数值，使模型在数据上的误差尽可能小。这个过程叫作 <strong><code>模型训练（model training）</code></strong>，包含三个要素：</p><ul><li>训练数据</li></ul><p>我们通常收集一系列的真实数据，例如多栋房屋的真实售出价格和它们对应的面积和房龄。我们希望在这个数据上面寻找模型参数来使模型的预测价格与真实价格的误差最小。在机器学习术语里，该数据集被称为 <strong><code>训练数据集（training data set）</code></strong> 或 <strong><code>训练集（training set）</code></strong> ，一栋房屋被称为一个  <strong><code>样本（sample）</code></strong>  ，其真实售出价格叫作 <strong><code>标签（label）</code></strong> ，用来预测标签的两个因素叫作  <strong><code>特征（feature）</code></strong>。特征用来表征样本的特点。<br><img src="https://img-blog.csdnimg.cn/20201009101536359.png#pic_center" alt="在这里插入图片描述"></p><ul><li>损失函数</li></ul><p>在模型训练中，我们需要衡量价格预测值与真实值之间的误差。通常我们会选取一个非负数作为误差，且数值越小表示误差越小。一个常用的选择是平方函数。它在评估索引为 i 的样本误差的表达式为：<br><img src="https://img-blog.csdnimg.cn/20201009101639483.png#pic_center" alt="在这里插入图片描述"><br>其中常数 1/2 使对平方项求导后的常数系数为1，这样在形式上稍微简单一些。显然，误差越小表示预测价格与真实价格越相近，且当二者相等时误差为0。给定训练数据集，这个误差只与模型参数相关，因此我们将它记为以模型参数为参数的函数。在机器学习里，将衡量误差的函数称为 <strong><code>损失函数（loss function）</code></strong> 。这里使用的平方误差函数也称为 <strong><code>平方损失（square loss）</code></strong> 。<br>通常，我们用训练数据集中所有样本误差的平均来衡量模型预测的质量，即<br><img src="https://img-blog.csdnimg.cn/20201009101817831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>优化算法</li></ul><p>当模型和损失函数形式较为简单时，上面的误差最小化问题的解可以直接用公式表达出来。这类解叫作 <strong><code>解析解（analytical solution）</code></strong> 。本节使用的线性回归和平方误差刚好属于这个范畴。然而，大多数深度学习模型并没有解析解，<strong>只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值</strong>。这类解叫作 <strong><code>数值解（numerical solution）</code></strong>。</p><p>在求数值解的优化算法中，<strong>小批量随机梯度下降（mini-batch stochastic gradient descent）</strong> 在深度学习中被广泛使用。它的算法很简单：先选取一组模型参数的初始值，如随机选取；接下来对参数进行多次迭代，使每次迭代都可能降低损失函数的值。在每次迭代中，先随机均匀采样一个由固定数目训练数据样本所组成的小批量（mini-batch）B，然后求小批量中数据样本的平均损失有关模型参数的导数（梯度），最后用此结果与预先设定的一个正数的乘积作为模型参数在本次迭代的减小量。</p><p>在训练本节讨论的线性回归模型的过程中，模型的每个参数将作如下迭代：<br><img src="https://img-blog.csdnimg.cn/20201009103857374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201009103924921.png#pic_center" alt="在这里插入图片描述"></p><ul><li>模型预测</li></ul><p><img src="https://img-blog.csdnimg.cn/20201009105609277.png#pic_center" alt="在这里插入图片描述"></p><h3 id="二、线性回归的表示方法"><a href="#二、线性回归的表示方法" class="headerlink" title="二、线性回归的表示方法"></a>二、线性回归的表示方法</h3><p>如果我们对训练数据集里的3个房屋样本（索引分别为1、2和3）逐一预测价格<br><img src="https://img-blog.csdnimg.cn/20201009124246381.png#pic_center" alt="在这里插入图片描述"><br>现在，我们将上面3个等式转化成矢量计算。设：</p><p><img src="https://img-blog.csdnimg.cn/2020100912431818.png#pic_center" alt="在这里插入图片描述"><br>对3个房屋样本预测价格的矢量计算表达式为yˆ=Xw+b, 其中的加法运算使用了 <code>广播机制</code></p><p> <img src="https://img-blog.csdnimg.cn/20201009145117634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RzdW5kZXJlX3g=,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性回归输出是一个连续值，因此适用于回归问题。回归问题在实际中很常见，如预测房屋价格、气温、销售额等连续值的问题。&lt;/p&gt;&lt;h3 id=&quot;一、基本要素&quot;&gt;&lt;a href=&quot;#一、基本要素&quot; class=&quot;headerlink&quot; title=&quot;一、基本要素&quot;&gt;&lt;/a&gt;一、基本要素&lt;/h3&gt;&lt;p&gt;&lt;code&gt;摘自原书&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;模型定义&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;设房屋的面积为 x1，房龄为 x2，售出价格为 y。我们需要建立基于输入 x1 和 x2 来计算输出 y 的表达式，也就是 &lt;strong&gt;&lt;code&gt;模型（model）&lt;/code&gt;&lt;/strong&gt; 。顾名思义，线性回归假设输出与各个输入之间是线性关系：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201009100323806.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其中 w1 和 w2 是 &lt;strong&gt;&lt;code&gt;权重（weight）&lt;/code&gt;&lt;/strong&gt;，b 是 &lt;strong&gt;&lt;code&gt;偏差（bias）&lt;/code&gt;&lt;/strong&gt;，且均为标量。它们是线性回归模型的  参数（parameter）。模型输出 yˆ  是线性回归对真实价格 y 的预测或估计。我们通常允许它们之间有一定误差。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习 PyTorch版》学习笔记（二）：自动求梯度</title>
    <link href="http://1979F.github.io/2020/10/08/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%87%AA%E5%8A%A8%E6%B1%82%E6%A2%AF%E5%BA%A6/"/>
    <id>http://1979F.github.io/2020/10/08/《动手学深度学习 PyTorch版》学习笔记（二）：自动求梯度/</id>
    <published>2020-10-08T15:28:53.000Z</published>
    <updated>2020-11-22T05:41:50.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、自动求梯度"><a href="#一、自动求梯度" class="headerlink" title="一、自动求梯度"></a>一、自动求梯度</h2><p><strong>1、requires_grad_(), detach(), torch.no_grad()的区别</strong><br>参考博客：<a href="https://www.jianshu.com/p/ff74ccae25f3" target="_blank" rel="noopener">https://www.jianshu.com/p/ff74ccae25f3</a></p><p><strong>2、.grad_fn</strong><br>每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function, 就是说该Tensor是不是通过某些运算得到的，若是，则grad_fn返回一个与这些运算相关的对象，否则是None。</p><a id="more"></a><p><strong>3、梯度</strong></p><ul><li>grad在反向传播过程中是累加的(accumulated)，这意味着每一次运行反向传播，梯度都会累加之前的梯度，所以一般在反向传播之前需把梯度清零 <code>.grad.data.zero_()</code></li><li>在y.backward()时，如果y是标量，则不需要为backward()传入任何参数；否则，需要传入一个与y同形的Tensor</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = <span class="number">2</span> * x</span><br><span class="line">z = y.view(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">2.</span>, <span class="number">4.</span>],</span><br><span class="line">        [<span class="number">6.</span>, <span class="number">8.</span>]], grad_fn=&lt;ViewBackward&gt;)</span><br></pre></td></tr></table></figure><p>现在 z 不是一个标量，所以在调用backward时需要传入一个和z同形的权重向量进行加权求和得到一个标量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v = torch.tensor([[<span class="number">1.0</span>, <span class="number">0.1</span>], [<span class="number">0.01</span>, <span class="number">0.001</span>]], dtype=torch.float)</span><br><span class="line">z.backward(v)</span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([<span class="number">2.0000</span>, <span class="number">0.2000</span>, <span class="number">0.0200</span>, <span class="number">0.0020</span>])</span><br></pre></td></tr></table></figure><p><strong>4、中断梯度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor(<span class="number">1.0</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y1 = x ** <span class="number">2</span> </span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    y2 = x ** <span class="number">3</span></span><br><span class="line">y3 = y1 + y2</span><br><span class="line"></span><br><span class="line">print(x.requires_grad)</span><br><span class="line">print(y1, y1.requires_grad) <span class="comment"># True</span></span><br><span class="line">print(y2, y2.requires_grad) <span class="comment"># False</span></span><br><span class="line">print(y3, y3.requires_grad) <span class="comment"># True</span></span><br><span class="line">y3.backward()</span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20201008232836301.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、自动求梯度&quot;&gt;&lt;a href=&quot;#一、自动求梯度&quot; class=&quot;headerlink&quot; title=&quot;一、自动求梯度&quot;&gt;&lt;/a&gt;一、自动求梯度&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1、requires_grad_(), detach(), torch.no_grad()的区别&lt;/strong&gt;&lt;br&gt;参考博客：&lt;a href=&quot;https://www.jianshu.com/p/ff74ccae25f3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/ff74ccae25f3&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、.grad_fn&lt;/strong&gt;&lt;br&gt;每个Tensor都有一个.grad_fn属性，该属性即创建该Tensor的Function, 就是说该Tensor是不是通过某些运算得到的，若是，则grad_fn返回一个与这些运算相关的对象，否则是None。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《动手学深度学习 PyTorch版》学习笔记（一）：数据操作</title>
    <link href="http://1979F.github.io/2020/10/08/%E3%80%8A%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20PyTorch%E7%89%88%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    <id>http://1979F.github.io/2020/10/08/《动手学深度学习 PyTorch版》学习笔记（一）：数据操作/</id>
    <published>2020-10-08T14:57:32.000Z</published>
    <updated>2020-11-22T05:42:22.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据操作"><a href="#一、数据操作" class="headerlink" title="一、数据操作"></a>一、数据操作</h2><p>在PyTorch中，torch.Tensor是存储和变换数据的主要工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;tensor&quot;这个单词一般可译作“张量”，张量可以看作是一个多维数组。</span><br><span class="line">标量可以看作是0维张量，向量可以看作1维张量，矩阵可以看作是二维张量。</span><br></pre></td></tr></table></figure><p><strong>1、torch.arange() 和torch.linspace</strong></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arange(s, e, step) =&gt; 从s到e，步长为step</span></span><br><span class="line">x8 = torch.arange(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># print(x8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># linspace(s, e, steps) =&gt; 从s到e，均匀切分成steps份</span></span><br><span class="line">x9 = torch.linspace(<span class="number">2</span>,<span class="number">8</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># print(x9)</span></span><br></pre></td></tr></table></figure><p><strong>2、torch.range() 和torch.arange() 的区别</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y=torch.range(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">tensor([<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.dtype</span><br><span class="line">torch.float32</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z=torch.arange(<span class="number">1</span>,<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z.dtype</span><br><span class="line">torch.int64</span><br></pre></td></tr></table></figure><p><strong>3、torch.randn与torch.rand的区别</strong></p><p><strong>randn</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.randn(*sizes, out=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>返回一个包含了从<code>标准正态分布</code>中抽取的一组随机数的张量</p><p><code>size</code>：张量的形状</p><p><code>out</code>：结果张量</p><p><strong>rand</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.rand(*sizes, out=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>返回一个张量，包含了从区间[0, 1)的<code>均匀分布</code>中抽取的一组随机数</p><p><strong>4、NumPy数组与Tensor的互相转换</strong>（共享内存）</p><p>NumPy转Tensor：<code>torch.from_numpy()</code><br>Tensor转NumPy：<code>numpy()</code><br>另：可以使用 torch.tensor() 将NumPy数组转换成Tensor，但不再共享内存</p><p><strong>5、Tensor on GPU</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span>)          <span class="comment"># GPU</span></span><br><span class="line">    y = torch.ones_like(x, device=device)  <span class="comment"># 直接创建一个在GPU上的Tensor</span></span><br><span class="line">    x = x.to(device)                       <span class="comment"># 等价于 .to("cuda")</span></span><br><span class="line">    z = x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(<span class="string">"cpu"</span>, torch.double))       <span class="comment"># to()还可以同时更改数据类型</span></span><br></pre></td></tr></table></figure><p><strong>6、索引</strong></p><p>索引出来的结果与元数据共享内存 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">print(x)</span><br><span class="line">y = x[<span class="number">0</span>, :]  <span class="comment"># 取出第一行</span></span><br><span class="line">print(y)</span><br><span class="line">y += <span class="number">1</span></span><br><span class="line">print(y)</span><br><span class="line">print(x[<span class="number">0</span>, :]) <span class="comment"># 源tensor也被改了</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">tensor([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">tensor([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">tensor([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p><strong>7、广播机制</strong></p><p>当对两个形状不同的Tensor按元素运算时，可能会触发广播（broadcasting）机制：先适当复制元素使这两个Tensor形状相同后再按元素运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">1</span>, <span class="number">3</span>).view(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(x)</span><br><span class="line">y = torch.arange(<span class="number">1</span>, <span class="number">4</span>).view(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">print(y)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tensor([[<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line">tensor([[<span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>],</span><br><span class="line">        [<span class="number">3</span>]])</span><br><span class="line">tensor([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">        [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、数据操作&quot;&gt;&lt;a href=&quot;#一、数据操作&quot; class=&quot;headerlink&quot; title=&quot;一、数据操作&quot;&gt;&lt;/a&gt;一、数据操作&lt;/h2&gt;&lt;p&gt;在PyTorch中，torch.Tensor是存储和变换数据的主要工具。&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;tensor&amp;quot;这个单词一般可译作“张量”，张量可以看作是一个多维数组。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;标量可以看作是0维张量，向量可以看作1维张量，矩阵可以看作是二维张量。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;1、torch.arange() 和torch.linspace&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>torch.randn与torch.rand的区别</title>
    <link href="http://1979F.github.io/2020/10/05/torch.randn%E4%B8%8Etorch.rand%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://1979F.github.io/2020/10/05/torch.randn与torch.rand的区别/</id>
    <published>2020-10-05T04:53:15.000Z</published>
    <updated>2020-11-22T07:01:48.362Z</updated>
    
    <content type="html"><![CDATA[<h4 id="randn"><a href="#randn" class="headerlink" title="randn"></a>randn</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.randn(*sizes, out=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>返回一个包含了从标准正态分布中抽取的一组随机数的张量</p><p><code>size</code>：张量的形状</p><p><code>out</code>：结果张量</p><h4 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.rand(*sizes, out=<span class="literal">None</span>) → Tensor</span><br></pre></td></tr></table></figure><p>[0,1)之间的均匀分布</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;randn&quot;&gt;&lt;a href=&quot;#randn&quot; class=&quot;headerlink&quot; title=&quot;randn&quot;&gt;&lt;/a&gt;randn&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch 之 requires_grad，requires_grad_()，grad_fn</title>
    <link href="http://1979F.github.io/2020/10/04/PyTorch%20%E4%B9%8B%20requires_grad%EF%BC%8Crequires_grad_()%EF%BC%8Cgrad_fn/"/>
    <id>http://1979F.github.io/2020/10/04/PyTorch 之 requires_grad，requires_grad_()，grad_fn/</id>
    <published>2020-10-04T11:33:52.000Z</published>
    <updated>2020-11-22T07:07:05.540Z</updated>
    
    <content type="html"><![CDATA[<ul><li>x.grad_fn和x.requires_grad为x的属性</li><li>x.grad_fn：积分方法名，默认为None</li><li>x.requires_grad：是否积分的属性，默认为False</li><li>x.requires_grad_()：设置积分的方法，设置之后requires_grad为True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""Tensor"""</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="comment"># 创建一个Tensor并设置requires_grad=True</span></span><br><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.grad_fn)</span><br><span class="line"></span><br><span class="line">y = x + <span class="number">2</span></span><br><span class="line">print(y)</span><br><span class="line">print(y.grad_fn)</span><br><span class="line"></span><br><span class="line">print(x.is_leaf, y.is_leaf)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;x.grad_fn和x.requires_grad为x的属性&lt;/li&gt;
&lt;li&gt;x.grad_fn：积分方法名，默认为None&lt;/li&gt;
&lt;li&gt;x.requires_grad：是否积分的属性，默认为False&lt;/li&gt;
&lt;li&gt;x.requires_grad_
      
    
    </summary>
    
    
    
      <category term="PyTorch" scheme="http://1979F.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>指定tensorflow运行的GPU或CPU设备</title>
    <link href="http://1979F.github.io/2020/07/29/%E6%8C%87%E5%AE%9Atensorflow%E8%BF%90%E8%A1%8C%E7%9A%84GPU%E6%88%96CPU%E8%AE%BE%E5%A4%87/"/>
    <id>http://1979F.github.io/2020/07/29/指定tensorflow运行的GPU或CPU设备/</id>
    <published>2020-07-29T08:11:15.000Z</published>
    <updated>2020-11-22T05:44:23.748Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>如果 TensorFlow 指令中兼有 CPU 和 GPU 实现，当该指令分配到设备时，GPU 设备有优先权。</p></li><li><p>如果你的系统里有多个 GPU, 那么 ID 最小的 GPU 会默认使用。</p></li></ul><p>当我们要指定tensorflow运行的GPU或CPU设备时，可以使用<code>tf.device()</code>命令</p><p> 首先查看可用运算设备(CPU,GPU)</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python.client <span class="keyword">import</span> device_lib</span><br><span class="line">print(device_lib.list_local_devices())</span><br></pre></td></tr></table></figure><p>得到类似以下的输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[name: <span class="string">"/device:CPU:0"</span></span><br><span class="line">device_type: <span class="string">"CPU"</span></span><br><span class="line">memory_limit: <span class="number">268435456</span></span><br><span class="line">locality &#123;</span><br><span class="line">&#125;</span><br><span class="line">incarnation: <span class="number">13177083330855175469</span></span><br><span class="line">, name: <span class="string">"/device:GPU:0"</span></span><br><span class="line">device_type: <span class="string">"GPU"</span></span><br><span class="line">memory_limit: <span class="number">10968950375</span></span><br><span class="line">locality &#123;</span><br><span class="line">  bus_id: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">incarnation: <span class="number">6161624703599064583</span></span><br><span class="line">physical_device_desc: <span class="string">"device: 0, name: GeForce GTX 1080 Ti, pci bus id: 0000:00:08.0, compute capability: 6.1"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>name即是对应设备名称，一般来说（以各自实际情况为准，每个人的情况可能不同）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;/cpu:0&quot;：机器的 CPU。</span><br><span class="line">&quot;/device:GPU:0&quot;：机器的 GPU（如果有一个）。</span><br><span class="line">&quot;/device:GPU:1&quot;：机器的第二个 GPU（以此类推）。</span><br></pre></td></tr></table></figure><p><strong>使用命令tf.device()进行指定</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"CUDA_VISIBLE_DEVICES"</span>] = <span class="string">'/device:GPU:0'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果 TensorFlow 指令中兼有 CPU 和 GPU 实现，当该指令分配到设备时，GPU 设备有优先权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你的系统里有多个 GPU, 那么 ID 最小的 GPU 会默认使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当我们要指定tensorflow运行的GPU或CPU设备时，可以使用&lt;code&gt;tf.device()&lt;/code&gt;命令&lt;/p&gt;&lt;p&gt; 首先查看可用运算设备(CPU,GPU)&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>module ‘tensorflow‘ has no attribute ‘sparse ‘</title>
    <link href="http://1979F.github.io/2020/07/29/module%20%E2%80%98tensorflow%E2%80%98%20has%20no%20attribute%20%E2%80%98sparse%20%E2%80%98/"/>
    <id>http://1979F.github.io/2020/07/29/module ‘tensorflow‘ has no attribute ‘sparse ‘/</id>
    <published>2020-07-29T07:50:49.000Z</published>
    <updated>2020-11-22T07:08:36.191Z</updated>
    
    <content type="html"><![CDATA[<p>非常奇怪的一个报错，在查找资料无果的情况下选择了重装keras（应该是版本对应出现了问题），报错解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;非常奇怪的一个报错，在查找资料无果的情况下选择了重装keras（应该是版本对应出现了问题），报错解决&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="深度学习" scheme="http://1979F.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
